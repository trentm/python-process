Note:
This document is a dump of all the changes made to process.py in the Komodo
(http://www.activestate.com/Products/Komodo) source tree up until Aug 2005
when I got back on track updating process.py in my personal SVN repository
here. Komodo was the project for which process.py was initially written.



Change 127511 by trentm@trentm-planer on 2005/01/25 10:21:36

	Some minor fixes: the internal _whichFirstArg can now raise
	which.WhichError. This has been true for a long time.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#74 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#74 (text) ====

@@ -128,6 +128,7 @@
 import types
 import pprint 
 import errno
+import logging
 
 if sys.platform.startswith("win"):
     import msvcrt
@@ -147,7 +148,7 @@
 else:
     import signal
 
-import logging
+import which
 
 
 #---- exceptions
@@ -164,9 +165,10 @@
 #   - 'log' to log normal process handling
 #   - 'logres' to track system resource life
 #   - 'logfix' to track wait/kill proxying in _ThreadFixer
+
 log = logging.getLogger("process")
-logres = logging.getLogger("process.res")
-logfix = logging.getLogger("process.waitfix")
+logres = logging.getLogger("process_res")
+logfix = logging.getLogger("process_waitfix")
 #log.setLevel(logging.DEBUG)
 #logres.setLevel(logging.DEBUG)
 #logfix.setLevel(logging.DEBUG)
@@ -237,7 +239,8 @@
     """Return the given command ensuring that the first arg (the command to
     launch) is a full path to an existing file.
 
-    Raise a ProcessError if no such executable could be found.
+    Raise a ProcessError or which.WhichError if no such executable could be
+    found.
     """
     # Parse out the first arg.
     if cmd.startswith('"'):
@@ -474,7 +477,7 @@
             # NT and not using command.com.
             try:
                 cmd = _whichFirstArg(cmd, env)
-            except ProcessError:
+            except (ProcessError, which.WhichError):
                 raise ProcessError("Could not find a suitable executable "\
                     "to launch for '%s'. On WinNT you must manually prefix "\
                     "shell commands and batch files with 'cmd.exe /c' to "\
@@ -500,7 +503,7 @@
             #      % (w9xpopen, comspec, cmd.replace('"', '\\"'))
             try:
                 cmd = _whichFirstArg(cmd, env)
-            except ProcessError:
+            except (ProcessError, which.WhichError):
                 raise ProcessError("Could not find a suitable executable "\
                     "to launch for '%s'. On Win9x you must manually prefix "\
                     "shell commands and batch files with 'command.com /c' "\
@@ -908,7 +911,7 @@
             # to ensure be have the full path to the executable to launch.
             try:
                 cmd = _whichFirstArg(cmd, self._env)
-            except ProcessError:
+            except (ProcessError, which.WhichError):
                 # Could not find the command, perhaps it is an internal
                 # shell command -- fallback to _fixupCommand
                 cmd = _fixupCommand(cmd, self._env)
Change 126161 by shanec@shanec-leverage on 2005/01/13 16:11:42

	fix http://bugs.activestate.com/show_bug.cgi?id=35970
	- perlapp fails to run if current buffer is on unc path

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#73 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#73 (text) ====

@@ -297,6 +297,16 @@
         values either be all ASCII or all unicode. Try to remove this burden
         from the user of process.py.
         """
+        
+        # XXX we may want to change the location of this check at some point,
+        # but this is the most central location to do it.
+        # if you try to run something with cwd==unc path then cmd.exe will
+        # force the cwd to the windows directory.  At the same time, *something*
+        # is still not initialized correctly, and some apps (eg. pdk apps) will
+        # fail to run properly.  Bug 35970 is an example.
+        if cwd and cwd.startswith(r'\\'):
+            cwd = None
+        
         isWin9x = win32api.GetVersionEx()[3] == VER_PLATFORM_WIN32_WINDOWS
         # On Win9x all keys and values of 'env' must be ASCII (XXX
         # Actually this is probably only true if the Unicode support
Change 122488 by shanec@shanec-tochtli on 2004/12/14 13:28:03

	catch EINTR signals and ignore them, this fixes reading/writing io to some apps.  Specificly, svn commit seems to do this and was causing problems with Komodo, even though the commit was successful.
	
	reference:
	http://www.gossamer-threads.com/lists/python/dev/364822
	
	r=trentm

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#72 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#72 (text) ====

@@ -127,6 +127,8 @@
 import threading
 import types
 import pprint 
+import errno
+
 if sys.platform.startswith("win"):
     import msvcrt
     import win32api
@@ -563,6 +565,17 @@
                      id(self), len(text), text)
         return text
 
+    def _read_no_intr(self, fd, buffersize):
+        """Like os.read, but retries on EINTR"""
+        while 1:
+            try:
+                return os.read(fd, buffersize)
+            except OSError, e:
+                if e.errno == errno.EINTR:
+                    continue
+                else:
+                    raise
+
     def read(self, nBytes=-1):
         # nBytes <= 0 means "read everything"
         #   Note that we are changing the "read everything" cue to
@@ -578,7 +591,7 @@
             if nBytes <= 0:
                 text, self._lineBuf = self._lineBuf, ""
                 while 1:
-                    t = os.read(self._descriptor, 4092)
+                    t = self._read_no_intr(self._descriptor, 4092)
                     if not t:
                         break
                     else:
@@ -589,7 +602,7 @@
                         self._lineBuf[:nBytes], self._lineBuf[nBytes:]
                 else:
                     nBytesToGo = nBytes - len(self._lineBuf)
-                    text = self._lineBuf + os.read(self._descriptor,
+                    text = self._lineBuf + self._read_no_intr(self._descriptor,
                                                    nBytesToGo)
                     self._lineBuf = ""
             return text
@@ -654,9 +667,20 @@
         else:
             raise "FileHandle.readline: no handle to read with"
 
+    def _write_no_intr(self, fd, s):
+        """Like os.write, but retries on EINTR"""
+        while 1:
+            try:
+                return os.write(fd, s)
+            except OSError, e:
+                if e.errno == errno.EINTR:
+                    continue
+                else:
+                    raise
+    
     def write(self, text):
         if self._descriptor is not None:
-            os.write(self._descriptor, text)
+            self._write_no_intr(self._descriptor, text)
         elif self._handle is not None:
             try:
                 errCode, nBytesWritten = win32file.WriteFile(self._handle, text)
@@ -901,6 +925,17 @@
                                    % (cmd, ex.args[2]),
                                errno=ex.args[0])
 
+    def _waitpid_no_intr(self, pid, options):
+        """Like os.waitpid, but retries on EINTR"""
+        while 1:
+            try:
+                return os.waitpid(pid, options)
+            except OSError, e:
+                if e.errno == errno.EINTR:
+                    continue
+                else:
+                    raise
+
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
         
@@ -953,7 +988,7 @@
             else:
                 if timeout is None:
                     timeout = 0
-                pid, sts = os.waitpid(self._pid, timeout)
+                pid, sts = self._waitpid_no_intr(self._pid, timeout)
                 if pid == self._pid:
                     self.__retvalCache = retval = sts
                 else:
Change 116864 by trentm@trentm-planer on 2004/10/27 14:52:12

	Avoid this warning: 
		...\process.py:1750: DeprecationWarning: integer argument expected, got float

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#71 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#71 (text) ====

@@ -927,7 +927,7 @@
             if timeout is None:
                 timeout = win32event.INFINITE
             else:
-                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+                timeout = timeout * 1000 # Win32 API's timeout is in millisecs
 
             rc = win32event.WaitForSingleObject(self._hProcess, timeout)
             if rc == win32event.WAIT_FAILED:
@@ -1745,7 +1745,7 @@
             if timeout is None:
                 timeout = win32event.INFINITE
             else:
-                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+                timeout = timeout * 1000 # Win32 API's timeout is in millisecs
 
             rc = win32event.WaitForSingleObject(self._hProcess, timeout)
             if rc == win32event.WAIT_FAILED:
Change 109446 by trentm@trentm-planer on 2004/08/03 21:48:57

	Fix typos in docstrings.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#70 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#70 (text) ====

@@ -12,7 +12,7 @@
     Process:
         Use this class to simply launch a process (either a GUI app or a
         console app in a new console) with which you do not intend to
-        communicate via it std handles.
+        communicate via its std handles.
 
     ProcessOpen:
         Think of this as a super version of Python's os.popen3() method.
@@ -721,7 +721,7 @@
 
 class _CountingCloser:
     """Call .close() on the given object after own .close() is called
-    the precribed number of times.
+    the prescribed number of times.
     """
     def __init__(self, objectsToClose, count):
         """
Change 106376 by trentm@trentm-planer-automation on 2004/07/08 10:29:11

	Fix http://bugs.activestate.com/Komodo/show_bug.cgi?id=32639
	"SCC Diff doesn't show last line if no EOL"
	
	This was a bug in process.py's ProcessOpen.stdout.readline() method
	-- which was being used by p4lib.py's P4.diff() routine for Komodo SCC
	Diff.
	
	The problem was introduced in change 46646 which (presumably) was
	fixing a hang/infinite-loop or something. Either the semantic of
	_FileWrapper.read()'s handling of self._lineBuf was mis-interpreted
	then or it has changed in the interim such that self._lineBuf was
	emptied in .read() (called by .readline()) before .readline() tried
	to use it. "t", in this case, returns the necessary data. This code
	could use a revisiting.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#69 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#69 (text) ====

@@ -569,6 +569,11 @@
         #   include 0, because actually doing
         #   win32file.ReadFile(<handle>, 0) results in every subsequent
         #   read returning 0, i.e. it shuts down the pipe.
+        #XXX The currently usage of this by self.readline() can result in
+        #    multiple descriptor/handle/whatever .read()'s after a previous
+        #    read has indicated that the pipe is done. This should not be
+        #    done. I am not sure that there are adverse side-effects but
+        #    it should be easy to avoid doing so.
         if self._descriptor is not None:
             if nBytes <= 0:
                 text, self._lineBuf = self._lineBuf, ""
@@ -624,7 +629,7 @@
                     lengthBefore = len(self._lineBuf)
                     t = self.read(4092)
                     if len(t) <= lengthBefore: # no new data was read
-                        line, self._lineBuf = self._lineBuf, ""
+                        line, self._lineBuf = t, ""
                         break
                     else:
                         self._lineBuf += t
Change 103735 by trentm@trentm-planer-other on 2004/06/14 18:40:10

	Escape arguments containing '<' and/or '>'.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#68 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#68 (text) ====

@@ -191,9 +191,11 @@
         >>> import os
         >>> _joinArgv(['foo', 'bar "baz'])
         'foo "bar \\"baz"'
+        >>> _joinArgv(["foo", "<bar>"])
+        'foo "<bar>"'
     """
     cmdstr = ""
-    specialChars = [';', ' ', '=']
+    specialChars = [';', ' ', '=', '<', '>']
     for arg in argv:
         if arg == '':
             cmdstr += '""'
Change 73508 by shanec@shanec-leverage on 2003/08/18 13:37:15

	fix http://bugs.activestate.com/show_bug.cgi?id=23562
	- fix it again since we dont use process.cpp any longer

Affected files ...

... //depot/main/Apps/Komodo-devel/src/invocations/koInvokeInterpreters.py#64 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#67 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/invocations/koInvokeInterpreters.py#64 (text) ====

@@ -50,12 +50,15 @@
     cmdstr = ""
     specialChars = [';', ' ', '=']
     for arg in argv:
-        for ch in specialChars:
-            if ch in arg:
-                cmdstr += '"%s"' % _escapeArg(arg)
-                break
+        if arg == '':
+            cmdstr += '""'
         else:
-            cmdstr += _escapeArg(arg)
+            for ch in specialChars:
+                if ch in arg:
+                    cmdstr += '"%s"' % _escapeArg(arg)
+                    break
+            else:
+                cmdstr += _escapeArg(arg)
         cmdstr += ' '
     if cmdstr.endswith(' '): cmdstr = cmdstr[:-1]  # strip trailing space
     return cmdstr

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#67 (text) ====

@@ -195,12 +195,15 @@
     cmdstr = ""
     specialChars = [';', ' ', '=']
     for arg in argv:
-        for ch in specialChars:
-            if ch in arg:
-                cmdstr += '"%s"' % _escapeArg(arg)
-                break
+        if arg == '':
+            cmdstr += '""'
         else:
-            cmdstr += _escapeArg(arg)
+            for ch in specialChars:
+                if ch in arg:
+                    cmdstr += '"%s"' % _escapeArg(arg)
+                    break
+            else:
+                cmdstr += _escapeArg(arg)
         cmdstr += ' '
     if cmdstr.endswith(' '): cmdstr = cmdstr[:-1]  # strip trailing space
     return cmdstr
Change 73265 by trentm@trentm-planer on 2003/08/13 12:50:06

	Add '=' to the set of characters (space, ';') that will cause the
	containing arg to get quoted for the shell. This was initiated by the
	PDK integration using a perlapp option of the form:
		--info foo=bar
	When passed to the shell this need to be:
		--info "foo=bar"

Affected files ...

... //depot/main/Apps/Komodo-devel/src/install/customactions.unprocessed.py#6 edit
... //depot/main/Apps/Komodo-devel/src/invocations/koInvokeInterpreters.py#63 edit
... //depot/main/Apps/Komodo-devel/src/misc-components/koSysUtils.py#23 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#66 edit
... //depot/main/Apps/Komodo-devel/src/run/koRunService.py#50 edit
... //depot/main/Apps/Komodo-devel/src/scc/cvs/cvslib.py#17 edit
... //depot/main/Apps/Komodo-devel/src/scc/p4/p4lib.py#18 edit
... //depot/main/Apps/Komodo-devel/src/webservices/koWSProxyGenerator.py#9 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/install/customactions.unprocessed.py#6 (text) ====

@@ -160,9 +160,12 @@
         'foo "bar \\"baz"'
     """
     cmdstr = ""
+    specialChars = [';', ' ', '=']
     for arg in argv:
-        if ' ' in arg or ';' in arg:
-            cmdstr += '"%s"' % _escapeArg(arg)
+        for ch in specialChars:
+            if ch in arg:
+                cmdstr += '"%s"' % _escapeArg(arg)
+                break
         else:
             cmdstr += _escapeArg(arg)
         cmdstr += ' '

==== //depot/main/Apps/Komodo-devel/src/invocations/koInvokeInterpreters.py#63 (text) ====

@@ -48,9 +48,12 @@
         'foo "bar \\"baz"'
     """
     cmdstr = ""
+    specialChars = [';', ' ', '=']
     for arg in argv:
-        if ' ' in arg or ';' in arg:
-            cmdstr += '"%s"' % _escapeArg(arg)
+        for ch in specialChars:
+            if ch in arg:
+                cmdstr += '"%s"' % _escapeArg(arg)
+                break
         else:
             cmdstr += _escapeArg(arg)
         cmdstr += ' '

==== //depot/main/Apps/Komodo-devel/src/misc-components/koSysUtils.py#23 (text) ====

@@ -210,11 +210,15 @@
         'foo "bar \\"baz"'
     """
     cmdstr = ""
+    specialChars = [';', ' ', '=']
     for arg in argv:
-        if ' ' in arg or ';' in arg:
-            cmdstr += '"%s"' % _escapeArg(arg)
+        for ch in specialChars:
+            if ch in arg:
+                cmdstr += '"%s"' % _escapeArg(arg)
+                break
         else:
             cmdstr += _escapeArg(arg)
         cmdstr += ' '
     if cmdstr.endswith(' '): cmdstr = cmdstr[:-1]  # strip trailing space
     return cmdstr
+

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#66 (text) ====

@@ -193,9 +193,12 @@
         'foo "bar \\"baz"'
     """
     cmdstr = ""
+    specialChars = [';', ' ', '=']
     for arg in argv:
-        if ' ' in arg or ';' in arg:
-            cmdstr += '"%s"' % _escapeArg(arg)
+        for ch in specialChars:
+            if ch in arg:
+                cmdstr += '"%s"' % _escapeArg(arg)
+                break
         else:
             cmdstr += _escapeArg(arg)
         cmdstr += ' '

==== //depot/main/Apps/Komodo-devel/src/run/koRunService.py#50 (text) ====


==== //depot/main/Apps/Komodo-devel/src/scc/cvs/cvslib.py#17 (text) ====

@@ -94,7 +94,7 @@
     #XXX I suspect that there is a more that we should escape here.
     if not arg: return arg
     arg.replace('"', r'\"')
-    if (' ' in arg or ';' in arg) and not (arg.startswith('"') and arg.endswith('"')):
+    if (' ' in arg or ';' in arg or '=' in arg) and not (arg.startswith('"') and arg.endswith('"')):
         arg = '"' + arg + '"'
     return arg
 

==== //depot/main/Apps/Komodo-devel/src/scc/p4/p4lib.py#18 (text) ====

@@ -75,11 +75,14 @@
         'foo "bar \\"baz"'
     """
     cmdstr = ""
+    # Quote args with '*' because don't want shell to expand the
+    # argument. (XXX Perhaps that should only be done for Windows.)
+    specialChars = [';', ' ', '=', '*']
     for arg in argv:
-        # Quote args with '*' because don't want shell to expand the
-        # argument. (XXX Perhaps that should only be done for Windows.)
-        if ' ' in arg or '*' in arg or ';' in arg:
-            cmdstr += '"%s"' % _escapeArg(arg)
+        for ch in specialChars:
+            if ch in arg:
+                cmdstr += '"%s"' % _escapeArg(arg)
+                break
         else:
             cmdstr += _escapeArg(arg)
         cmdstr += ' '

==== //depot/main/Apps/Komodo-devel/src/webservices/koWSProxyGenerator.py#9 (text) ====

@@ -10,7 +10,7 @@
     #XXX I suspect that there is a more that we should escape here.
     if not arg: return arg
     arg.replace('"', r'\"')
-    if (' ' in arg or ';' in arg) and not (arg.startswith('"') and arg.endswith('"')):
+    if (' ' in arg or ';' in arg or '=' in arg) and not (arg.startswith('"') and arg.endswith('"')):
         arg = '"' + arg + '"'
     return arg
 
Change 68721 by trentm@trentm-planer on 2003/06/09 17:52:07

	Use Python's std logging.py for which Komodo provides a runtime
	interface. Also add some file handle closing guards for Python's
	runtime handles. I have been running my build with these guards for
	over a month.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#65 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#65 (text) ====

@@ -145,6 +145,8 @@
 else:
     import signal
 
+import logging
+
 
 #---- exceptions
 
@@ -156,67 +158,16 @@
 
 #---- internal logging facility
 
-class Logger:
-    DEBUG, INFO, WARN, ERROR, FATAL = range(5)
-    def __init__(self, name, level=None, streamOrFileName=sys.stderr):
-        self.name = name
-        if level is None:
-            self.level = self.WARN
-        else:
-            self.level = level
-        if type(streamOrFileName) == types.StringType:
-            self.stream = open(streamOrFileName, 'w')
-            self._opennedStream = 1
-        else:
-            self.stream = streamOrFileName
-            self._opennedStream = 0
-    def __del__(self):
-        if self._opennedStream:
-            self.stream.close()
-    def _getLevelName(self, level):
-        levelNameMap = {
-            self.DEBUG: "DEBUG",
-            self.INFO: "INFO",
-            self.WARN: "WARN",
-            self.ERROR: "ERROR",
-            self.FATAL: "FATAL",
-        }
-        return levelNameMap[level]
-    def log(self, level, msg, *args):
-        if level < self.level:
-            return
-        message = "%s: %s:" % (self.name, self._getLevelName(level).lower())
-        message = message + (msg % args) + "\n"
-        self.stream.write(message)
-        self.stream.flush()
-    def debug(self, msg, *args):
-        self.log(self.DEBUG, msg, *args)
-    def info(self, msg, *args):
-        self.log(self.INFO, msg, *args)
-    def warn(self, msg, *args):
-        self.log(self.WARN, msg, *args)
-    def error(self, msg, *args):
-        self.log(self.ERROR, msg, *args)
-    def fatal(self, msg, *args):
-        self.log(self.FATAL, msg, *args)
-
 # Loggers:
 #   - 'log' to log normal process handling
 #   - 'logres' to track system resource life
 #   - 'logfix' to track wait/kill proxying in _ThreadFixer
-if 1:   # normal/production usage
-    log = Logger("process", Logger.WARN)
-else:   # development/debugging usage
-    log = Logger("process", Logger.DEBUG, sys.stdout)
-if 1:   # normal/production usage
-    logres = Logger("process.res", Logger.WARN)
-else:   # development/debugging usage
-    logres = Logger("process.res", Logger.DEBUG, sys.stdout)
-if 1:   # normal/production usage
-    logfix = Logger("process.waitfix", Logger.WARN)
-else:   # development/debugging usage
-    logfix = Logger("process.waitfix", Logger.DEBUG, sys.stdout)
-
+log = logging.getLogger("process")
+logres = logging.getLogger("process.res")
+logfix = logging.getLogger("process.waitfix")
+#log.setLevel(logging.DEBUG)
+#logres.setLevel(logging.DEBUG)
+#logfix.setLevel(logging.DEBUG)
 
 
 #---- globals
@@ -1524,7 +1475,12 @@
             self.__log.info("[%s] ProcessProxy: closing stdin (%r)."\
                             % (id(self), self.stdin))
             try:
-                self.stdin.close()
+                if self.stdin == sys.__stdin__:
+                    self.__log.info("[%s] ProcessProxy: NOT closing stdin "
+                                    "because it is sys.__stdin__."
+                                    % id(self))
+                else:
+                    self.stdin.close()
                 self._stdinProxy.join()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
@@ -1533,7 +1489,12 @@
             self.__log.info("[%s] ProcessProxy: closing stdout (%r)."\
                             % (id(self), self.stdout))
             try:
-                self.stdout.close()
+                if self.stdout == sys.__stdout__:
+                    self.__log.info("[%s] ProcessProxy: NOT closing stdout "
+                                    "because it is sys.__stdout__."
+                                    % id(self))
+                else:
+                    self.stdout.close()
                 if self._stdoutProxy is not threading.currentThread():
                     self._stdoutProxy.join()
             except AttributeError:
@@ -1543,7 +1504,12 @@
             self.__log.info("[%s] ProcessProxy: closing stderr (%r)."\
                             % (id(self), self.stderr))
             try:
-                self.stderr.close()
+                if self.stderr == sys.__stderr__:
+                    self.__log.info("[%s] ProcessProxy: NOT closing stderr "
+                                    "because it is sys.__stderr__."
+                                    % id(self))
+                else:
+                    self.stderr.close()
                 if self._stderrProxy is not threading.currentThread():
                     self._stderrProxy.join()
             except AttributeError:
Change 64450 by markh@markh-eden on 2003/04/20 16:53:10

	win32event timeout is an int (Py2.3 warns about this)

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#64 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#64 (text) ====

@@ -1331,7 +1331,7 @@
             if timeout is None:
                 timeout = win32event.INFINITE
             else:
-                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+                timeout = timeout * 1000 # Win32 API's timeout is int(millisecs)
 
             rc = win32event.WaitForSingleObject(self._hProcess, timeout)
             if rc == win32event.WAIT_FAILED:
Change 63569 by trentm@trentm-planer on 2003/04/11 17:16:35

	Upgrade Komodo to which 1.0.0. I was getting sick of the stupid
	generator interface to which.which. This function is now more sane.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#63 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/sysdata/pdk.py#8 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#5 edit
... //depot/main/Apps/Komodo-devel/src/run/koRunService.py#47 edit
... //depot/main/Apps/Komodo-devel/src/scc/cvs/koCVS.py#16 edit
... //depot/main/Apps/Komodo-devel/src/scc/p4/koP4.py#12 edit
... //depot/main/Apps/Komodo-devel/test/measure_lint_leak.py#5 edit
... //depot/main/Apps/Komodo-devel/test/measure_typing_speed.py#2 edit
... //depot/main/Apps/Komodo-devel/test/perfsupport.py#3 edit
... //depot/main/Apps/Komodo-devel/test/which.py#2 edit
... //depot/main/Apps/Komodo-devel/util/asi.py#3 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#63 (text) ====

@@ -294,22 +294,26 @@
         else:
             first, rest = cmd, ""
 
+    # The first arg may already be a full path to exe.
+    #XXX Shouldn't bother which'ing again in this case.
+
     # Ensure the first arg is a valid path to the appropriate file.
     import which
+    assert which._version_ >= (1,0,0)
     if os.sep in first:
         altpath = [os.path.dirname(first)]
         firstbase = os.path.basename(first)
-        candidates = list(which.which(firstbase, path=altpath))
+        candidate = which.which(firstbase, path=altpath)
     elif env:
         altpath = _getPathFromEnv(env)
         if altpath:
-            candidates = list(which.which(first, altpath.split(os.pathsep)))
+            candidate = which.which(first, altpath.split(os.pathsep))
         else:
-            candidates = list(which.which(first))
+            candidate = which.which(first)
     else:
-        candidates = list(which.which(first))
-    if candidates:
-        return _joinArgv( [candidates[0]] ) + ' ' + rest
+        candidate = which.which(first)
+    if candidate:
+        return _joinArgv( [candidate] ) + ' ' + rest
     else:
         raise ProcessError("Could not find an appropriate leading command "\
                            "for: %r" % cmd)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/sysdata/pdk.py#8 (text) ====

@@ -28,6 +28,7 @@
 import re
 
 import which
+assert which._version_ >= (1,0,0)
 import process
 
 from sysdata.common import SysDataError, log
@@ -81,37 +82,32 @@
 
 def perlapp(name):
     try:
-        # I hate this generator interface. -- TM
-        return which.which("perlapp").next()
-    except StopIteration:
+        return which.which("perlapp")
+    except which.WhichError:
         return None
 
 def perlctrl(name):
     try:
-        # I hate this generator interface. -- TM
-        return which.which("perlctrl").next()
-    except StopIteration:
+        return which.which("perlctrl")
+    except which.WhichError:
         return None
 
 def perlsvc(name):
     try:
-        # I hate this generator interface. -- TM
-        return which.which("perlsvc").next()
-    except StopIteration:
+        return which.which("perlsvc")
+    except which.WhichError:
         return None
 
 def perlnet(name):
     try:
-        # I hate this generator interface. -- TM
-        return which.which("plc").next()
-    except StopIteration:
+        return which.which("plc")
+    except which.WhichError:
         return None
 
 def perltray(name):
     try:
-        # I hate this generator interface. -- TM
-        return which.which("perltray").next()
-    except StopIteration:
+        return which.which("perltray")
+    except which.WhichError:
         return None
 
 def installed(name):

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#5 (text) ====

@@ -1,28 +1,36 @@
 #!/usr/bin/env python
+# Copyright (c) 2003 ActiveState Tool Corporation.
+# See the file LICENSE.txt for licensing information.
+
+r"""Find the full path of commands.
+
+which(command, path=None, verbose=0)
+    Return the full path to the first match of the given command on the
+    path.
 
-# Copyright (c) 2002 Trent Mick
-# 
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included
-# in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+whichall(command, path=None, verbose=0)
+    Return a list of full paths to all matches of the given command on
+    the path.
+
+whichgen(command, path=None, verbose=0)
+    Return a generator which will yield full paths to all matches of the
+    given command on the path.
+    
+By default the PATH environment variable is searched (as well as, on
+Windows, the AppPaths key in the registry), but a specific 'path' list
+to search may be specified as well.  On Windows, the PATHEXT environment
+variable is applied as appropriate.
 
+If "verbose" is true then a tuple of the form
+    (<fullpath>, <matched-where-description>)
+is returned for each match. The latter element is a textual description
+of where the match was found. For example:
+    from PATH element 0
+    from HKLM\SOFTWARE\...\perl.exe
 """
-    Show full path of commands.
+
+_cmdlnUsage = """
+    Show the full path of commands.
 
     Usage:
         which [<options>...] [<command-name>...]
@@ -32,8 +40,10 @@
         -V, --version   Print the version info and exit.
 
         -a, --all       Print *all* matching paths.
-        -v, --verbose   Print out near misses on stderr. [default]
-        -q, --quiet     Do not print out near misses.
+        -v, --verbose   Print out how matches were located and
+                        show near misses on stderr.
+        -q, --quiet     Just print out matches. I.e., do not print out
+                        near misses.
 
         -p <altpath>, --path=<altpath>
                         An alternative path (list of directories) may
@@ -65,8 +75,7 @@
 
 #---- global data
 
-_version_ = (0, 7, 0)
-gVerbose = 0
+_version_ = (1, 0, 0)
 
 
 #---- internal support stuff
@@ -79,14 +88,15 @@
             exeName += '.exe'
         import _winreg
         try:
-            registered = _winreg.QueryValue(_winreg.HKEY_LOCAL_MACHINE,
-                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\"\
-                + exeName)
+            key = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\" +\
+                  exeName
+            value = _winreg.QueryValue(_winreg.HKEY_LOCAL_MACHINE, key)
+            registered = (value, "from HKLM\\"+key)
         except _winreg.error:
             pass
-        if registered and not os.path.exists(registered):
+        if registered and not os.path.exists(registered[0]):
             registered = None
-    return None
+    return registered
 
 def _samefile(fname1, fname2):
     if sys.platform.startswith('win'):
@@ -95,7 +105,7 @@
     else:
         return os.path.samefile(fname1, fname2)
 
-def _cull(potential, matches):
+def _cull(potential, matches, verbose=0):
     """Cull inappropriate matches. Possible reasons:
         - a duplicate of a previous match
         - not a disk file
@@ -103,19 +113,19 @@
     If 'potential' is approved it is returned and added to 'matches'.
     Otherwise, None is returned.
     """
-    global gVerbose
     for match in matches:  # don't yield duplicates
-        if _samefile(potential, match):
-            if gVerbose:
-                sys.stderr.write("duplicate: %s\n" % potential)
+        if _samefile(potential[0], match[0]):
+            if verbose:
+                sys.stderr.write("duplicate: %s (%s)\n" % potential)
             return None
     else:
-        if not stat.S_ISREG(os.stat(potential).st_mode):
-            if gVerbose:
-                sys.stderr.write("not a regular file: %s\n" % potential)
-        elif not os.access(potential, os.X_OK):
-            if gVerbose:
-                sys.stderr.write("no executable access: %s\n" % potential)
+        if not stat.S_ISREG(os.stat(potential[0]).st_mode):
+            if verbose:
+                sys.stderr.write("not a regular file: %s (%s)\n" % potential)
+        elif not os.access(potential[0], os.X_OK):
+            if verbose:
+                sys.stderr.write("no executable access: %s (%s)\n"\
+                                 % potential)
         else:
             matches.append(potential)
             return potential
@@ -123,17 +133,29 @@
         
 #---- module API
 
-def which(command, path=None):
-    """Generate a list of found apps for the given 'command' on the path.
+def whichgen(command, path=None, verbose=0):
+    """Return a generator of full paths to the given command.
     
-    "path" (optional) an alternate search path, instead of using the PATH
-        environment variable. This is a list, e.g. ["C:\\TEMP",...].
+    "command" is a the name of the executable to search for.
+    "path" is an optional alternate path list to search. The default it
+        to use the PATH environment variable.
+    "verbose", if true, will cause a 2-tuple to be returned for each
+        match. The second element is a textual description of were the
+        match was found.
+
+    This method returns a generator which yields either full paths to
+    the given command or, if verbose, tuples of the form (<path to
+    command>, <where path found>).
     """
     matches = []
     if path is None:
+        usingGivenPath = 0
         path = os.environ.get("PATH", "").split(os.pathsep)
         if sys.platform.startswith("win"):
             path.insert(0, os.curdir)  # implied by Windows shell
+    else:
+        usingGivenPath = 1
+
     # Windows has the concept of a list of extensions (PATHEXT env var).
     exts = []
     if sys.platform.startswith("win"):
@@ -145,12 +167,14 @@
                 break
         else:
             exts = ['.COM', '.EXE', '.BAT']
+
     # File name cannot have path separators because PATH lookup does not
     # work that way.
     if os.sep in command or os.altsep and os.altsep in command:
         pass
     else:
-        for dirName in path:
+        for i in range(len(path)):
+            dirName = path[i]
             # On windows the dirName *could* be quoted, drop the quotes
             if sys.platform.startswith("win") and len(dirName) >= 2\
                and dirName[0] == '"' and dirName[-1] == '"':
@@ -159,43 +183,92 @@
                 absName = os.path.abspath(
                     os.path.normpath(os.path.join(dirName, command+ext)))
                 if os.path.isfile(absName):
-                    match = _cull(absName, matches)
+                    if usingGivenPath:
+                        fromWhere = "from given path element %d" % i
+                    elif not sys.platform.startswith("win"):
+                        fromWhere = "from PATH element %d" % i
+                    elif i == 0:
+                        fromWhere = "from current directory"
+                    else:
+                        fromWhere = "from PATH element %d" % (i-1)
+                    match = _cull((absName, fromWhere), matches, verbose)
                     if match:
-                        yield match
-        absName = _getRegisteredExecutable(command)
-        if absName is not None:
-            match = _cull(absName, matches)
+                        if verbose:
+                            yield match
+                        else:
+                            yield match[0]
+        match = _getRegisteredExecutable(command)
+        if match is not None:
+            match = _cull(match, matches, verbose)
             if match:
-                yield match
+                if verbose:
+                    yield match
+                else:
+                    yield match[0]
+
+
+def which(command, path=None, verbose=0):
+    """Return the full path to the first match of the given command on
+    the path.
+    
+    "command" is a the name of the executable to search for.
+    "path" is an optional alternate path list to search. The default it
+        to use the PATH environment variable.
+    "verbose", if true, will cause a 2-tuple to be returned with the
+        second element being a textual description of were the match was
+        found.
+
+    If no match is found for the command, a WhichError is raised.
+    """
+    try:
+        match = whichgen(command, path, verbose).next()
+    except StopIteration:
+        raise WhichError("Could not find '%s' on the path." % command)
+    return match
+
+
+def whichall(command, path=None, verbose=0):
+    """Return a list of full paths to all matches of the given command
+    on the path.  
+
+    "command" is a the name of the executable to search for.
+    "path" is an optional alternate path list to search. The default it
+        to use the PATH environment variable.
+    "verbose", if true, will cause a 2-tuple to be returned with the
+        second element being a textual description of were the match was
+        found.
+    """
+    return list( whichgen(command, path, verbose) )
+
 
 
 #---- mainline
 
-def main(argv):
-    global gVerbose, _version_
+def _main(argv):
     all = 0
-    gVerbose = 1 # be verbose through the cmdln interface, by default.
+    verbose = 0
     try:
         optlist, args = getopt.getopt(argv[1:], 'haVvqp:',
-            ['help', 'all', 'version', 'verbose', 'quiet', 'path'])
+            ['help', 'all', 'version', 'verbose', 'quiet', 'path='])
     except getopt.GetoptError, msg:
-        print "which: error: %s. Your invocation was: %s\n" % (msg, argv)
-        print __doc__
+        sys.stderr.write("which: error: %s. Your invocation was: %s\n"\
+                         % (msg, argv))
+        sys.stderr.write("Try 'which --help'.\n")
         return 1
     altpath = None
     for opt, optarg in optlist:
         if opt in ('-h', '--help'):
-            print __doc__
+            print _cmdlnUsage
             return 0
         elif opt in ('-V', '--version'):
-            print "Which %s" % '.'.join([str(i) for i in _version_])
+            print "which %s" % '.'.join([str(i) for i in _version_])
             return 0
         elif opt in ('-a', '--all'):
             all = 1
         elif opt in ('-v', '--verbose'):
-            gVerbose = 1
+            verbose = 1
         elif opt in ('-q', '--quiet'):
-            gVerbose = 0
+            verbose = 0
         elif opt in ('-p', '--path'):
             altpath = optarg.split(os.pathsep)
 
@@ -205,18 +278,21 @@
     failures = 0
     for arg in args:
         #print "debug: search for %r" % arg
-        npaths = 0
-        for path in which(arg, altpath):
-            print path
-            npaths += 1
+        nmatches = 0
+        for match in whichgen(arg, altpath, verbose):
+            if verbose:
+                print "%s (%s)" % match
+            else:
+                print match
+            nmatches += 1
             if not all:
                 break
-        if not npaths:
+        if not nmatches:
             failures += 1
     return failures
 
 
 if __name__ == "__main__":
-    sys.exit( main(sys.argv) )
+    sys.exit( _main(sys.argv) )
 
 

==== //depot/main/Apps/Komodo-devel/src/run/koRunService.py#47 (text) ====

@@ -346,15 +346,19 @@
             guid = guid[1:-1] # strip of the {}'s
         else:
             import which
-            uuidgens = list( which.which("uuidgen") )
-            if uuidgens:
+            assert which._version_ >= (1,0,0)
+            try:
+                uuidgen = which.which("uuidgen")
+            except which.WhichError, ex:
+                pass
+            else:
                 import process
                 try:
-                    p = process.ProcessOpen(uuidgens[0])
+                    p = process.ProcessOpen(uuidgen)
                     guid = p.stdout.read().strip()
                     p.close()
                 except process.ProcessError, ex:
-                    log.warn("Error running '%s': %s", uuidgens[0], str(ex))
+                    log.warn("Error running '%s': %s", uuidgen, str(ex))
         return guid
 
     def _getCodeMap(self, fileName=None, lineNum=None, word=None,

==== //depot/main/Apps/Komodo-devel/src/scc/cvs/koCVS.py#16 (text) ====

@@ -62,17 +62,21 @@
         return self._executable
     
     def redetermineIfFunctional(self):
-        # XXX if we get multiple cvs executables, we should determine
+        # XXX if there are multiple cvs executables, we should determine
         # which ones are usable, which is the latest version, etc.,
         # and stuff that information someplace
         import which
+        assert which._version_ >= (1,0,0)
         cvsInfoEx = components.classes["@activestate.com/koCVSInfoEx;1"].\
                     createInstance(components.interfaces.koIAppInfoEx)
         if not self._executable:
-            cvss = list(which.which('cvs'))
-            if cvss:
+            try:
+                cvs = which.which('cvs')
+            except which.WhichError:
+                pass
+            else:
                 # this call sets cvsInfoEx.executablePath
-                cvsInfoEx.getInstallationPathFromBinary(cvss[0])
+                cvsInfoEx.getInstallationPathFromBinary(cvs)
         else:
             cvsInfoEx.executablePath = self._executable;
 

==== //depot/main/Apps/Komodo-devel/src/scc/p4/koP4.py#12 (text) ====

@@ -137,15 +137,19 @@
         
     def redetermineIfFunctional(self):
         import which
+        assert which._version_ >= (1,0,0)
             
         if not self._executable:
-            p4s = list(which.which('p4'))
+            try:
+                p4 = which.which('p4')
+            except which.WhichError:
+                p4 = None
         elif os.path.exists(self._executable):
-            p4s = [self._executable]
+            p4 = self._executable
         else:
-            p4s = []
+            p4 = None
         
-        if not p4s:
+        if p4 is None:
             self.isFunctional = 0
             self.reasonNotFunctional = "no 'p4' executable could be found"
         else:

==== //depot/main/Apps/Komodo-devel/test/measure_lint_leak.py#5 (text) ====

@@ -16,8 +16,11 @@
     import win32com.client
     import win32pdh, win32pdhutil
 
+import which
+assert which._version_ >= (1,0,0)
 
 
+
 #---- support routines
 
 def usage(code, msg=''):
@@ -46,60 +49,6 @@
     return None
 
 
-def which(exeName, return_first=1):
-    """Find an 'executable' on the 'Path'."""
-    matches = []
-    path = os.environ["PATH"].split(os.pathsep)
-    # windows has the concept of a list of extensions (PATHEXT env var)
-    exts = []
-    if sys.platform.startswith("win"):
-        if os.environ.has_key("PATHEXT"):
-            exts = os.environ["PATHEXT"].split(os.pathsep)
-        # If '.exe' is not in exts then obviously this is Win9x and or a
-        # bogus PATHEXT (this is possible, and likely, on Win9x where
-        # ActivePython adds .py;.pyc;.pyo to an non-existant PATHEXT)
-        # then use a reasonable default.
-        for ext in exts:
-            if ext.lower() == ".exe":
-                break
-        else:
-            exts = ['.COM', '.EXE', '.BAT']
-    # file name cannot have path separators because PATH lookup does not
-    # work that way
-    if os.sep in exeName or os.altsep and os.altsep in exeName:
-        pass
-    else:
-        for dirName in path:
-            # on windows the dirName *could* be quoted, drop the quotes
-            if sys.platform.startswith("win") and\
-               len(dirName) >= 2 and\
-               dirName[0] == '"' and dirName[-1] == '"':
-                dirName = dirName[1:-1]
-            for ext in ['']+exts:
-                absExeName = os.path.join(dirName, exeName+ext)
-                if os.path.isfile(absExeName):
-                    if return_first:
-                        return absExeName
-                    matches.append(os.path.normpath(absExeName))
-        # last look up the Path in the "App Paths" registry or whatever
-        ret = _GetRegisteredExecutable(exeName)
-        if ret is not None:
-            if return_first:
-                return ret
-            matches.append(ret)
-    if return_first: # If I want the first and got here, I must have none!
-        return ""
-    # check for duplicates
-    matchesWithoutDups = []
-    for i in range(len(matches)):
-        for j in range(i+1, len(matches)):
-            if self._SameFile(matches[i], matches[j]):
-                break
-        else:
-            matchesWithoutDups.append(matches[i])
-    return matchesWithoutDups
-
-
 def _GetMozillaPIDs():
     if sys.platform.startswith("win"):
         win32pdh.EnumObjects(None, None, 0, 1)  # refresh internal cache
@@ -259,7 +208,7 @@
 
     # defaults
     verbose = 1
-    komodoExe = which("komodo")
+    komodoExe = which.which("komodo")
     out = sys.stdout
 
     try:

==== //depot/main/Apps/Komodo-devel/test/measure_typing_speed.py#2 (text) ====

@@ -16,8 +16,11 @@
     import win32com.client
     import win32pdh, win32pdhutil
 
+import which
+assert which._version_ >= (1,0,0)
 
 
+
 #---- support routines
 
 def usage(code, msg=''):
@@ -46,60 +49,6 @@
     return None
 
 
-def which(exeName, return_first=1):
-    """Find an 'executable' on the 'Path'."""
-    matches = []
-    path = os.environ["PATH"].split(os.pathsep)
-    # windows has the concept of a list of extensions (PATHEXT env var)
-    exts = []
-    if sys.platform.startswith("win"):
-        if os.environ.has_key("PATHEXT"):
-            exts = os.environ["PATHEXT"].split(os.pathsep)
-        # If '.exe' is not in exts then obviously this is Win9x and or a
-        # bogus PATHEXT (this is possible, and likely, on Win9x where
-        # ActivePython adds .py;.pyc;.pyo to an non-existant PATHEXT)
-        # then use a reasonable default.
-        for ext in exts:
-            if ext.lower() == ".exe":
-                break
-        else:
-            exts = ['.COM', '.EXE', '.BAT']
-    # file name cannot have path separators because PATH lookup does not
-    # work that way
-    if os.sep in exeName or os.altsep and os.altsep in exeName:
-        pass
-    else:
-        for dirName in path:
-            # on windows the dirName *could* be quoted, drop the quotes
-            if sys.platform.startswith("win") and\
-               len(dirName) >= 2 and\
-               dirName[0] == '"' and dirName[-1] == '"':
-                dirName = dirName[1:-1]
-            for ext in ['']+exts:
-                absExeName = os.path.join(dirName, exeName+ext)
-                if os.path.isfile(absExeName):
-                    if return_first:
-                        return absExeName
-                    matches.append(os.path.normpath(absExeName))
-        # last look up the Path in the "App Paths" registry or whatever
-        ret = _GetRegisteredExecutable(exeName)
-        if ret is not None:
-            if return_first:
-                return ret
-            matches.append(ret)
-    if return_first: # If I want the first and got here, I must have none!
-        return ""
-    # check for duplicates
-    matchesWithoutDups = []
-    for i in range(len(matches)):
-        for j in range(i+1, len(matches)):
-            if self._SameFile(matches[i], matches[j]):
-                break
-        else:
-            matchesWithoutDups.append(matches[i])
-    return matchesWithoutDups
-
-
 def _GetMozillaPIDs(exename):
     if sys.platform.startswith("win"):
         win32pdh.EnumObjects(None, None, 0, 1)  # refresh internal cache
@@ -318,7 +267,7 @@
 
     # defaults
     verbose = 1
-    komodoExe = which("komodo")
+    komodoExe = which.which("komodo")
     out = sys.stdout
 
     try:

==== //depot/main/Apps/Komodo-devel/test/perfsupport.py#3 (text) ====

@@ -1,12 +1,13 @@
 import os, sys, time
-from which import which
+import which
+assert which._version_ >= (1,0,0)
 from memutils import getpidsforprocess
 
 def startKomodo(args=[]):
     # start up Komodo with the testFile
     # - spawn komodo and wait to startup
     verbose = 1
-    komodoExe = list(which("komodo"))[0]
+    komodoExe = which.which("komodo")
     out = sys.stdout
     pidsBefore = getpidsforprocess('mozilla')
 

==== //depot/main/Apps/Komodo-devel/test/which.py#2 (text) ====

@@ -1,25 +1,6 @@
 #!/usr/bin/env python
-
-# Copyright (c) 2002 Trent Mick
-# 
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included
-# in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+# Copyright (c) 2003 ActiveState Tool Corporation.
+# See the file LICENSE.txt for licensing information.
 
 r"""Find the full path of commands.
 

==== //depot/main/Apps/Komodo-devel/util/asi.py#3 (text) ====

@@ -1700,20 +1700,14 @@
         iscmdbld = None
         try:
             import which
+            assert which._version_ >= (1,0,0)
         except ImportError:
             log.error("build: could not import which to find path to IsCmdBld.exe")
             log.error("build: you should get 'which' from starship.python.net/~tmick")
             return 1
-        else:
-            iscmdblds = list( which.which('IsCmdBld') )
-            if iscmdblds:
-                if isinstance(iscmdblds[0], tuple):
-                    # which := ('path\\to\\iscmdbld.exe', 'from PATH elem 3')
-                    iscmdbld = iscmdblds[0][0]
-                else:
-                    # which := 'path\\to\\iscmdbld.exe'
-                    iscmdbld = iscmdblds[0]
-        if not iscmdbld:
+        try:
+            iscmdbld = which.which('IsCmdBld')
+        except which.WhichError, ex:
             log.error("build: could not find path to IsCmdBld.exe")
             return 1
 
Change 58375 by trentm@trentm-planer on 2003/02/17 11:23:04

	Safe workaround for http://bugs.activestate.com/Komodo/show_bug.cgi?id=23215
	"Dictionary items must be strings, or all must be unicode" warning from PHP app info stuff
	
	We'll lokk at a more proper fix post-2.3.
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#62 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#62 (text) ====

@@ -366,8 +366,11 @@
                 # Try again with an all unicode environment.
                 #XXX Would be nice if didn't have to depend on the error
                 #    string to catch this.
-                import warnings
-                warnings.warn('env: ' + str(ex), stacklevel=4)
+                #XXX Removing this warning for 2.3 release. See bug
+                #    23215. The right fix is to correct the PHPAppInfo
+                #    stuff to heed the warning.
+                #import warnings
+                #warnings.warn('env: ' + str(ex), stacklevel=4)
                 if isWin9x and env:
                     aenv = {}
                     try:
Change 58037 by trentm@trentm-planer on 2003/02/12 14:37:47

	Fix http://bugs.activestate.com/Komodo/show_bug.cgi?id=23187
	"exception in thread <stdin> during run command tutorial"
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#61 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#61 (text) ====

@@ -2129,9 +2129,12 @@
                      self.getName(), id(self), text, self.fChild)
             try:
                 self.fChild.write(text)
-            except IOError, ex:
-                # Ignore errors for now.
-                # XXX There *may* be errors we don't want to avoid.
+            except (OSError, IOError), ex:
+                # Ignore errors for now. For example:
+                # - Get this on Win9x when writing multiple lines to "dir":
+                #   OSError: [Errno 32] Broken pipe
+                #XXX There *may* be errors we don't want to avoid.
+                #XXX Should maybe just ignore EnvironmentError (base class).
                 log.info("[%s] _InFileProxy: error writing to child (%r), "\
                          "closing: %s" % (self.getName(), self.fParent, ex))
                 break
Change 57885 by trentm@trentm-planer on 2003/02/11 15:57:58

	Apparently WinNT's cmd.exe suffers from the same problem that
	command.com does in that a process launch "through" it (think
	"%COMSPEC% /c myapp.exe") does not receive console ctrl events, which
	are used by process.py to terminate the underlying process on .kill().
	
	For that reason we fallback (as we have been doing for Win9x) to NOT
	spawning processes "through" the shell. Cons:
		- cannot directly run shell command, like "dir" and "echo"
		- cannot directly run batch files
	
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#60 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#60 (text) ====

@@ -438,24 +438,71 @@
 
 
 def _fixupCommand(cmd, env=None):
+    """Fixup the command string so it is launchable via CreateProcess.
+
+    One cannot just launch, say "python", via CreateProcess. A full path
+    to an executable is required. In general there are two choices:
+        1. Launch the command string via the shell. The shell will find
+           the fullpath to the appropriate executable. This shell will
+           also be able to execute special shell commands, like "dir",
+           which don't map to an actual executable.
+        2. Find the fullpath to the appropriate executable manually and
+           launch that exe.
+
+    Option (1) is preferred because you don't have to worry about not
+    exactly duplicating shell behaviour and you get the added bonus of
+    being able to launch "dir" and friends.
+
+    However, (1) is not always an option. Doing so when the shell is
+    command.com (as on all Win9x boxes) or when using WinNT's cmd.exe,
+    problems are created with .kill() because these shells seem to eat
+    up Ctrl-C's and Ctrl-Break's sent via
+    win32api.GenerateConsoleCtrlEvent().  Strangely this only happens
+    when spawn via this Python interface. For example, Ctrl-C get
+    through to hang.exe here:
+      C:\> ...\w9xpopen.exe "C:\WINDOWS\COMMAND.COM /c hang.exe"
+      ^C
+    but not here:
+      >>> p = ProcessOpen('hang.exe')
+      # This results in the same command to CreateProcess as
+      # above.
+      >>> p.kill()
+
+    Hence, for these platforms we fallback to option (2).  Cons:
+      - cannot spawn shell commands like 'dir' directly
+      - cannot spawn batch files
+    """
     if sys.platform.startswith("win"):
-        # Fixup the command string to spawn.
-        # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
+        # Fixup the command string to spawn.  (Lifted from
+        # posixmodule.c::_PyPopenCreateProcess() with some modifications)
         comspec = os.environ.get("COMSPEC", None)
+        win32Version = win32api.GetVersion()
         if comspec is None:
             raise ProcessError("Cannot locate a COMSPEC environment "\
                                "variable to use as the shell")
         # Explicitly check if we are using COMMAND.COM.  If we
         # are then use the w9xpopen hack.
-        elif win32api.GetVersion() < 0x80000000L and\
+        elif (win32Version & 0x80000000L == 0) and\
+             (win32Version &        0x5L >= 5) and\
              os.path.basename(comspec).lower() != "command.com":
-            # NT/2000 and not using command.com.
+            # 2000/XP and not using command.com.
             if '"' in cmd or "'" in cmd:
                 cmd = comspec + ' /c "%s"' % cmd
             else:
                 cmd = comspec + ' /c ' + cmd
+        elif (win32Version & 0x80000000L == 0) and\
+             (win32Version &        0x5L  < 5) and\
+             os.path.basename(comspec).lower() != "command.com":
+            # NT and not using command.com.
+            try:
+                cmd = _whichFirstArg(cmd, env)
+            except ProcessError:
+                raise ProcessError("Could not find a suitable executable "\
+                    "to launch for '%s'. On WinNT you must manually prefix "\
+                    "shell commands and batch files with 'cmd.exe /c' to "\
+                    "have the shell run them." % cmd)
         else:
-            # Oh gag, we're on Win9x or using COMMAND.COM. Use the
+            # Oh gag, we're on Win9x and/or using COMMAND.COM. Use the
             # workaround listed in KB: Q150956
             w9xpopen = os.path.join(
                 os.path.dirname(win32api.GetModuleFileName(0)),
@@ -470,38 +517,17 @@
                         "Can not locate 'w9xpopen.exe' which is needed "\
                         "for ProcessOpen to work with your shell or "\
                         "platform.")
-            # XXX As for other platforms it would be preferable to launch
-            # the given user command via the std shell. However, on
-            # Win9x spawning via command.com causes problems for .kill()
-            # because command.com seems to eat up Ctrl-C's and
-            # Ctrl-Break's sent via win32api.GenerateConsoleCtrlEvent().
-            # Strangely this only happens when spawn via this Python
-            # interface. For example, Ctrl-C get through to
-            # hang.exe here:
-            #   C:\> ...\w9xpopen.exe "C:\WINDOWS\COMMAND.COM /c hang.exe"
-            #   ^C
-            # but not here:
-            #   >>> p = ProcessOpen('hang.exe')
-            #   # This results in the same command to CreateProcess as
-            #   # above.
-            #   >>> p.kill()
-            # 
-            # The work around is to skip launching via the shell and
-            # error out if this is not expected to work. Cons:
-            #   - cannot spawn shell commands like 'dir' directly
-            #   - cannot spawn batch files
-            if 0:
-                cmd = '%s "%s /c %s"'\
-                      % (w9xpopen, comspec, cmd.replace('"', '\\"'))
-            else:
-                try:
-                    cmd = _whichFirstArg(cmd, env)
-                except ProcessError:
-                    raise ProcessError("Could not find a suitable executable "\
-                        "to launch for '%s'. On Win9x you must manually "\
-                        "prefix shell commands with 'command.com /c' to "\
-                        "have the shell run them." % cmd)
-                cmd = '%s "%s"' % (w9xpopen, cmd.replace('"', '\\"'))
+            ## This would be option (1):
+            #cmd = '%s "%s /c %s"'\
+            #      % (w9xpopen, comspec, cmd.replace('"', '\\"'))
+            try:
+                cmd = _whichFirstArg(cmd, env)
+            except ProcessError:
+                raise ProcessError("Could not find a suitable executable "\
+                    "to launch for '%s'. On Win9x you must manually prefix "\
+                    "shell commands and batch files with 'command.com /c' "\
+                    "to have the shell run them." % cmd)
+            cmd = '%s "%s"' % (w9xpopen, cmd.replace('"', '\\"'))
     return cmd
 
 class _FileWrapper:
Change 57671 by trentm@trentm-piper on 2003/02/10 12:51:21

	Typo in internal documentation. No functional change.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#59 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#59 (text) ====

@@ -92,7 +92,7 @@
       p.wait(os.WNOHANG)):
         >>> p = ProcessOpen(['perl', '-e', 'while (1) {}'])
         >>> try:
-        ...     p.wait(0)  # poll to see if is process still running
+        ...     p.wait(os.WNOHANG)  # poll to see if is process still running
         ... except ProcessError, ex:
         ...     if ex.errno == ProcessProxy.WAIT_TIMEOUT:
         ...             print "process is still running"
Change 57497 by trentm@trentm-piper on 2003/02/07 14:36:08

	Fix http://bugs.activestate.com/Komodo/show_bug.cgi?id=21144
	"run" output in output pane is inconsistent
	
	The ProcessProxy has to decide when to shut its various threads down.
	Optionas are (1) rely on the caller to do this (that sucks), (2) wait for
	the child process to terminate (there are problems with that, discussed in
	internal comments), and (3) wait for the child to close stdout and/or
	stderr. Before this we had been shutting down when the child's stdout
	closed. This was insufficient because Gary's test case showed an example
	where the child could close its stdout _then_ kick out the remains of
	stderr output, which the ProcessProxy would miss. Solution: wait for the
	child to close stdout *and stderr*. All tests pass on Windows and Linux.
	
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#58 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#58 (text) ====

@@ -38,7 +38,7 @@
         comminucation:
 
                             <parent process>
-               ,---->->->------'   ^   `------<-<-<----,
+               ,---->->->------'   ^   `------>->->----,
                |                   |                   v
            IOBuffer             IOBuffer            IOBuffer        
            (p.stdout)           (p.stderr)          (p.stdin)
@@ -46,7 +46,7 @@
            _OutFileProxy        _OutFileProxy       _InFileProxy
            thread               thread              thread
                |                   ^                   |
-               `----<-<-<------,   |   ,------>->->----'
+               `----<-<-<------,   |   ,------<-<-<----'
                             <child process>
 
     Usage:
@@ -84,7 +84,7 @@
         >>> p.stdout.read()
         ''
         >>> p = process.ProcessOpen(['perl', '-e', 'print $ENV{FOO}'],
-        ...                         env={'FOO':'bar'}).start()
+        ...                         env={'FOO':'bar'})
         >>> p.stdout.read()
         'bar'
 
@@ -106,14 +106,14 @@
         XXX write this, mention IOBuffer subclassing.
 """
 #TODO:
-#   - Discuss the decision to NOT have the stdout _OutFileProxy wait for
-#     process termination before closing stdin. It will just close stdin
-#     when stdout is seen to have been closed. That is considered Good
-#     Enough (tm). Theoretically it would be nice to only abort the
-#     stdin proxying when the process terminates, but watching for
-#     process termination in any of the parent's thread adds the
-#     undesired condition that the parent cannot exit with the child
-#     still running. That sucks.
+#   - Discuss the decision to NOT have the stdout/stderr _OutFileProxy's
+#     wait for process termination before closing stdin. It will just
+#     close stdin when stdout is seen to have been closed. That is
+#     considered Good Enough (tm). Theoretically it would be nice to
+#     only abort the stdin proxying when the process terminates, but
+#     watching for process termination in any of the parent's thread
+#     adds the undesired condition that the parent cannot exit with the
+#     child still running. That sucks.
 #     XXX Note that I don't even know if the current stdout proxy even
 #         closes the stdin proxy at all.
 #   - DavidA: if I specify "unbuffered" for my stdin handler (in the
@@ -722,7 +722,31 @@
                % (self._file, self._descriptor, self._handle)
 
 
+class _CountingCloser:
+    """Call .close() on the given object after own .close() is called
+    the precribed number of times.
+    """
+    def __init__(self, objectsToClose, count):
+        """
+        "objectsToClose" is a list of object on which to call .close().
+        "count" is the number of times this object's .close() method
+            must be called before .close() is called on the given objects.
+        """
+        self.objectsToClose = objectsToClose
+        self.count = count
+        if self.count <= 0:
+            raise ProcessError("illegal 'count' value: %s" % self.count)
+
+    def close(self):
+        self.count -= 1
+        log.debug("[%d] _CountingCloser.close(): count=%d", id(self),
+                  self.count)
+        if self.count == 0:
+            for objectToClose in self.objectsToClose:
+                objectToClose.close()
 
+
+
 #---- public interface
 
 class Process:
@@ -1387,7 +1411,6 @@
     #   - stdout/stderr proxy handling
     #   - stdin proxy handling
     #   - termination
-    #   - special methods (e.g. .kill())
     #   - how to .start(), i.e. basic usage rules
     #   - mention that pased in stdin/stdout/stderr objects have to
     #     implement at least .write (is .write correct for stdin)?
@@ -1412,7 +1435,7 @@
         "env" is optionally a mapping specifying the environment in which to
             start the child. Default is None, a.k.a. inherits the environment
             of the parent.
-        "stdin", "stdout", "stderr" can be used to specify an objects with
+        "stdin", "stdout", "stderr" can be used to specify objects with
             file-like interfaces to handle read (stdout/stderr) and write
             (stdin) events from the child. By default a process.IOBuffer
             instance is assigned to each handler. IOBuffer may be
@@ -1488,7 +1511,8 @@
                             % (id(self), self.stderr))
             try:
                 self.stderr.close()
-                self._stderrProxy.join()
+                if self._stderrProxy is not threading.currentThread():
+                    self._stderrProxy.join()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stderr, etc.
@@ -1546,14 +1570,17 @@
         self._stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
         self._stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
-        # the child has closed its side of <stdout>. (This is one way of
-        # determining when it is appropriate to clean up this pipe, with
-        # compromises. See the discussion at the top of this module.)
+        # the child has closed its side of <stdout> and <stderr>. (This
+        # is one way of determining when it is appropriate to clean up
+        # this pipe, with compromises. See the discussion at the top of
+        # this module.)
+        closer = _CountingCloser([self.stdin, childStdin, self], 2)
         self._stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
-                                          [self.stdin, childStdin, self],
+                                          [closer],
                                           name='<stdout>')
         self._stdoutProxy.start()
         self._stderrProxy = _OutFileProxy(childStderr, self.stderr,
+                                          [closer],
                                           name='<stderr>')
         self._stderrProxy.start()
 
Change 54500 by davida@davida-jigsaw on 2003/01/06 17:04:19

	Adding ; to the list of escape-worthy chars.
	r=trentm

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#57 edit
... //depot/main/Apps/Komodo-devel/src/scc/cvs/cvslib.py#15 edit
... //depot/main/Apps/Komodo-devel/src/scc/p4/p4lib.py#13 edit
... //depot/main/Apps/Komodo-devel/src/webservices/koWSProxyGenerator.py#6 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#57 (text) ====

@@ -243,7 +243,7 @@
     """
     cmdstr = ""
     for arg in argv:
-        if ' ' in arg:
+        if ' ' in arg or ';' in arg:
             cmdstr += '"%s"' % _escapeArg(arg)
         else:
             cmdstr += _escapeArg(arg)

==== //depot/main/Apps/Komodo-devel/src/scc/cvs/cvslib.py#15 (text) ====

@@ -94,7 +94,7 @@
     #XXX I suspect that there is a more that we should escape here.
     if not arg: return arg
     arg.replace('"', r'\"')
-    if ' ' in arg and not (arg.startswith('"') and arg.endswith('"')):
+    if (' ' in arg or ';' in arg) and not (arg.startswith('"') and arg.endswith('"')):
         arg = '"' + arg + '"'
     return arg
 

==== //depot/main/Apps/Komodo-devel/src/scc/p4/p4lib.py#13 (text) ====

@@ -1,26 +1,5 @@
 #!/usr/bin/env python
 
-# Copyright (c) 2002 Trent Mick
-# 
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included
-# in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
 """
     An OO interface to 'p4' (the Perforce client command line app).
 
@@ -148,7 +127,7 @@
     for arg in argv:
         # Quote args with '*' because don't want shell to expand the
         # argument. (XXX Perhaps that should only be done for Windows.)
-        if ' ' in arg or '*' in arg:
+        if ' ' in arg or '*' in arg or ';' in arg:
             cmdstr += '"%s"' % _escapeArg(arg)
         else:
             cmdstr += _escapeArg(arg)

==== //depot/main/Apps/Komodo-devel/src/webservices/koWSProxyGenerator.py#6 (text) ====

@@ -10,7 +10,7 @@
     #XXX I suspect that there is a more that we should escape here.
     if not arg: return arg
     arg.replace('"', r'\"')
-    if ' ' in arg and not (arg.startswith('"') and arg.endswith('"')):
+    if (' ' in arg or ';' in arg) and not (arg.startswith('"') and arg.endswith('"')):
         arg = '"' + arg + '"'
     return arg
 
Change 53917 by davida@davida-jigsaw on 2002/12/19 13:05:08

	Delayed imports of win32gui
	Removing import win32con from platform.py
	r=shanec

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/platform.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#56 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/platform.py#2 (text) ====

@@ -439,8 +439,10 @@
     except ImportError:
         return release,version,csd,ptype
     from win32api import RegQueryValueEx,RegOpenKeyEx,RegCloseKey,GetVersionEx
-    from win32con import HKEY_LOCAL_MACHINE,VER_PLATFORM_WIN32_NT,\
-                         VER_PLATFORM_WIN32_WINDOWS
+    # Constants extracted from win32con to save memory
+    HKEY_LOCAL_MACHINE = 0x80000002
+    VER_PLATFORM_WIN32_NT = 2 
+    VER_PLATFORM_WIN32_WINDOWS = 1
 
     # Find out the registry key and some general version infos
     maj,min,buildno,plat,csd = GetVersionEx()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#56 (text) ====

@@ -135,7 +135,6 @@
     import pywintypes
     import win32process
     import win32event
-    import win32gui
     # constants pulled from win32con to save memory
     VER_PLATFORM_WIN32_WINDOWS = 1
     CTRL_BREAK_EVENT = 1
@@ -957,6 +956,7 @@
             after gracePeriod (1 sec. default), terminate.
         """
         if sys.platform.startswith("win"):
+            import win32gui
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
@@ -1005,6 +1005,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
+            import win32gui
             win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
@@ -1324,6 +1325,7 @@
             after gracePeriod (1 sec. default), terminate.
         """
         if sys.platform.startswith("win"):
+            import win32gui
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
@@ -1374,6 +1376,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
+            import win32gui
             win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
@@ -1754,6 +1757,7 @@
             after gracePeriod (1 sec. default), terminate.
         """
         if sys.platform.startswith("win"):
+            import win32gui
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
@@ -1804,6 +1808,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
+            import win32gui
             win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
Change 52968 by davida@davida-jigsaw on 2002/12/04 16:07:45

	Get rid of all calls to win32con -- importing it takes 1/2 meg!
	r=trentm

Affected files ...

... //depot/main/Apps/Komodo-devel/src/ask-pass/ask-pass.py#2 edit
... //depot/main/Apps/Komodo-devel/src/commandments/prototype/komodo.py#6 edit
... //depot/main/Apps/Komodo-devel/src/misc-components/koInitService.py#43 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/memutils.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#55 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/progressbar.py#7 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/ask-pass/ask-pass.py#2 (text) ====

@@ -25,48 +25,74 @@
 
 import win32ui
 import win32api
-import win32con
 from pywin.mfc import dialog
 
+# constants pulled from win32con to save memory
+BS_DEFPUSHBUTTON = 1
+BS_PUSHBUTTON = 0
+DS_MODALFRAME = 0x80
+DS_SETFONT = 0x40
+ES_PASSWORD = 0x20
+IDCANCEL = 2
+IDOK = 1
+SS_LEFT = 0 
+WS_BORDER = 0x800000
+WS_CAPTION = 0xc00000
+WS_CHILD = 0x40000000
+WS_POPUP = 0x80000000
+WS_SYSMENU = 0x80000
+WS_SYSMENU = 0x80000
+WS_TABSTOP = 0x10000
+WS_VISIBLE = 0x10000000
+
+# The following code can be used to check that the constant definitions are correct
+#
+#x = globals().copy()
+#from win32con import *
+#y = globals().copy()
+#for k,v in x.items():
+#    if y[k] != v:
+#        print k, x[v], y[v]
+        
 def MakeLoginDlgTemplate(title):
-	style = win32con.DS_MODALFRAME | win32con.WS_POPUP | win32con.WS_VISIBLE | win32con.WS_CAPTION | win32con.WS_SYSMENU | win32con.DS_SETFONT
-	cs = win32con.WS_CHILD | win32con.WS_VISIBLE
+	style = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_SETFONT
+	cs = WS_CHILD | WS_VISIBLE
 
 	# Window frame and title
 	dlg = [ [title, (0, 0, 184, 40), style, None, (8, "MS Sans Serif")], ]
 
 	# ID label and text box
-	dlg.append([130, "User ID:", -1, (7, 9, 69, 9), cs | win32con.SS_LEFT])
-	s = cs | win32con.WS_TABSTOP | win32con.WS_BORDER 
+	dlg.append([130, "User ID:", -1, (7, 9, 69, 9), cs | SS_LEFT])
+	s = cs | WS_TABSTOP | WS_BORDER 
 	dlg.append(['EDIT', None, win32ui.IDC_EDIT1, (50, 7, 60, 12), s])
 
 	# Password label and text box
-	dlg.append([130, "Password:", -1, (7, 22, 69, 9), cs | win32con.SS_LEFT])
-	s = cs | win32con.WS_TABSTOP | win32con.WS_BORDER 
-	dlg.append(['EDIT', None, win32ui.IDC_EDIT2, (50, 20, 60, 12), s | win32con.ES_PASSWORD])
+	dlg.append([130, "Password:", -1, (7, 22, 69, 9), cs | SS_LEFT])
+	s = cs | WS_TABSTOP | WS_BORDER 
+	dlg.append(['EDIT', None, win32ui.IDC_EDIT2, (50, 20, 60, 12), s | ES_PASSWORD])
 
 	# OK/Cancel Buttons
-	s = cs | win32con.WS_TABSTOP 
-	dlg.append([128, "OK", win32con.IDOK, (124, 5, 50, 14), s | win32con.BS_DEFPUSHBUTTON])
-	s = win32con.BS_PUSHBUTTON | s
-	dlg.append([128, "Cancel", win32con.IDCANCEL, (124, 20, 50, 14), s])
+	s = cs | WS_TABSTOP 
+	dlg.append([128, "OK", IDOK, (124, 5, 50, 14), s | BS_DEFPUSHBUTTON])
+	s = BS_PUSHBUTTON | s
+	dlg.append([128, "Cancel", IDCANCEL, (124, 20, 50, 14), s])
 	return dlg
 
 def MakePasswordDlgTemplate(title):
-	style = win32con.DS_MODALFRAME | win32con.WS_POPUP | win32con.WS_VISIBLE | win32con.WS_CAPTION | win32con.WS_SYSMENU | win32con.DS_SETFONT
-	cs = win32con.WS_CHILD | win32con.WS_VISIBLE
+	style = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_SETFONT
+	cs = WS_CHILD | WS_VISIBLE
 	# Window frame and title
 	dlg = [ [title, (0, 0, 177, 45), style, None, (8, "MS Sans Serif")], ]
 	
 	# Password label and text box
-	dlg.append([130, "Password:", -1, (7, 7, 69, 9), cs | win32con.SS_LEFT])
-	s = cs | win32con.WS_TABSTOP | win32con.WS_BORDER 
-	dlg.append(['EDIT', None, win32ui.IDC_EDIT1, (50, 7, 60, 12), s | win32con.ES_PASSWORD])
+	dlg.append([130, "Password:", -1, (7, 7, 69, 9), cs | SS_LEFT])
+	s = cs | WS_TABSTOP | WS_BORDER 
+	dlg.append(['EDIT', None, win32ui.IDC_EDIT1, (50, 7, 60, 12), s | ES_PASSWORD])
 	
 	# OK/Cancel Buttons
-	s = cs | win32con.WS_TABSTOP | win32con.BS_PUSHBUTTON
-	dlg.append([128, "OK", win32con.IDOK, (124, 5, 50, 14), s | win32con.BS_DEFPUSHBUTTON])
-	dlg.append([128, "Cancel", win32con.IDCANCEL, (124, 22, 50, 14), s])
+	s = cs | WS_TABSTOP | BS_PUSHBUTTON
+	dlg.append([128, "OK", IDOK, (124, 5, 50, 14), s | BS_DEFPUSHBUTTON])
+	dlg.append([128, "Cancel", IDCANCEL, (124, 22, 50, 14), s])
 	return dlg
 
 class LoginDlg(dialog.Dialog):
@@ -80,7 +106,7 @@
 	d = LoginDlg(title)
 	d['userid'] = userid
 	d['password'] = password
-	if d.DoModal() != win32con.IDOK:
+	if d.DoModal() != IDOK:
 		return (None, None)
 	else:	
 		return (d['userid'], d['password'])
@@ -93,7 +119,7 @@
 def GetPassword(title='Password', password=''):
 	d = PasswordDlg(title)
 	d['password'] = password
-	if d.DoModal()!=win32con.IDOK:
+	if d.DoModal()!= IDOK:
 		return ''
 	return d['password']
 

==== //depot/main/Apps/Komodo-devel/src/commandments/prototype/komodo.py#6 (text) ====

@@ -10,7 +10,7 @@
     import win32pipe
     import win32api
     import win32file
-    import win32con
+    SW_SHOWDEFAULT = 10 # from win32con
     import win32process
     import win32event
     from win32com.shell import shellcon, shell
@@ -63,7 +63,7 @@
     if sys.platform.startswith("win"):
         si = win32process.STARTUPINFO() 
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
-        si.wShowWindow = win32con.SW_SHOWDEFAULT
+        si.wShowWindow = SW_SHOWDEFAULT
 
         hProcess, hThread, processId, threadId\
             = win32process.CreateProcess(

==== //depot/main/Apps/Komodo-devel/src/misc-components/koInitService.py#43 (text) ====

@@ -150,8 +150,8 @@
                 # media is accessed, but not available
                 # (eg, when a file from a floppy is on the MRU,
                 # but no floppy is in the drive)
-                import win32api, win32con
-                win32api.SetErrorMode(win32con.SEM_FAILCRITICALERRORS)
+                SEM_FAILCRITICALERRORS = 1 # constant pulled from win32con to save memory
+                win32api.SetErrorMode(SEM_FAILCRITICALERRORS)
             except ImportError:
                 logError("Could not import win32api/win32con to set the "\
                          "Win32 Error Mode.")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/memutils.py#2 (text) ====

@@ -89,8 +89,10 @@
         return pids
         
     def kill(pid):
-        import win32api, win32con
-        handle = win32api.OpenProcess(win32con.PROCESS_TERMINATE, 0,pid)
+        import win32api
+        # constants pulled from win32con to save memory
+        PROCESS_TERMINATE = 1 # from win32con
+        handle = win32api.OpenProcess(PROCESS_TERMINATE, 0,pid)
         win32api.TerminateProcess(handle,0)
         win32api.CloseHandle(handle)
     
@@ -115,13 +117,13 @@
     if kb > 1000:
         mb = kb / 1024.
         return "%3.1f M" % mb
-    return "%3.1f k" % kb
+    return "%3d k" % kb
 
 _imported_modules = {}
 module_tree = {}
 current_module = module_tree
 from logging import getLogger
-logger = getLogger('perf')
+#logger = getLogger('perf')
 def _memory_import(name, *args, **kw):
     global current_module
     start = int(my_process_memory())
@@ -135,7 +137,7 @@
         realname = name
     mem = end-start
     if mem:
-        logger.info("%s\t%s" % (realname, memoryrepr(mem)))
+        #logger.info("%s\t%s" % (realname, memoryrepr(mem)))
         current_module['memory'] = memoryrepr(mem)
     current_module = orig
     if not current_module[name]:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#55 (text) ====

@@ -135,8 +135,14 @@
     import pywintypes
     import win32process
     import win32event
-    import win32con
     import win32gui
+    # constants pulled from win32con to save memory
+    VER_PLATFORM_WIN32_WINDOWS = 1
+    CTRL_BREAK_EVENT = 1
+    SW_SHOWDEFAULT = 10
+    WM_CLOSE = 0x10
+    DUPLICATE_SAME_ACCESS = 2
+    
 else:
     import signal
 
@@ -327,7 +333,7 @@
         values either be all ASCII or all unicode. Try to remove this burden
         from the user of process.py.
         """
-        isWin9x = win32api.GetVersionEx()[3] == win32con.VER_PLATFORM_WIN32_WINDOWS
+        isWin9x = win32api.GetVersionEx()[3] == VER_PLATFORM_WIN32_WINDOWS
         # On Win9x all keys and values of 'env' must be ASCII (XXX
         # Actually this is probably only true if the Unicode support
         # libraries, which are not installed by default, are not
@@ -839,7 +845,7 @@
 
         si = win32process.STARTUPINFO() 
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
-        si.wShowWindow = win32con.SW_SHOWDEFAULT
+        si.wShowWindow = SW_SHOWDEFAULT
 
         if not (self._flags & self.CREATE_NEW_CONSOLE):
             #XXX This is hacky.
@@ -958,7 +964,7 @@
             # console. This is supposed to trigger shutdown handlers in
             # each of the processes.
             try:
-                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                win32api.GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,
                                                   self._processId)
             except AttributeError:
                 log.warn("The win32api module does not have "\
@@ -999,7 +1005,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
-            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
+            win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
 class ProcessOpen(Process):
@@ -1158,7 +1164,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStdinWr)
             self._hChildStdinWr = hChildStdinWrDup
             hChildStdoutRdDup = win32api.DuplicateHandle(
@@ -1167,7 +1173,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStdoutRd)
             self._hChildStdoutRd = hChildStdoutRdDup
             hChildStderrRdDup = win32api.DuplicateHandle(
@@ -1176,7 +1182,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStderrRd)
             self._hChildStderrRd = hChildStderrRdDup
 
@@ -1325,7 +1331,7 @@
             # console. This is supposed to trigger shutdown handlers in
             # each of the processes.
             try:
-                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                win32api.GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,
                                                   self._processId)
             except AttributeError:
                 log.warn("The win32api module does not have "\
@@ -1368,7 +1374,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
-            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
+            win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
 class ProcessProxy(Process):
@@ -1574,7 +1580,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStdinWr)
             self._hChildStdinWr = hChildStdinWrDup
             hChildStdoutRdDup = win32api.DuplicateHandle(
@@ -1583,7 +1589,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStdoutRd)
             self._hChildStdoutRd = hChildStdoutRdDup
             hChildStderrRdDup = win32api.DuplicateHandle(
@@ -1592,7 +1598,7 @@
                 win32api.GetCurrentProcess(),
                 0,
                 0, # not inherited
-                win32con.DUPLICATE_SAME_ACCESS)
+                DUPLICATE_SAME_ACCESS)
             win32api.CloseHandle(hChildStderrRd)
             self._hChildStderrRd = hChildStderrRdDup
 
@@ -1755,7 +1761,7 @@
             # console. This is supposed to trigger shutdown handlers in
             # each of the processes.
             try:
-                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                win32api.GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,
                                                   self._processId)
             except AttributeError:
                 log.warn("The win32api module does not have "\
@@ -1798,7 +1804,7 @@
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
-            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
+            win32gui.PostMessage(hwnd, WM_CLOSE, 0, 0)
 
 
 class IOBuffer:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/progressbar.py#7 (text) ====

@@ -29,23 +29,26 @@
 
 if sys.platform.startswith('win'):
     TOTALNUMSTEPS = 138  # this needs to be tweaked depending on when "ticks" are sent.
-    import win32gui, win32con, win32api  
+    import win32gui, win32api  
     import sys
 
-    PBM_SETRANGE = win32con.WM_USER + 1
-    PBM_GETRANGE = win32con.WM_USER + 7
-    PBM_SETRANGE32 = win32con.WM_USER + 111
-    PBM_SETPOS = win32con.WM_USER + 2
-    PBM_DELTAPOS = win32con.WM_USER + 3
-    PBM_SETSTEP = win32con.WM_USER + 4
-    PBM_STEPIT = win32con.WM_USER + 5
+    # constants pulled from win32con to save memory
+    WM_USER = 0x400
+    GWL_USERDATA = 0xffffffeb
+    PBM_SETRANGE = WM_USER + 1
+    PBM_GETRANGE = WM_USER + 7
+    PBM_SETRANGE32 = WM_USER + 111
+    PBM_SETPOS = WM_USER + 2
+    PBM_DELTAPOS = WM_USER + 3
+    PBM_SETSTEP = WM_USER + 4
+    PBM_STEPIT = WM_USER + 5
 
     progressControl = None
     labelControl = None
 
     numSteps = 0
     def _MyCallback( hwnd, extra ):
-        userdata = win32api.GetWindowLong(hwnd, win32con.GWL_USERDATA)
+        userdata = win32api.GetWindowLong(hwnd, GWL_USERDATA)
         # This is a special random number set in nsNativAppSupportWin.cpp that identifies the splash screen
         # the number is chosen to not possibly being a valid pointer, and to try and be somewhat random.
         if userdata == 11757453:
Change 51289 by trentm@trentm-planer on 2002/11/13 14:06:47

	   Make "CreateProcess" error messages a little more helpful when trying to
	   create a "Process".

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#54 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#54 (text) ====

@@ -871,7 +871,9 @@
                     si)             # STARTUPINFO pointer 
             win32api.CloseHandle(self._hThread)
         except win32api.error, ex:
-            raise ProcessError(msg=ex.args[2], errno=ex.args[0])
+            raise ProcessError(msg="Error creating process for '%s': %s"\
+                                   % (cmd, ex.args[2]),
+                               errno=ex.args[0])
 
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
Change 50501 by trentm@trentm-planer on 2002/11/06 13:57:28

	Drop obselete comment.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#53 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#53 (text) ====

@@ -1810,9 +1810,6 @@
     until write provides the needed data, termination) are handled for
     free.
 
-    Would be nice to support:
-        .readlines(sizehint=0)
-
     Cannot support:
         .seek()     # Because we are managing *two* positions (one each
         .tell()     #   for reading and writing), these do not make
Change 47010 by trentm@trentm-planer on 2002/09/24 16:45:11

	Fix http://bugs.activestate.com/Komodo/show_bug.cgi?id=20650
	'No way to kill hung "run command" processes?'
	
	GenerateConsoleCtrlEvent does not work in Komodo-land with no real console.
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#52 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#52 (text) ====

@@ -963,9 +963,11 @@
                          "GenerateConsoleCtrlEvent(). This may mean that "\
                          "parts of this process group have NOT been killed.")
             except win32api.error, ex:
-                if ex.args[0] != 87:
-                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
-                    #                     'The parameter is incorrect.')
+                if ex.args[0] not in (6, 87):
+                    # Ignore the following:
+                    #   api_error: (87, 'GenerateConsoleCtrlEvent', 'The parameter is incorrect.')
+                    #   api_error: (6, 'GenerateConsoleCtrlEvent', 'The handle is invalid.')
+                    # Get error 6 if there is no console.
                     raise
             
             # Last resort: call TerminateProcess if it has not yet.
@@ -1328,9 +1330,11 @@
                          "GenerateConsoleCtrlEvent(). This may mean that "\
                          "parts of this process group have NOT been killed.")
             except win32api.error, ex:
-                if ex.args[0] != 87:
-                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
-                    #                     'The parameter is incorrect.')
+                if ex.args[0] not in (6, 87):
+                    # Ignore the following:
+                    #   api_error: (87, 'GenerateConsoleCtrlEvent', 'The parameter is incorrect.')
+                    #   api_error: (6, 'GenerateConsoleCtrlEvent', 'The handle is invalid.')
+                    # Get error 6 if there is no console.
                     raise
             
             # Last resort: call TerminateProcess if it has not yet.
@@ -1756,9 +1760,11 @@
                          "GenerateConsoleCtrlEvent(). This may mean that "\
                          "parts of this process group have NOT been killed.")
             except win32api.error, ex:
-                if ex.args[0] != 87:
-                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
-                    #                     'The parameter is incorrect.')
+                if ex.args[0] not in (6, 87):
+                    # Ignore the following:
+                    #   api_error: (87, 'GenerateConsoleCtrlEvent', 'The parameter is incorrect.')
+                    #   api_error: (6, 'GenerateConsoleCtrlEvent', 'The handle is invalid.')
+                    # Get error 6 if there is no console.
                     raise
             
             # Last resort: call TerminateProcess if it has not yet.
Change 46646 by trentm@trentm-planer on 2002/09/20 14:52:49

	   Fix _FileWrapper's .readline()'s termination condition. If the child's
	   stdout finished with output in the line buffer that did not terminate
	   with a newline then .readline() would keep trying os.read(fd). readline
	   tested that no text was returned from the child (the file descriptor read
	   termination condition) but did not consider the characters already in the
	   line buffer in its test.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#51 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#51 (text) ====

@@ -624,8 +624,9 @@
                         self._lineBuf[:idx+1], self._lineBuf[idx+1:]
                     break
                 else:
+                    lengthBefore = len(self._lineBuf)
                     t = self.read(4092)
-                    if not t:
+                    if len(t) <= lengthBefore: # no new data was read
                         line, self._lineBuf = self._lineBuf, ""
                         break
                     else:
Change 45578 by trentm@trentm-press on 2002/09/05 16:23:50

	   Refactor the _ThreadFixer class (which works around the LinuxThreads bug
	   where you can only wait on a child process from the thread that launched
	   it).
	
	   Before: The proxy thread would wait on a queue of request (either of type
	   "wait" or "stop"). The overriden .wait() would put in a "wait" request and
	   then block until the proxy thread had a result for that request. That
	   worked except that the proxy thread could never figure out when to finish
	   (because you cannot wait on a Queue *and* wait on a process) -- hence the
	   "stop" request type that was sent from an overriden .close(). That was
	   hacky and hang-prone.
	
	   Now: The proxy thread just starts the child and then immediately wait's for
	   the child to terminate. On termination is stores the exit status (for use
	   by the main thread) and notifies any thread waiting for this termination
	   (possibly the main thread). The overriden .wait() now just uses this stored
	   exit status and the termination notification to simulate the .wait().
	
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#50 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#50 (text) ====

@@ -808,13 +808,13 @@
     def _forkAndExecChildOnUnix(self):
         """Fork and start the child process.
 
-        Returns the child pid.
+        Sets self._pid as a side effect.
         """
         pid = os.fork()
         if pid == 0: # child
             self._runChildOnUnix()
         # parent
-        return pid
+        self._pid = pid
 
     def _startOnUnix(self):
         if self._cwd:
@@ -823,7 +823,7 @@
                 os.chdir(self._cwd)
             except OSError, ex:
                 raise ProcessError(msg=str(ex), errno=ex.errno)
-        self._pid = self._forkAndExecChildOnUnix()
+        self._forkAndExecChildOnUnix()
 
         # parent
         if self._cwd:
@@ -1085,7 +1085,7 @@
                                 fdChildStderrWr):
         """Fork and start the child process.
 
-        Returns the child pid.
+        Sets self._pid as a side effect.
         """
         pid = os.fork()
         if pid == 0: # child
@@ -1094,7 +1094,7 @@
             os.dup2(fdChildStderrWr, 2)
             self._runChildOnUnix()
         # parent
-        return pid
+        self._pid = pid
 
     def _startOnUnix(self):
         # Create pipes for std handles.
@@ -1108,8 +1108,8 @@
                 os.chdir(self._cwd)
             except OSError, ex:
                 raise ProcessError(msg=str(ex), errno=ex.errno)
-        self._pid = self._forkAndExecChildOnUnix(fdChildStdinRd,
-            fdChildStdoutWr, fdChildStderrWr)
+        self._forkAndExecChildOnUnix(fdChildStdinRd, fdChildStdoutWr,
+                                     fdChildStderrWr)
         if self._cwd:
             os.chdir(oldDir)
 
@@ -1484,7 +1484,7 @@
                                 fdChildStderrWr):
         """Fork and start the child process.
 
-        Returns the child pid.
+        Sets self._pid as a side effect.
         """
         pid = os.fork()
         if pid == 0: # child
@@ -1493,7 +1493,7 @@
             os.dup2(fdChildStderrWr, 2)
             self._runChildOnUnix()
         # parent
-        return pid
+        self._pid = pid
 
     def _startOnUnix(self):
         # Create pipes for std handles.
@@ -1507,8 +1507,8 @@
                 os.chdir(self._cwd)
             except OSError, ex:
                 raise ProcessError(msg=str(ex), errno=ex.errno)
-        self._pid = self._forkAndExecChildOnUnix(fdChildStdinRd,
-            fdChildStdoutWr, fdChildStderrWr)
+        self._forkAndExecChildOnUnix(fdChildStdinRd, fdChildStdoutWr,
+                                     fdChildStderrWr)
         if self._cwd:
             os.chdir(oldDir)
 
@@ -2145,8 +2145,6 @@
 
 
 if sys.platform.startswith("linux"):
-    import Queue
-
     class _ThreadFixer:
         """Mixin class for various classes in the Process hierarchy to
         work around the known LinuxThreads bug where one cannot .wait()
@@ -2156,128 +2154,98 @@
         Usage:
             class ProcessXXX(_ThreadFixer, BrokenProcessXXX):
                 _pclass = BrokenProcessXXX
+
+        Details:
+            Because we must do all real os.wait() calls on the child
+            process from the thread that spawned it, we use a proxy
+            thread whose only responsibility is just that. The proxy
+            thread just starts the child and then immediately wait's for
+            the child to terminate. On termination is stores the exit
+            status (for use by the main thread) and notifies any thread
+            waiting for this termination (possibly the main thread). The
+            overriden .wait() uses this stored exit status and the
+            termination notification to simulate the .wait().
         """
         def __init__(self, *args, **kwargs):
             # Keep a reference to 'log' ensure it is around for this object's
             # destruction.
             self.__log = log
-            self.__pid = None
-            self.__pidReady = threading.Condition()
-            self.__requestResult = None
-            self.__requestFinished = threading.Condition()
-            self.__requests = Queue.Queue()
-            self.__terminated = 0
-            self.__exitStatus = None
             self.__waiter = None
+            self.__hasTerminated = threading.Condition()
+            self.__terminationResult = None
+            self.__childStarted = threading.Condition()
             self._pclass.__init__(self, *args, **kwargs)
 
         def _forkAndExecChildOnUnix(self, *args, **kwargs):
             """Fork and start the child process do it in a special subthread
             that will negotiate subsequent .wait()'s.
 
-            Returns the child pid.
+            Sets self._pid as a side effect.
             """
             self.__waiter = threading.Thread(
                 target=self.__launchAndWait, args=args, kwargs=kwargs)
 
-            # Start subthread which will launch child. Wait for the child to
-            # be launched then return the child's pid.
+            # Start subthread that will launch child and wait until it
+            # *has* started.
+            self.__childStarted.acquire()
             self.__waiter.start()
-            self.__pidReady.acquire()
-            if self.__pid is None:
-                self.__pidReady.wait()
-            self.__pidReady.release()
-            return self.__pid
+            self.__childStarted.wait()
+            self.__childStarted.release()
 
-        def close(self):
-            logfix.info("request waiter stop from thread %s",
-                        threading.currentThread().getName())
-            self.__requests.put( ("stop",) )
+        def __launchAndWait(self, *args, **kwargs):
+            """Launch the given command and wait for it to terminate.
 
-            # Wait the proxy thread to complete. (Must get own reference
-            # to the thread to ensure that we do not call None.join()
-            # because the proxy thread sets self.__waiter = None when it
-            # ends.)
-            waiter = self.__waiter
-            if waiter:
-                waiter.join()
-
-            self._pclass.close(self)
-
-        def __launchAndWait(self, *args, **kwargs):
+            When the process has terminated then store its exit value
+            and finish.
+            """
             logfix.info("start child in thread %s",
                         threading.currentThread().getName())
-            pid = self._pclass._forkAndExecChildOnUnix(self, *args, **kwargs)
 
-            # Pass the PID back to the main thread.
-            self.__pidReady.acquire()
-            self.__pid = pid
-            self.__pidReady.notifyAll()
-            self.__pidReady.release()
+            # Spawn the child process and notify the main thread of
+            # this.
+            self.__childStarted.acquire()
+            self._pclass._forkAndExecChildOnUnix(self, *args, **kwargs)
+            self.__childStarted.notifyAll()
+            self.__childStarted.release()
 
-            # Process requests until done.
-            while 1:
-                request = self.__requests.get()
-                logfix.info("waiter: '%s' request", request[0])
-                if request[0] == "wait":
-                    try:
-                        self.__requestResult =\
-                            self._pclass.wait(self, timeout=request[1])
-                        self.__terminated = 1
-                        self.__exitStatus = self.__requestResult
-                    except Exception, ex:
-                        self.__requestResult = ex
-                    logfix.info("waiter: wait for process: result=%r",
-                                self.__requestResult)
-                    self.__requestFinished.acquire()
-                    self.__requestFinished.notify()
-                    self.__requestFinished.release()
-                elif request[0] == "stop":
-                    self.__terminated = 1
-
-                if self.__terminated:
-                    # No need to proxy requests anymore if the process
-                    # has "terminated" (where "terminated" might be
-                    # artificial if .close() was called).
-                    logfix.info("waiter: process terminated, exiting, sts=%s",
-                                self.__exitStatus)
-                    break
-
-            # Now that the process is terminated, no new requests
-            # will come to this thread, but still need to exhaust the
-            # current Queue of requests.
-            while 1:
-                try:
-                    request = self.__requests.get_nowait()
-                except Queue.Empty:
-                    break
-                logfix.info("waiter: cleaning out '%s' request after "\
-                            "termination", request[0])
-                if request[0] == "wait":
-                    self.__requestResult = self.__exitStatus
-                    self.__requestFinished.acquire()
-                    self.__requestFinished.notify()
-                    self.__requestFinished.release()
-                elif request[0] == "stop":
-                    pass
+            # Wait on the thread and store appropriate results when
+            # finished.
+            try:
+                waitResult = self._pclass.wait(self)
+            except ProcessError, ex:
+                waitResult = ex
+            self.__hasTerminated.acquire()
+            self.__terminationResult = waitResult
+            self.__hasTerminated.notifyAll()
+            self.__hasTerminated.release()
 
             self.__waiter = None # drop ref that would keep instance alive
+        
+        def wait(self, timeout=None): 
+            # If the process __hasTerminated then return the exit
+            # status. Otherwise simulate the wait as appropriate.
+            # Note:
+            #   - This class is only used on linux so 'timeout' has the
+            #     Unix 'timeout' semantics.
+            self.__hasTerminated.acquire()
+            if self.__terminationResult is None:
+                if timeout == os.WNOHANG:   # Poll.
+                    self.__hasTerminated.wait(0)
+                else:                       # Block until process finishes.
+                    self.__hasTerminated.wait()
+            terminationResult = self.__terminationResult
+            self.__hasTerminated.release()
 
-        def wait(self, timeout=None): 
-            if self.__terminated:
-                return self.__exitStatus
+            if terminationResult is None:
+                # process has not finished yet
+                raise ProcessError("Wait for process timed out.",
+                                   self.WAIT_TIMEOUT)
+            elif isinstance(terminationResult, Exception):
+                # some error waiting for process termination
+                raise terminationResult
             else:
-                logfix.info("request wait from thread %s",
-                            threading.currentThread().getName())
-                self.__requestFinished.acquire()
-                self.__requests.put( ('wait', timeout) )
-                self.__requestFinished.wait()
-                self.__requestFinished.release()
-
-                if isinstance(self.__requestResult, Exception):
-                    raise self.__requestResult
-                else:
-                    return self.__requestResult
+                # the process terminated
+                return terminationResult
 
     _ThreadBrokenProcess = Process
     class Process(_ThreadFixer, _ThreadBrokenProcess):
Change 45556 by trentm@trentm-press on 2002/09/05 13:42:47

	Finally get the test suite to pass on Linux.
	   - Fix a circular reference that was preventing Process* instances from
	     destructing.
	   - Ensure no exception in _ThreadFixer's proxy thread on artificial
	     termination (i.e. when .close is called before the process has actually
	     terminated.)
	
	   COMMANDMENT: Thou shalt always call .close() on a created process object
	                when thou art finished with it.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#49 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#14 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#49 (text) ====

@@ -1840,7 +1840,7 @@
         self.__buf += s  # Append to buffer.
 
     def write(self, s):
-        log.info("[%s] IOBuffer.write(s=%r)" % (self._name, s))
+        log.info("[%s] IOBuffer.write(s=%r)", self._name, s)
         # Silently drop writes after the buffer has been close()'d.
         if self._closed:
             return
@@ -2138,8 +2138,8 @@
                          % (self.getName(), self.fChild))
                 break
 
-            log.info("[%s] _OutFileProxy: text(len=%d): %r"\
-                     % (self.getName(), len(text), text))
+            log.info("[%s] _OutFileProxy: text(len=%d): %r",
+                     self.getName(), len(text), text)
             self.fParent.write(text)
 
 
@@ -2154,8 +2154,8 @@
         the process.
 
         Usage:
-            class ProcessXXXWithThreadFix(_ThreadFixer, ProcessXXX):
-                _pclass = ProcessXXX
+            class ProcessXXX(_ThreadFixer, BrokenProcessXXX):
+                _pclass = BrokenProcessXXX
         """
         def __init__(self, *args, **kwargs):
             # Keep a reference to 'log' ensure it is around for this object's
@@ -2193,8 +2193,15 @@
             logfix.info("request waiter stop from thread %s",
                         threading.currentThread().getName())
             self.__requests.put( ("stop",) )
-            if self.__waiter:
-                self.__waiter.join()
+
+            # Wait the proxy thread to complete. (Must get own reference
+            # to the thread to ensure that we do not call None.join()
+            # because the proxy thread sets self.__waiter = None when it
+            # ends.)
+            waiter = self.__waiter
+            if waiter:
+                waiter.join()
+
             self._pclass.close(self)
 
         def __launchAndWait(self, *args, **kwargs):
@@ -2229,10 +2236,9 @@
                     self.__terminated = 1
 
                 if self.__terminated:
-                    # No need to proxy .wait() and .kill() requests if the
-                    # process is done.
-                    if self.__exitStatus is None:
-                        self.__exitStatus = self._pclass.wait(self, os.WNOHANG)
+                    # No need to proxy requests anymore if the process
+                    # has "terminated" (where "terminated" might be
+                    # artificial if .close() was called).
                     logfix.info("waiter: process terminated, exiting, sts=%s",
                                 self.__exitStatus)
                     break
@@ -2255,6 +2261,8 @@
                 elif request[0] == "stop":
                     pass
 
+            self.__waiter = None # drop ref that would keep instance alive
+
         def wait(self, timeout=None): 
             if self.__terminated:
                 return self.__exitStatus

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#14 (text) ====

@@ -191,7 +191,6 @@
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
-
     def test_ProcessOpen_stdin_handle_cleanup_1(self):
         p1 = process.ProcessOpen(['ask'])
         p2 = process.ProcessOpen(['ask'])
@@ -201,8 +200,10 @@
         p2.stdin.close()
 
         p1.wait()
+        p1.close()
         del p1
         p2.wait()
+        p2.close()
 
         p1 = process.ProcessOpen(['ask'])
         p2 = process.ProcessOpen(['ask'])
@@ -214,6 +215,8 @@
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
         p2.kill()
+        p1.close()
+        p2.close()
 
     def test_ProcessOpen_stdin_handle_cleanup_2(self):
         p1 = process.ProcessOpen(['ask'])
@@ -224,7 +227,9 @@
         p2.stdin.close()
 
         p1.wait()
+        p1.close()
         p2.wait()
+        p2.close()
 
         p1 = process.ProcessOpen(['ask'])
         p2 = process.ProcessOpen(['ask'])
@@ -232,12 +237,15 @@
         p1.stdin.close()
 
         p2.kill()
+        p2.close()
+        p1.close()
 
     def test_ProcessOpen_stdin_buffer(self):
         p = process.ProcessOpen(['ask'])
         p.stdin.write("Trent\n")
         p.stdin.close()
         output = p.stdout.read()
+        p.close()
         expected = "What is your name?\nYour name is 'Trent'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
@@ -253,6 +261,7 @@
         # inheritability having been properly set.)
         p.stdin.close()
         output = p.stdout.read()
+        p.close()
         expected = "What is your name?\nYour name is 'Tre'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
@@ -270,6 +279,7 @@
                 "be hung. output=%r" % output)
         finally:
             p.kill()
+            p.close()
 
     ## This is left commented out because the use of 'sys.stdin' requires
     ## user interaction -- not really an automated test suite then.
@@ -290,6 +300,7 @@
         p.stdin.write("3\n")
         p.stdin.close()
         output = p.stdout.read()
+        p.close()
         expected = "1\n2\n3\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r (expected: %r). "\
@@ -304,6 +315,7 @@
             p.stdin.write("3\n")
             p.stdin.close()
             output = p.stdout.read()
+            p.close()
             expected = "???\r\n"
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r (expected: %r). "\
@@ -322,6 +334,7 @@
             p.stdin.write("3\r\n")
             p.stdin.close()
             output = p.stdout.read()
+            p.close()
             expected = "1\r\n2\r\n3\r\n"
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r (expected: %r). "\
Change 45493 by trentm@trentm-planer on 2002/09/04 17:09:58

	Possible fix for http://bugs.activestate.com/Komodo/show_bug.cgi?id=20479
	   There were reference cycles in ProcessOpen and ProcessProxy such that their
	   desctructors would never get called and system handles would not be freed.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#48 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#48 (text) ====

@@ -344,6 +344,13 @@
                 aenv[str(key)] = str(value)
             env = aenv
         
+        log.debug("""\
+_SaferCreateProcess(appName=%r,
+                    cmd=%r,
+                    env=%r,
+                    cwd=%r)
+    os.getcwd(): %r
+""", appName, cmd, env, cwd, os.getcwd())
         try:
             hProcess, hThread, processId, threadId\
                 = win32process.CreateProcess(appName, cmd, processSA,
@@ -514,11 +521,10 @@
     handle. If the file handle is not kept alive the Python file object
     will cease to function.)
     """
-    def __init__(self, file=None, descriptor=None, handle=None, process=None):
+    def __init__(self, file=None, descriptor=None, handle=None):
         self._file = file
         self._descriptor = descriptor
         self._handle = handle
-        self._process = process
         self._closed = 0
         if self._descriptor is not None or self._handle is not None:
             self._lineBuf = "" # to support .readline()
@@ -1038,6 +1044,7 @@
 
     def __del__(self):
         #XXX Should probably not rely upon this.
+        logres.info("[%s] ProcessOpen.__del__()", id(self))
         self.close()
         del self.__log # drop reference
 
@@ -1061,7 +1068,7 @@
                 self.stdout.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
-                # self.stdin, etc.
+                # self.stdout, etc.
                 pass
             try:
                 self.__log.info("[%s] ProcessOpen: closing stderr (%r)."\
@@ -1069,7 +1076,7 @@
                 self.stderr.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
-                # self.stdin, etc.
+                # self.stderr, etc.
                 pass
 
             self._closed = 1
@@ -1110,13 +1117,13 @@
         os.close(fdChildStdoutWr)
         os.close(fdChildStderrWr)
 
-        self.stdin = _FileWrapper(descriptor=fdChildStdinWr, process=self)
+        self.stdin = _FileWrapper(descriptor=fdChildStdinWr)
         logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
                     id(self), self.stdin)
-        self.stdout = _FileWrapper(descriptor=fdChildStdoutRd, process=self)
+        self.stdout = _FileWrapper(descriptor=fdChildStdoutRd)
         logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
                     id(self), self.stdout)
-        self.stderr = _FileWrapper(descriptor=fdChildStderrRd, process=self)
+        self.stderr = _FileWrapper(descriptor=fdChildStderrRd)
         logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
                     id(self), self.stderr)
 
@@ -1178,18 +1185,15 @@
             fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
 
             self.stdin = _FileWrapper(descriptor=fdChildStdinWr,
-                                      handle=self._hChildStdinWr,
-                                      process=self)
+                                      handle=self._hChildStdinWr)
             logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
                         id(self), self.stdin)
             self.stdout = _FileWrapper(descriptor=fdChildStdoutRd,
-                                       handle=self._hChildStdoutRd,
-                                       process=self)
+                                       handle=self._hChildStdoutRd)
             logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
                         id(self), self.stdout)
             self.stderr = _FileWrapper(descriptor=fdChildStderrRd,
-                                       handle=self._hChildStderrRd,
-                                       process=self)
+                                       handle=self._hChildStderrRd)
             logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
                         id(self), self.stderr)
 
@@ -1435,6 +1439,7 @@
 
     def __del__(self):
         #XXX Should probably not rely upon this.
+        logres.info("[%s] ProcessProxy.__del__()", id(self))
         self.close()
         del self.__log # drop reference
 
@@ -1511,13 +1516,13 @@
         os.close(fdChildStdoutWr)
         os.close(fdChildStderrWr)
 
-        childStdin = _FileWrapper(descriptor=fdChildStdinWr, process=self)
+        childStdin = _FileWrapper(descriptor=fdChildStdinWr)
         logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                     id(self), childStdin)
-        childStdout = _FileWrapper(descriptor=fdChildStdoutRd, process=self)
+        childStdout = _FileWrapper(descriptor=fdChildStdoutRd)
         logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                     id(self), childStdout)
-        childStderr = _FileWrapper(descriptor=fdChildStderrRd, process=self)
+        childStderr = _FileWrapper(descriptor=fdChildStderrRd)
         logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                     id(self), childStderr)
 
@@ -1596,18 +1601,15 @@
             fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
 
             childStdin = _FileWrapper(descriptor=fdChildStdinWr,
-                                      handle=self._hChildStdinWr,
-                                      process=self)
+                                      handle=self._hChildStdinWr)
             logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                         id(self), childStdin)
             childStdout = _FileWrapper(descriptor=fdChildStdoutRd,
-                                       handle=self._hChildStdoutRd,
-                                       process=self)
+                                       handle=self._hChildStdoutRd)
             logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                         id(self), childStdout)
             childStderr = _FileWrapper(descriptor=fdChildStderrRd,
-                                       handle=self._hChildStderrRd,
-                                       process=self)
+                                       handle=self._hChildStderrRd)
             logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                         id(self), childStderr)
 
@@ -2103,13 +2105,14 @@
                 self.fParent.close()
             except IOError:
                 pass # Ignore: IOError: [Errno 4] Interrupted system call
-            for item in self.toClose:
+            while self.toClose:
                 logres.info("[%s] _OutFileProxy: closing %r after "\
-                            "closing parent", self.getName(), item)
+                            "closing parent", self.getName(), self.toClose[0])
                 try:
-                    item.close()
+                    self.toClose[0].close()
                 except IOError:
                     pass # Ignore: IOError: [Errno 4] Interrupted system call
+                del self.toClose[0]
         log.info("[%s] _OutFileProxy: done" % self.getName())
 
     def _proxyFromChildToParent(self):
Change 45445 by trentm@trentm-press on 2002/09/04 12:20:04

	   Fix ProcessProxy to ensure that all std handle proxies have finished before
	   .close() returns. Before this is was possible for a passed in "stdout"
	   handler to have not received all output from the child after p.close() had
	   returned, thus causing confusion on the user end. Now, p.close() join's all
	   std handle proxy threads. This _ThreadFixer stuff exacerbated this problem
	   but putting another thread in the game (i.e. another thread that could keep
	   control away from the proxy threads).

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#47 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#47 (text) ====

@@ -1448,6 +1448,7 @@
                             % (id(self), self.stdin))
             try:
                 self.stdin.close()
+                self._stdinProxy.join()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stdin, etc.
@@ -1456,6 +1457,8 @@
                             % (id(self), self.stdout))
             try:
                 self.stdout.close()
+                if self._stdoutProxy is not threading.currentThread():
+                    self._stdoutProxy.join()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stdout, etc.
@@ -1464,6 +1467,7 @@
                             % (id(self), self.stderr))
             try:
                 self.stderr.close()
+                self._stderrProxy.join()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stderr, etc.
@@ -1518,19 +1522,19 @@
                     id(self), childStderr)
 
         # Create proxy threads for the out pipes.
-        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
-        stdinProxy.start()
+        self._stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
+        self._stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
         # the child has closed its side of <stdout>. (This is one way of
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
-        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
-                                   [self.stdin, childStdin, self],
-                                   name='<stdout>')
-        stdoutProxy.start()
-        stderrProxy = _OutFileProxy(childStderr, self.stderr,
-                                   name='<stderr>')
-        stderrProxy.start()
+        self._stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
+                                          [self.stdin, childStdin, self],
+                                          name='<stdout>')
+        self._stdoutProxy.start()
+        self._stderrProxy = _OutFileProxy(childStderr, self.stderr,
+                                          name='<stderr>')
+        self._stderrProxy.start()
 
     def _startOnWindows(self):
         if type(self._cmd) in (types.ListType, types.TupleType):
@@ -1643,20 +1647,20 @@
             win32file.CloseHandle(hChildStdoutWr)
             win32file.CloseHandle(hChildStderrWr)
 
-        # Create proxy threads for the out pipes.
-        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
-        stdinProxy.start()
+        # Create proxy threads for the pipes.
+        self._stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
+        self._stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
         # the child has closed its side of <stdout>. (This is one way of
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
-        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
-                                   [self.stdin, childStdin, self],
-                                   name='<stdout>')
-        stdoutProxy.start()
-        stderrProxy = _OutFileProxy(childStderr, self.stderr,
-                                   name='<stderr>')
-        stderrProxy.start()
+        self._stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
+                                          [self.stdin, childStdin, self],
+                                          name='<stdout>')
+        self._stdoutProxy.start()
+        self._stderrProxy = _OutFileProxy(childStderr, self.stderr,
+                                          name='<stderr>')
+        self._stderrProxy.start()
 
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
Change 45438 by trentm@trentm-press on 2002/09/04 11:29:41

	   Remove mention of ProcessProxyWithThreadFix in the test suite and from
	   comments in process.py. This has been removed infavour of having that
	   functionality as the default ProcessProxy behaviour.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#46 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#9 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#10 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#13 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#10 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#8 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#46 (text) ====

@@ -198,7 +198,7 @@
 # Loggers:
 #   - 'log' to log normal process handling
 #   - 'logres' to track system resource life
-#   - 'logfix' to track wait/kill proxying in ProcessProxyWithThreadFix
+#   - 'logfix' to track wait/kill proxying in _ThreadFixer
 if 1:   # normal/production usage
     log = Logger("process", Logger.WARN)
 else:   # development/debugging usage
@@ -912,7 +912,7 @@
             # (XXX It would require synchronization code to handle the case
             # of multiple simultaneous .wait() requests, however we can punt
             # on that because it is moot while Linux still has the problem
-            # for which Process*WithThreadFix() exists.)
+            # for which _ThreadFixer() exists.)
             if self.__retvalCache is not None:
                 retval = self.__retvalCache
             else:
@@ -1278,7 +1278,7 @@
             # (XXX It would require synchronization code to handle the case
             # of multiple simultaneous .wait() requests, however we can punt
             # on that because it is moot while Linux still has the problem
-            # for which Process*WithThreadFix() exists.)
+            # for which _ThreadFixer() exists.)
             if self.__retvalCache is not None:
                 retval = self.__retvalCache
             else:
@@ -1704,7 +1704,7 @@
             # (XXX It would require synchronization code to handle the case
             # of multiple simultaneous .wait() requests, however we can punt
             # on that because it is moot while Linux still has the problem
-            # for which Process*WithThreadFix() exists.)
+            # for which _ThreadFixer() exists.)
             if self.__retvalCache is not None:
                 retval = self.__retvalCache
             else:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#9 (text) ====

@@ -159,22 +159,6 @@
             if os.path.exists(dname):
                 os.removedirs(dname)
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_simple_cmd(self):
-            p = process.ProcessProxyWithThreadFix('echo hi there')
-            output = p.stdout.read()
-            self.failUnless(output.strip() == 'hi there')
-
-        def test_ProcessProxyWithThreadFix_cmd_with_quotes(self):
-            p = process.ProcessProxyWithThreadFix('echo hi "there"')
-            output = p.stdout.read()
-            if sys.platform.startswith("win"):
-                expected = 'hi "there"'
-            else:
-                expected = 'hi there'
-            self.failUnless(output.strip() == expected)
-
     def test_ProcessOpen_simple_cmd(self):
         try:
             p = process.ProcessOpen('echo hi there')

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#10 (text) ====

@@ -76,71 +76,6 @@
     
         testsupport.rmtree(wd)
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_cwd_notspecified(self):
-            cwd = os.getcwd()
-
-            p = process.ProcessProxyWithThreadFix(['printcwd'])
-            output = p.stdout.read()
-
-            pattern = re.compile("CWD is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == cwd,
-                            "%r != %r" % (match.group(1), cwd))
-
-        def test_ProcessProxyWithThreadFix_cwd_specified(self):
-            wd = os.path.expanduser('~')
-
-            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
-            output = p.stdout.read()
-
-            pattern = re.compile("CWD is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == wd,
-                            "%r != %r" % (match.group(1), wd))
-
-        def test_ProcessProxyWithThreadFix_cwd_specified_doesnotexist(self):
-            wd = "foobar"
-            self.failUnlessRaises(process.ProcessError, process.ProcessProxyWithThreadFix,
-                                  cmd=['printcwd'], cwd=wd)
-
-        def test_ProcessProxyWithThreadFix_cwd_specified_relative(self):
-            wd = "mytmprelativedir"
-            testsupport.mkdir(wd)
-
-            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
-            output = p.stdout.read()
-
-            pattern = re.compile("CWD is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == os.path.abspath(wd),
-                            "%r != %r" % (match.group(1), os.path.abspath(wd)))
-        
-            testsupport.rmtree(wd)
-
-        def test_ProcessProxyWithThreadFix_cwd_specified_withspaces(self):
-            wd = "my tmp relative dir with spaces"
-            testsupport.mkdir(wd)
-
-            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
-            output = p.stdout.read()
-
-            pattern = re.compile("CWD is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == os.path.abspath(wd),
-                            "%r != %r" % (match.group(1), os.path.abspath(wd)))
-        
-            testsupport.rmtree(wd)
-
     def test_ProcessOpen_cwd_notspecified(self):
         cwd = os.getcwd()
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#7 (text) ====

@@ -72,69 +72,6 @@
         self.failUnless(os.environ['TALK_ENV'] == 'spam')
         os.environ['TALK_ENV'] = ''
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_env_unspecified(self):
-            talkenv = ''
-
-            p = process.ProcessProxyWithThreadFix(['printenv'])
-            output = p.stdout.read()
-
-            pattern = re.compile("TALK_ENV is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == talkenv,
-                            "%r != %r" % (match.group(1), talkenv))
-
-        def test_ProcessProxyWithThreadFix_env_inherited(self):
-            talkenv = 'foo'
-            os.environ['TALK_ENV'] = 'foo'
-
-            p = process.ProcessProxyWithThreadFix(['printenv'])
-            output = p.stdout.read()
-
-            pattern = re.compile("TALK_ENV is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == talkenv,
-                            "%r != %r" % (match.group(1), talkenv))
-
-            os.environ['TALK_ENV'] = ''
-
-        def test_ProcessProxyWithThreadFix_env_specified(self):
-            talkenv = 'bar'
-            env = {'TALK_ENV': talkenv}
-
-            p = process.ProcessProxyWithThreadFix(['printenv'], env=env)
-            output = p.stdout.read()
-
-            pattern = re.compile("TALK_ENV is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == talkenv,
-                            "%r != %r" % (match.group(1), talkenv))
-
-        def test_ProcessProxyWithThreadFix_env_overridden(self):
-            os.environ['TALK_ENV'] = 'spam'
-            talkenv = 'eggs'
-            env = {'TALK_ENV': talkenv}
-
-            p = process.ProcessProxyWithThreadFix(['printenv'], env=env)
-            output = p.stdout.read()
-
-            pattern = re.compile("TALK_ENV is '(.*?)'")
-            match = pattern.search(output)
-            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
-                                   "output=%r" % (pattern.pattern, output))
-            self.failUnless(match.group(1) == talkenv,
-                            "%r != %r" % (match.group(1), talkenv))
-
-            self.failUnless(os.environ['TALK_ENV'] == 'spam')
-            os.environ['TALK_ENV'] = ''
-
     def test_ProcessOpen_env_unspecified(self):
         talkenv = ''
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#6 (text) ====

@@ -35,23 +35,6 @@
         retval = p.wait()
         self._assertRetvalIs(-42, retval)
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_0(self):
-            p = process.ProcessProxyWithThreadFix(['quiet'])
-            retval = p.wait()
-            self._assertRetvalIs(0, retval)
-
-        def test_ProcessProxyWithThreadFix_42(self):
-            p = process.ProcessProxyWithThreadFix(['quiet', '42'])
-            retval = p.wait()
-            self._assertRetvalIs(42, retval)
-
-        def test_ProcessProxyWithThreadFix_minus_42(self):
-            p = process.ProcessProxyWithThreadFix(['quiet', '-42'])
-            retval = p.wait()
-            self._assertRetvalIs(-42, retval)
-
     def test_ProcessOpen_0(self):
         p = process.ProcessOpen(['quiet'])
         retval = p.wait()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#13 (text) ====

@@ -192,122 +192,6 @@
                         "Unexpected stdout output: %r" % output)
 
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_stdin_handle_cleanup_1(self):
-            p1 = process.ProcessProxyWithThreadFix(['ask'])
-            p2 = process.ProcessProxyWithThreadFix(['ask'])
-            p1.stdin.write("Trent\n")
-            p2.stdin.write("Andrew\n")
-            p1.stdin.close()
-            p2.stdin.close()
-
-            p1.wait()
-            del p1
-            p2.wait()
-
-            p1 = process.ProcessProxyWithThreadFix(['ask'])
-            p2 = process.ProcessProxyWithThreadFix(['ask'])
-            p1.stdin.write("Mick\n")
-            p1.stdin.close()
-
-            output = p1.stdout.read()
-            expected = "What is your name?\nYour name is 'Mick'.\n"
-            self.failUnless(output == expected,
-                            "Unexpected stdout output: %r" % output)
-            p2.kill()
-
-        def test_ProcessProxyWithThreadFix_stdin_handle_cleanup_2(self):
-            p1 = process.ProcessProxyWithThreadFix(['ask'])
-            p2 = process.ProcessProxyWithThreadFix(['ask'])
-            p1.stdin.write("Trent\n")
-            p2.stdin.write("Andrew\n")
-            p1.stdin.close()
-            p2.stdin.close()
-
-            p1.wait()
-            p2.wait()
-
-            p1 = process.ProcessProxyWithThreadFix(['ask'])
-            p2 = process.ProcessProxyWithThreadFix(['ask'])
-            p1.stdin.write("Mick\n")
-            p1.stdin.close()
-
-            p2.kill()
-
-        def test_ProcessProxyWithThreadFix_stdin_buffer(self):
-            p = process.ProcessProxyWithThreadFix(['ask'])
-            p.stdin.write("Trent\n")
-            p.stdin.close()
-            output = p.stdout.read()
-            expected = "What is your name?\nYour name is 'Trent'.\n"
-            self.failUnless(output == expected,
-                            "Unexpected stdout output: %r" % output)
-
-        def test_ProcessProxyWithThreadFix_stdin_buffer_nonewline(self):
-            p = process.ProcessProxyWithThreadFix(['ask'])
-            p.stdin.write("Tre")
-            # Note that we have not sent a newline, so the scanf() (or
-            # fread() or whatever) in ask.exe is still waiting for input.
-            # This is testing that the subsequent p.stdin.close()
-            # successfully communicates to the child that the pipe is closed
-            # and no more data is forth coming. (This relies on the pipe
-            # inheritability having been properly set.)
-            p.stdin.close()
-            output = p.stdout.read()
-            expected = "What is your name?\nYour name is 'Tre'.\n"
-            self.failUnless(output == expected,
-                            "Unexpected stdout output: %r" % output)
-
-        def test_ProcessProxyWithThreadFix_stdin_donotrespond(self):
-            p = process.ProcessProxyWithThreadFix(['ask_then_talk'],
-                                stdout=MyOutFile(), stderr=MyOutFile())
-            # Expect this to hang, as the child waits for input that we do
-            # not send it.
-            time.sleep(6)
-            # There should be no output, other that
-            output = ''.join([item[2] for item in p.stdout.log])
-            try:
-                self.failUnless(output == "What is your name?\n",
-                    "Stdout has unexpectedly received other than one "\
-                    "'What is your name?' write. The process should "\
-                    "be hung. log=%r" % p.stdout.log)
-            finally:
-                p.kill()
-
-        ## This is left commented out because the use of 'sys.stdin' requires
-        ## user interaction -- not really an automated test suite then.
-        #def test_ProcessProxyWithThreadFix_stdin_sysstdin(self):
-        #    p = process.ProcessProxyWithThreadFix(['ask'], stdin=sys.stdin)
-        #    output = p.stdout.read()
-        #    expected = "What is your name?\nYour name is"
-        #    self.failUnless(output.find(expected) != -1,
-        #                    "Unexpected stdout output: %r" % output)
-
-        def test_ProcessProxyWithThreadFix_stdin_text_mode(self):
-            # On Linux:
-            #   There is no distinction btwn text- and binary-modes. So this
-            #   really is not providing that useful a test.
-            p = process.ProcessProxyWithThreadFix(['sort'])
-            p.stdin.write("2\n")
-            p.stdin.write("1\n")
-            p.stdin.write("3\n")
-            p.stdin.close()
-            output = p.stdout.read()
-            expected = "1\n2\n3\n"
-            self.failUnless(output == expected,
-                            "Unexpected stdout output: %r (expected: %r). "\
-                            "Pipes are not doing text translation."\
-                            % (output, expected))
-
-        def test_ProcessProxyWithThreadFix_stdin_buffering_with_mystdin(self):
-            p = process.ProcessProxyWithThreadFix(['ask'],
-                    stdin=MyInFile("Trent\n"))
-            output = p.stdout.read()
-            expected = "What is your name?\nYour name is 'Trent'.\n"
-            self.failUnless(output == expected,
-                            "Unexpected stdout output: %r" % output)
-
     def test_ProcessOpen_stdin_handle_cleanup_1(self):
         p1 = process.ProcessOpen(['ask'])
         p2 = process.ProcessOpen(['ask'])

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#10 (text) ====

@@ -13,6 +13,7 @@
     def __init__(self):
         self.log = []
     def write(self, text):
+        print "XXX MyOutFile.write('%s')" % text
         self.log.append( (time.time(), 'write', text) )
     def close(self):
         self.log.append( (time.time(), 'close', None) )
@@ -35,8 +36,11 @@
         p = process.ProcessProxy(['talk'], stdout=MyOutFile(),
                                  stderr=MyOutFile())
         p.wait()
-        self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
-        self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
+        p.close()
+        output = p.stdout.getOutput()
+        error = p.stderr.getOutput()
+        self.failUnless(output == 'o0o1o2o3o4')
+        self.failUnless(error == 'e0e1e2e3e4')
 
         #XXX Cannot test this part until the setvbuf work is done to
         #    make the child pipes unbuffered. Update: even with the
@@ -84,50 +88,6 @@
         output = p.stdout.readlines()
         self.failUnless(output == ["hello\n"]*10)
 
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_stdout_buffer(self):
-            p = process.ProcessProxyWithThreadFix(['talk'])
-            output = p.stdout.read()
-            self.failUnless(output == 'o0o1o2o3o4')
-            error = p.stderr.read()
-            self.failUnless(error == 'e0e1e2e3e4')
-
-        def test_ProcessProxyWithThreadFix_my_stdout_with_buffered_child(self):
-            p = process.ProcessProxyWithThreadFix(['talk'], stdout=MyOutFile(),
-                                     stderr=MyOutFile())
-            p.wait()
-            self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
-            self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
-
-            #XXX Cannot test this part until the setvbuf work is done to
-            #    make the child pipes unbuffered. Update: even with the
-            #    setvbuf calls (done via os.fdopen(..., bufsize=0)) stdout
-            #    and stderr do *not* seem to be unbuffered. It *does* make a
-            #    difference for stdin though. Perhaps setvbuf can only be
-            #    used to affect *write* end of pipe, i.e. we cannot affect
-            #    what the child side of stdout/stderr will do. I suspect
-            #    that the only way to get this to work is to get the parent
-            #    side of stdout (and possibly stderr) to look like a tty.
-            #    This might require platform-specific hack, if it is indeed
-            #    possibly at all. How does Cygwin's bash do it? or 4DOS?
-            ## Ensure that the writes came in one about every second.
-
-        def test_ProcessProxyWithThreadFix_my_stdout_with_unbuffered_child(self):
-            p = process.ProcessProxyWithThreadFix(['talk_setvbuf'], stdout=MyOutFile(),
-                                     stderr=MyOutFile())
-            p.wait()
-            self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
-            self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
-
-            # Ensure that the writes are spread over about 5 seconds.
-            writeEvents = [e for e in p.stdout.log if e[1] == 'write']
-            timespan = writeEvents[-1][0] - writeEvents[0][0]
-            epsilon = 1.0
-            self.failUnless(timespan > epsilon,
-                            "Write events were not spread over a few seconds."\
-                            "timespan=%r" % timespan)
-
     def test_ProcessOpen_read_all(self):
         p = process.ProcessOpen(['talk'])
         output = p.stdout.read()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#8 (text) ====

@@ -27,58 +27,22 @@
         after = time.time()
         self.failUnless(4.0 < (after-before) < 10.0)
 
-    if not sys.platform.startswith("linux"):
-        # This is expected to fail on Linux -- hence
-        # ProcessProxyWithThreadFix.
-        def test_ProcessProxy_wait_from_parent_subthread(self):
-            before = time.time()
-            p = process.ProcessProxy(['talk'])
-            try:
-                t = threading.Thread(target=self._WaitAndReturn,
-                                     kwargs={'child':p})
-                t.start()
-                t.join()
-                after = time.time()
-                if self._hitLinuxThreadsBug:
-                    self.fail("Hit known bug in Linux threads: cannot wait "\
-                              "on a process from a different thread from "\
-                              "which it was spawned.")
-                self.failUnless(4.0 < (after-before) < 10.0)
-            finally:
-                p.kill()
-
-    if sys.platform.startswith("linux"):
-        # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_ProcessProxyWithThreadFix_wait(self):
-            before = time.time()
-            p = process.ProcessProxyWithThreadFix(['talk'])
-            p.wait()
+    def test_ProcessProxy_wait_from_parent_subthread(self):
+        before = time.time()
+        p = process.ProcessProxy(['talk'])
+        try:
+            t = threading.Thread(target=self._WaitAndReturn,
+                                 kwargs={'child':p})
+            t.start()
+            t.join()
             after = time.time()
+            if self._hitLinuxThreadsBug:
+                self.fail("Hit known bug in Linux threads: cannot wait "\
+                          "on a process from a different thread from "\
+                          "which it was spawned.")
             self.failUnless(4.0 < (after-before) < 10.0)
-
-        def test_ProcessProxyWithThreadFix_no_wait(self):
-            # This tests whether ProcessProxyWithThreadFix() will cleanup and
-            # terminate worker threads properly. If not, the test suite will
-            # likely hang.
-            before = time.time()
-            p = process.ProcessProxyWithThreadFix(['talk'])
-
-        def test_ProcessProxyWithThreadFix_wait_from_parent_subthread(self):
-            before = time.time()
-            p = process.ProcessProxyWithThreadFix(['talk'])
-            try:
-                t = threading.Thread(target=self._WaitAndReturn,
-                                     kwargs={'child':p})
-                t.start()
-                t.join()
-                after = time.time()
-                if self._hitLinuxThreadsBug:
-                    self.fail("Hit known bug in Linux threads: cannot wait "\
-                              "on a process from a different thread from "\
-                              "which it was spawned.")
-                self.failUnless(4.0 < (after-before) < 10.0)
-            finally:
-                p.kill()
+        finally:
+            p.kill()
 
     def test_ProcessOpen_wait(self):
         before = time.time()
@@ -87,25 +51,22 @@
         after = time.time()
         self.failUnless(4.0 < (after-before) < 10.0)
 
-    if not sys.platform.startswith("linux"):
-        # This is expected to fail on Linux -- hence should write
-        # ProcessOpenWithThreadFix.
-        def test_ProcessOpen_wait_from_parent_subthread(self):
-            before = time.time()
-            p = process.ProcessOpen(['talk'])
-            try:
-                t = threading.Thread(target=self._WaitAndReturn,
-                                     kwargs={'child':p})
-                t.start()
-                t.join()
-                after = time.time()
-                if self._hitLinuxThreadsBug:
-                    self.fail("Hit known bug in Linux threads: cannot wait "\
-                              "on a process from a different thread from "\
-                              "which it was spawned.")
-                self.failUnless(4.0 < (after-before) < 10.0)
-            finally:
-                p.kill()
+    def test_ProcessOpen_wait_from_parent_subthread(self):
+        before = time.time()
+        p = process.ProcessOpen(['talk'])
+        try:
+            t = threading.Thread(target=self._WaitAndReturn,
+                                 kwargs={'child':p})
+            t.start()
+            t.join()
+            after = time.time()
+            if self._hitLinuxThreadsBug:
+                self.fail("Hit known bug in Linux threads: cannot wait "\
+                          "on a process from a different thread from "\
+                          "which it was spawned.")
+            self.failUnless(4.0 < (after-before) < 10.0)
+        finally:
+            p.kill()
 
     def test_Process_wait_multiple_times(self):
         p = process.Process(['log', 'hi'])
@@ -119,13 +80,6 @@
         rv2 = p.wait()
         self.failUnless(rv1 == rv2)
 
-    if sys.platform.startswith("linux"):
-        def test_ProcessProxyWithThreadFix_wait_multiple_times(self):
-            p = process.ProcessProxyWithThreadFix(['echo', 'hi'])
-            rv1 = p.wait()
-            rv2 = p.wait()
-            self.failUnless(rv1 == rv2)
-
     def test_ProcessOpen_wait_multiple_times(self):
         p = process.ProcessOpen(['log', 'hi'])
         rv1 = p.wait()
Change 45432 by trentm@trentm-press on 2002/09/04 10:54:13

	Fix process stuff for Linux (mostly).
	   - By default Process/ProcessOpen/ProcessProxy all have the "WithThreadFix"
	     stuff. This means that there is a thread overhead for each process that
	     we launch on linux, but thems the breaks for a broken kernel.
	
	   Remain issue: lots of output quickly (e.g. 'ls -R') and we can still get
	   hangs. Possibly there is still some synchronization issue in class
	   _ThreadFixer.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#45 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#45 (text) ====

@@ -740,6 +740,8 @@
         # .wait() return error codes
         WAIT_TIMEOUT = 258
         WAIT_FAILED = -1
+        # creation "flags" constants
+        CREATE_NEW_CONSOLE = 0x10 # same as win32process.CREATE_NEW_CONSOLE
 
     def __init__(self, cmd, cwd=None, env=None, flags=0):
         """Create a child process.
@@ -797,6 +799,17 @@
         finally:
             os._exit(1)  # Should never get here.
 
+    def _forkAndExecChildOnUnix(self):
+        """Fork and start the child process.
+
+        Returns the child pid.
+        """
+        pid = os.fork()
+        if pid == 0: # child
+            self._runChildOnUnix()
+        # parent
+        return pid
+
     def _startOnUnix(self):
         if self._cwd:
             oldDir = os.getcwd()
@@ -804,9 +817,7 @@
                 os.chdir(self._cwd)
             except OSError, ex:
                 raise ProcessError(msg=str(ex), errno=ex.errno)
-        self._pid = os.fork()
-        if self._pid == 0: # child
-            self._runChildOnUnix()
+        self._pid = self._forkAndExecChildOnUnix()
 
         # parent
         if self._cwd:
@@ -2129,10 +2140,15 @@
 if sys.platform.startswith("linux"):
     import Queue
 
-    class ProcessProxyWithThreadFix(ProcessProxy):
-        """Present the same semantics as ProcessProxy but try to work around
-        the known LinuxThreads bug where one cannot .wait() on a created
-        process from a subthread of the thread that created the process.
+    class _ThreadFixer:
+        """Mixin class for various classes in the Process hierarchy to
+        work around the known LinuxThreads bug where one cannot .wait()
+        on a created process from a subthread of the thread that created
+        the process.
+
+        Usage:
+            class ProcessXXXWithThreadFix(_ThreadFixer, ProcessXXX):
+                _pclass = ProcessXXX
         """
         def __init__(self, *args, **kwargs):
             # Keep a reference to 'log' ensure it is around for this object's
@@ -2146,7 +2162,7 @@
             self.__terminated = 0
             self.__exitStatus = None
             self.__waiter = None
-            ProcessProxy.__init__(self, *args, **kwargs)
+            self._pclass.__init__(self, *args, **kwargs)
 
         def _forkAndExecChildOnUnix(self, *args, **kwargs):
             """Fork and start the child process do it in a special subthread
@@ -2172,19 +2188,12 @@
             self.__requests.put( ("stop",) )
             if self.__waiter:
                 self.__waiter.join()
-            ProcessProxy.close(self)
+            self._pclass.close(self)
 
-        def __launchAndWait(self, fdChildStdinRd, fdChildStdoutWr,
-                            fdChildStderrWr):
+        def __launchAndWait(self, *args, **kwargs):
             logfix.info("start child in thread %s",
                         threading.currentThread().getName())
-            pid = os.fork()
-            if pid == 0: # child
-                os.dup2(fdChildStdinRd, 0)
-                os.dup2(fdChildStdoutWr, 1)
-                os.dup2(fdChildStderrWr, 2)
-                self._runChildOnUnix()
-            # parent
+            pid = self._pclass._forkAndExecChildOnUnix(self, *args, **kwargs)
 
             # Pass the PID back to the main thread.
             self.__pidReady.acquire()
@@ -2199,7 +2208,7 @@
                 if request[0] == "wait":
                     try:
                         self.__requestResult =\
-                            ProcessProxy.wait(self, timeout=request[1])
+                            self._pclass.wait(self, timeout=request[1])
                         self.__terminated = 1
                         self.__exitStatus = self.__requestResult
                     except Exception, ex:
@@ -2216,7 +2225,7 @@
                     # No need to proxy .wait() and .kill() requests if the
                     # process is done.
                     if self.__exitStatus is None:
-                        self.__exitStatus = ProcessProxy.wait(self, os.WNOHANG)
+                        self.__exitStatus = self._pclass.wait(self, os.WNOHANG)
                     logfix.info("waiter: process terminated, exiting, sts=%s",
                                 self.__exitStatus)
                     break
@@ -2255,3 +2264,16 @@
                 else:
                     return self.__requestResult
 
+    _ThreadBrokenProcess = Process
+    class Process(_ThreadFixer, _ThreadBrokenProcess):
+        _pclass = _ThreadBrokenProcess
+
+    _ThreadBrokenProcessOpen = ProcessOpen
+    class ProcessOpen(_ThreadFixer, _ThreadBrokenProcessOpen):
+        _pclass = _ThreadBrokenProcessOpen
+
+    _ThreadBrokenProcessProxy = ProcessProxy
+    class ProcessProxy(_ThreadFixer, _ThreadBrokenProcessProxy):
+        _pclass = _ThreadBrokenProcessProxy
+
+
Change 45393 by trentm@trentm-press on 2002/09/03 16:27:04

	   Ignore possible OSError when closing a file descriptor (in a _FileWrapper).
	   Is this a good idea?
	
	   Ensure that logger is around and cleaned up properly in
	   ProcessProxyWithThreadFix.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#44 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#44 (text) ====

@@ -683,7 +683,17 @@
                 self._file.close()
                 log.debug("[%s] _FileWrapper.close: done file close", id(self))
             if self._descriptor is not None:
-                os.close(self._descriptor)
+                try:
+                    os.close(self._descriptor)
+                except OSError, ex:
+                    if ex.errno == 9:
+                        # Ignore: OSError: [Errno 9] Bad file descriptor
+                        # XXX *Should* we be ignoring this? It appears very
+                        #     *in*frequently in test_wait.py.
+                        log.debug("[%s] _FileWrapper.close: closing "\
+                                  "descriptor raised OSError", id(self))
+                    else:
+                        raise
             if self._handle is not None:
                 log.debug("[%s] _FileWrapper.close: close handle", id(self))
                 try:
@@ -1018,6 +1028,7 @@
     def __del__(self):
         #XXX Should probably not rely upon this.
         self.close()
+        del self.__log # drop reference
 
     def close(self):
         if not self._closed:
@@ -1050,7 +1061,6 @@
                 # self.stdin, etc.
                 pass
 
-            del self.__log # drop reference
             self._closed = 1
 
     def _forkAndExecChildOnUnix(self, fdChildStdinRd, fdChildStdoutWr,
@@ -1415,6 +1425,7 @@
     def __del__(self):
         #XXX Should probably not rely upon this.
         self.close()
+        del self.__log # drop reference
 
     def close(self):
         if not self._closed:
@@ -1436,7 +1447,7 @@
                 self.stdout.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
-                # self.stdin, etc.
+                # self.stdout, etc.
                 pass
             self.__log.info("[%s] ProcessProxy: closing stderr (%r)."\
                             % (id(self), self.stderr))
@@ -1444,10 +1455,9 @@
                 self.stderr.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
-                # self.stdin, etc.
+                # self.stderr, etc.
                 pass
 
-            del self.__log # drop reference
             self._closed = 1
 
     def _forkAndExecChildOnUnix(self, fdChildStdinRd, fdChildStdoutWr,
@@ -2125,6 +2135,9 @@
         process from a subthread of the thread that created the process.
         """
         def __init__(self, *args, **kwargs):
+            # Keep a reference to 'log' ensure it is around for this object's
+            # destruction.
+            self.__log = log
             self.__pid = None
             self.__pidReady = threading.Condition()
             self.__requestResult = None
Change 45056 by trentm@trentm-planer on 2002/08/28 14:56:02

	Fix bug http://bugs.activestate.com/Komodo/show_bug.cgi?id=20398
	   right-click -> Test Dialog..." pops up a console (must launch pythonw.exe and not python.exe)
	
	   This was due to (1) not spawning pythonw vs python and wperl vs perl on
	   Windows and (2) a bug in a recent change to process.py calling which with
	   incorrect semantics of the 'path' optional argument.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/project/peGUI.js#10 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#43 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#4 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/project/peGUI.js#10 (text) ====

@@ -65,19 +65,27 @@
         this.GuiBuilder.Edit(item.url);
         break;
     case 'cmd_testGUIDialog':
+        var sysUtilsSvc = Components.classes["@activestate.com/koSysUtils;1"].
+                          getService(Components.interfaces.koISysUtils);
+        var infoSvc = Components.classes["@activestate.com/koInfoService;1"].
+                      getService(Components.interfaces.koIInfoService);
         item = gFocusedProjectView.getSelectedPart();
         var startupfile = item.part.getStringAttribute('startup');
         // XXX Move this logic to language services -- that way it will work with
         // other languages when GUIBuilder adds support for new languages
         var language = gLanguageRegistry.suggestLanguageForFile(startupfile)
         var cmd = '';
-        var interp = ''
+        var interp = '';
         switch (language) {
             case 'Perl':
                 interp = globalPrefs.getStringPref("perlDefaultInterpreter");
                 if (interp == '') {
-                    interp = 'perl';
-                    if (koSysUtils.Which(interp) == '') {
+                    if (infoSvc.isWindows) {
+                        interp = 'wperl';
+                    } else {
+                        interp = 'perl';
+                    }
+                    if (sysUtilsSvc.Which(interp) == '') {
                         alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
                         return;
                     }
@@ -88,7 +96,7 @@
                 interp = globalPrefs.getStringPref("wishDefaultInterpreter");
                 if (interp == '') {
                     interp = 'wish';
-                    if (koSysUtils.Which(interp) == '') {
+                    if (sysUtilsSvc.Which(interp) == '') {
                         alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
                         return;
                     }
@@ -98,8 +106,12 @@
             case 'Python':
                 interp = globalPrefs.getStringPref("pythonDefaultInterpreter");
                 if (interp == '') {
-                    interp = 'python';
-                    if (koSysUtils.Which(interp) == '') {
+                    if (infoSvc.isWindows) {
+                        interp = 'pythonw';
+                    } else {
+                        interp = 'python';
+                    }
+                    if (sysUtilsSvc.Which(interp) == '') {
                         alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
                         return;
                     }
@@ -111,8 +123,6 @@
                 return;
         }
         if (cmd) {
-            var koSysUtilsSvc = Components.classes["@activestate.com/koSysUtils;1"].
-                  getService(Components.interfaces.koISysUtils);
             var userEnvSvc = Components.classes["@activestate.com/koUserEnviron;1"].
                   getService(Components.interfaces.koIUserEnviron);
             var env = userEnvSvc.GetEncodedEnvironment();

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#43 (text) ====

@@ -298,7 +298,7 @@
     elif env:
         altpath = _getPathFromEnv(env)
         if altpath:
-            candidates = list(which.which(first, altpath))
+            candidates = list(which.which(first, altpath.split(os.pathsep)))
         else:
             candidates = list(which.which(first))
     else:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#4 (text) ====

@@ -126,7 +126,8 @@
 def which(command, path=None):
     """Generate a list of found apps for the given 'command' on the path.
     
-    An alternate path list may be specified via the "path" argument.
+    "path" (optional) an alternate search path, instead of using the PATH
+        environment variable. This is a list, e.g. ["C:\\TEMP",...].
     """
     matches = []
     if path is None:
Change 45033 by trentm@trentm-planer on 2002/08/28 11:04:53

	Fix a few bugs:
	   - "right-click -> Test Dialog..." on a GUI Builder dialog in a Komodo
	     project did not properly send the user environment to Run_RunCommand. If
	     the dialog language was either Perl or Python this cause the siloed
	     versions of those interpreter to be used which is an error and fails
	     because those interps don't have Tk support. Added a convenience method
	     on koIUserEnviron to help with this.
	   - Sending in the environment to process.py's Process class exposed an error
	     where when process.py deconstructs a command string to ensure that the
	     first arg is a full path to an executable (this is done in two cases (1)
	     spawning processes via Process with*out* the CREATE_NEW_CONSOLE flag and
	     (2) spawning all processes on Win9x) it does not use the passed in
	     environment. Fixed that.
	   - When a specific Perl or Python or Tcl interpreter was specified in user
	     prefs, peGUI.js would improperly try to call koSysUtils.Which() on that
	     string. Calling Which("C:\\Python22\\Python.exe"), for example, is wrong.
	     Moved this .Which() to where it should be called: only if no specific
	     default interpreter is specified.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/project/peGUI.js#9 edit
... //depot/main/Apps/Komodo-devel/src/misc-components/koEnviron.py#4 edit
... //depot/main/Apps/Komodo-devel/src/misc-components/koIEnviron.idl#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#42 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/project/peGUI.js#9 (text) ====

@@ -77,6 +77,10 @@
                 interp = globalPrefs.getStringPref("perlDefaultInterpreter");
                 if (interp == '') {
                     interp = 'perl';
+                    if (koSysUtils.Which(interp) == '') {
+                        alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
+                        return;
+                    }
                 }
                 cmd = interp + ' "' + startupfile +'"';
                 break;
@@ -84,6 +88,10 @@
                 interp = globalPrefs.getStringPref("wishDefaultInterpreter");
                 if (interp == '') {
                     interp = 'wish';
+                    if (koSysUtils.Which(interp) == '') {
+                        alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
+                        return;
+                    }
                 }
                 cmd = interp + ' "' + startupfile +'"';
                 break;
@@ -91,6 +99,10 @@
                 interp = globalPrefs.getStringPref("pythonDefaultInterpreter");
                 if (interp == '') {
                     interp = 'python';
+                    if (koSysUtils.Which(interp) == '') {
+                        alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
+                        return;
+                    }
                 }
                 cmd = interp + ' "' + startupfile +'"';
                 break;
@@ -101,18 +113,17 @@
         if (cmd) {
             var koSysUtilsSvc = Components.classes["@activestate.com/koSysUtils;1"].
                   getService(Components.interfaces.koISysUtils);
-            if (koSysUtils.Which(interp) == '') {
-                alertDialog("Testing this dialog with " + language + " requires that '" + interp + "' be on your PATH or that the " + language + " default interpreter preference be correctly set.");
-            } else {
-                Run_RunCommand(window,
-                               cmd,
-                               null, // cwd
-                               null, // env 
-                               false, // insertOutput
-                               false, // operateOnSelection
-                               true, // doNotOpenOutputWindow
-                               'no-console') //
-            }
+            var userEnvSvc = Components.classes["@activestate.com/koUserEnviron;1"].
+                  getService(Components.interfaces.koIUserEnviron);
+            var env = userEnvSvc.GetEncodedEnvironment();
+            Run_RunCommand(window,
+                           cmd,
+                           null, // cwd
+                           env, // env 
+                           false, // insertOutput
+                           false, // operateOnSelection
+                           true, // doNotOpenOutputWindow
+                           'no-console');
         }
         break;
     case 'cmd_addGUIDialog':
@@ -184,4 +195,4 @@
 {
     part.iconopenstyle['guifile'] = 1
     part.iconstyle['guifile'] = 1
-}+}

==== //depot/main/Apps/Komodo-devel/src/misc-components/koEnviron.py#4 (text) ====

@@ -136,6 +136,10 @@
         return ["%s=%s" % (item[0], item[1])\
             for item in self._startupEnv.items()]
 
+    def GetEncodedEnvironment(self):
+        self._GetStartupEnv()
+        envStrings = self.GetEnvironmentStrings()
+        return '\n'.join(envStrings)
 
 
 class KoEnvironUtils:

==== //depot/main/Apps/Komodo-devel/src/misc-components/koIEnviron.idl#3 (text) ====

@@ -33,6 +33,10 @@
     void GetEnvironmentStrings(
       out PRUint32 count,
       [retval, array, size_is(count)] out string envStrs);
+
+    // Return the user environment as a string encoded as specified by
+    // run_functions.js::Run_RunCommand()'s env argument.
+    wstring GetEncodedEnvironment();
 };
 
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#42 (text) ====

@@ -247,7 +247,27 @@
     return cmdstr
 
 
-def _whichFirstArg(cmd):
+def _getPathFromEnv(env):
+    """Return the PATH environment variable or None.
+
+    Do the right thing for case sensitivity per platform.
+    XXX Icky. This guarantee of proper case sensitivity of environment
+        variables should be done more fundamentally in this module.
+    """
+    if sys.platform.startswith("win"):
+        for key in env.keys():
+            if key.upper() == "PATH":
+                return env[key]
+        else:
+            return None
+    else:
+        if env.has_key("PATH"):
+            return env["PATH"]
+        else:
+            return None
+
+
+def _whichFirstArg(cmd, env=None):
     """Return the given command ensuring that the first arg (the command to
     launch) is a full path to an existing file.
 
@@ -275,6 +295,12 @@
         altpath = [os.path.dirname(first)]
         firstbase = os.path.basename(first)
         candidates = list(which.which(firstbase, path=altpath))
+    elif env:
+        altpath = _getPathFromEnv(env)
+        if altpath:
+            candidates = list(which.which(first, altpath))
+        else:
+            candidates = list(which.which(first))
     else:
         candidates = list(which.which(first))
     if candidates:
@@ -399,7 +425,7 @@
         pass
 
 
-def _fixupCommand(cmd):
+def _fixupCommand(cmd, env=None):
     if sys.platform.startswith("win"):
         # Fixup the command string to spawn.
         # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
@@ -457,7 +483,7 @@
                       % (w9xpopen, comspec, cmd.replace('"', '\\"'))
             else:
                 try:
-                    cmd = _whichFirstArg(cmd)
+                    cmd = _whichFirstArg(cmd, env)
                 except ProcessError:
                     raise ProcessError("Could not find a suitable executable "\
                         "to launch for '%s'. On Win9x you must manually "\
@@ -793,13 +819,13 @@
             # shell to be openned as the command is launched. Therefore need
             # to ensure be have the full path to the executable to launch.
             try:
-                cmd = _whichFirstArg(cmd)
+                cmd = _whichFirstArg(cmd, self._env)
             except ProcessError:
                 # Could not find the command, perhaps it is an internal
                 # shell command -- fallback to _fixupCommand
-                cmd = _fixupCommand(cmd)
+                cmd = _fixupCommand(cmd, self._env)
         else:
-            cmd = _fixupCommand(cmd)
+            cmd = _fixupCommand(cmd, self._env)
         log.debug("cmd = %r", cmd)
 
         # Start the child process.
@@ -1155,7 +1181,7 @@
             si.hStdError = hChildStderrWr
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-            cmd = _fixupCommand(cmd)
+            cmd = _fixupCommand(cmd, self._env)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
             try:
@@ -1569,7 +1595,7 @@
             si.hStdError = hChildStderrWr
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-            cmd = _fixupCommand(cmd)
+            cmd = _fixupCommand(cmd, self._env)
             log.debug("cmd = %r", cmd)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
Change 45017 by trentm@trentm-planer on 2002/08/28 08:37:13

	   Fix bug http://bugs.activestate.com/Komodo/show_bug.cgi?id=20378
	   Error launching VPM: panic
	
	   Solution as decribed in the bug report.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/misc-components/koVPMService.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#41 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/misc-components/koVPMService.py#4 (text) ====

@@ -84,7 +84,7 @@
             installdir = os.path.dirname(os.path.dirname(perlDefaultInterp))
             perlInfo.installationPath = installdir
             if perlInfo.buildNumber >= minBuildNumber:
-                return installdir
+                return os.path.join(installdir, "bin")
             
         # Look on PATH.
         sysUtilsSvc = components.classes["@activestate.com/koSysUtils;1"]\
@@ -94,7 +94,7 @@
             installdir = os.path.dirname(os.path.dirname(perl))
             perlInfo.installationPath = installdir
             if perlInfo.buildNumber >= minBuildNumber:
-                return installdir
+                return os.path.join(installdir, "bin")
         else:
             ex = "Could not find a suitable Perl installation on which to "\
                  "run VPM. VPM currently requires ActivePerl build %d "\

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#41 (text) ====

@@ -301,6 +301,23 @@
         values either be all ASCII or all unicode. Try to remove this burden
         from the user of process.py.
         """
+        isWin9x = win32api.GetVersionEx()[3] == win32con.VER_PLATFORM_WIN32_WINDOWS
+        # On Win9x all keys and values of 'env' must be ASCII (XXX
+        # Actually this is probably only true if the Unicode support
+        # libraries, which are not installed by default, are not
+        # installed). On other Windows flavours all keys and values of
+        # 'env' must all be ASCII *or* all Unicode. We will try to
+        # automatically convert to the appropriate type, issuing a
+        # warning if such an automatic conversion is necessary.
+
+        #XXX Komodo 2.0 Beta 1 hack. This requirement should be
+        #    pushed out to Komodo code using process.py. Or should it?
+        if isWin9x and env:
+            aenv = {}
+            for key, value in env.items():
+                aenv[str(key)] = str(value)
+            env = aenv
+        
         try:
             hProcess, hThread, processId, threadId\
                 = win32process.CreateProcess(appName, cmd, processSA,
@@ -313,15 +330,23 @@
                 #    string to catch this.
                 import warnings
                 warnings.warn('env: ' + str(ex), stacklevel=4)
-                uenv = {}
-                for key, val in env.items():
-                    #XXX Linux may have trouble with all unicode env
-                    #    strings. Perhaps have all ASCII on Linux.
-                    uenv[unicode(key)] = unicode(val)
+                if isWin9x and env:
+                    aenv = {}
+                    try:
+                        for key, value in env.items():
+                            aenv[str(key)] = str(value)
+                    except UnicodeError, ex:
+                        raise ProcessError(str(ex))
+                    env = aenv
+                elif env:
+                    uenv = {}
+                    for key, val in env.items():
+                        uenv[unicode(key)] = unicode(val)
+                    env = uenv
                 hProcess, hThread, processId, threadId\
                     = win32process.CreateProcess(appName, cmd, processSA,
                                                  threadSA, inheritHandles,
-                                                 creationFlags, uenv, cwd,
+                                                 creationFlags, env, cwd,
                                                  si)
             else:
                 raise
Change 44891 by trentm@trentm-planer on 2002/08/26 11:20:00

	Fix bug http://bugs.activestate.com/Komodo/show_bug.cgi?id=20234
	"cvs hangs on long output"
	
	Python code and CVS command that will cause a hang:
	    import process
	    p = process.ProcessOpen("cvs diff", cwd="path/to/some/dir")
	    p.stdout.read() # this will hang
	
	Suspicion:
	    A long cvs process will not terminate until all data is read from the pipe.
	
	Details:
	    On a .stdout.read() (i.e. with no arguments) process.py would first
	    .wait() on the process to wait for it to terminate before reading
	    everything from the pipe. This is not necessary. The semantics of
	    ReadFile on a Win32 handle or os.read() on a file descriptor will
	    ensure that the return value is not empty unless the pipe on the
	    child-side of the process has closed. Removing this unnecessary .wait()
	    clears up the problem.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#40 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#40 (text) ====

@@ -517,7 +517,6 @@
         #   read returning 0, i.e. it shuts down the pipe.
         if self._descriptor is not None:
             if nBytes <= 0:
-                self._process.wait()
                 text, self._lineBuf = self._lineBuf, ""
                 while 1:
                     t = os.read(self._descriptor, 4092)
@@ -537,7 +536,6 @@
             return text
         elif self._handle is not None:
             if nBytes <= 0:
-                self._process.wait()
                 text, self._lineBuf = self._lineBuf, ""
                 while 1:
                     t = self._win32Read(4092)
Change 44878 by trentm@trentm-planer on 2002/08/26 10:33:21

	Fix bug http://bugs.activestate.com/show_bug.cgi?id=20362
	"env must be all string or all unicode" <- error in koAppInfo
	
	process.py's Process* objects require that all environment strings either be
	all ASCII or all unicode (because win32process.CreateProcess has this 
	requirement). Mitigate this burden somewhat by capturing this error condition 
	and trying again with the environment strings all converted to unicode.
	A warning *is* issued via Python's warnings framework to remind the user
	of process.py that one should still do this conversion yourself.
	
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/koprocessutils.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#39 edit
... //depot/main/Apps/Komodo-devel/src/run/koRunService.py#20 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/koprocessutils.py#4 (text) ====

@@ -13,9 +13,11 @@
 
         env = koprocessutils.getUserEnv()
         # make any desired changes to 'env'...
-        #   - Only insert unicode string because: Win32's CreateProcess
+        #   - Only insert unicode strings because: Win32's CreateProcess
         #     requires that all strings in 'env' either be plain strings
-        #     or all unicode strings.
+        #     or all unicode strings and getUserEnv() just converts
+        #     everything to unicode. (XXX This conversion is obselete since
+        #     _SaferCreateProcess in process.py.)
 
         p = process.ProcessOpen(cmd, env=env)
 
@@ -36,6 +38,8 @@
         userEnv = {}
         for piece in userEnvSvc.GetEnvironmentStrings():
             key, val = piece.split('=', 1)
+            #XXX This unicode conversion is not necessary since
+            #    _SaferCreateProcess in process.py.
             userEnv[unicode(key)] = unicode(val)
         _userEnvCache = userEnv
     return _userEnvCache

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#39 (text) ====

@@ -284,6 +284,50 @@
                            "for: %r" % cmd)
 
 
+if sys.platform.startswith("win"):
+    def _SaferCreateProcess(appName,        # app name
+                            cmd,            # command line 
+                            processSA,      # process security attributes 
+                            threadSA,       # thread security attributes 
+                            inheritHandles, # are handles are inherited
+                            creationFlags,  # creation flags 
+                            env,            # environment
+                            cwd,            # current working directory
+                            si):            # STARTUPINFO pointer
+        """If CreateProcess fails from environment type inconsistency then
+        fix that and try again.
+        
+        win32process.CreateProcess requires that all environment keys and
+        values either be all ASCII or all unicode. Try to remove this burden
+        from the user of process.py.
+        """
+        try:
+            hProcess, hThread, processId, threadId\
+                = win32process.CreateProcess(appName, cmd, processSA,
+                                             threadSA, inheritHandles,
+                                             creationFlags, env, cwd, si)
+        except TypeError, ex:
+            if ex.args == ('All dictionary items must be strings, or all must be unicode',):
+                # Try again with an all unicode environment.
+                #XXX Would be nice if didn't have to depend on the error
+                #    string to catch this.
+                import warnings
+                warnings.warn('env: ' + str(ex), stacklevel=4)
+                uenv = {}
+                for key, val in env.items():
+                    #XXX Linux may have trouble with all unicode env
+                    #    strings. Perhaps have all ASCII on Linux.
+                    uenv[unicode(key)] = unicode(val)
+                hProcess, hThread, processId, threadId\
+                    = win32process.CreateProcess(appName, cmd, processSA,
+                                                 threadSA, inheritHandles,
+                                                 creationFlags, uenv, cwd,
+                                                 si)
+            else:
+                raise
+        return hProcess, hThread, processId, threadId
+
+
 # Maintain references to all spawned ProcessProxy objects to avoid hangs.
 #   Otherwise, if the user lets the a ProcessProxy object go out of
 #   scope before the process has terminated, it is possible to get a
@@ -738,7 +782,7 @@
         # Start the child process.
         try:
             self._hProcess, self._hThread, self._processId, self._threadId\
-                = win32process.CreateProcess(
+                = _SaferCreateProcess(
                     None,           # app name
                     cmd,            # command line 
                     None,           # process security attributes 
@@ -1093,7 +1137,7 @@
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
             try:
                 self._hProcess, hThread, self._processId, threadId\
-                    = win32process.CreateProcess(
+                    = _SaferCreateProcess(
                         None,           # app name
                         cmd,            # command line 
                         None,           # process security attributes 
@@ -1508,7 +1552,7 @@
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
             try:
                 self._hProcess, hThread, self._processId, threadId\
-                    = win32process.CreateProcess(
+                    = _SaferCreateProcess(
                         None,           # app name
                         cmd,            # command line 
                         None,           # process security attributes 

==== //depot/main/Apps/Komodo-devel/src/run/koRunService.py#20 (text) ====

@@ -467,6 +467,8 @@
         envDict = self._mergeEnvWithParent(envDict)
         # The process library requires that all env strings be ASCII
         # or all Unicode. We'll just make them all Unicode for now.
+        #XXX This unicode conversion may not be necessary since
+        #    _SaferCreateProcess in process.py.
         uEnvDict = {}
         for key, val in envDict.items():
             #XXX Linux may have trouble with all unicode env
@@ -569,6 +571,8 @@
         envDict = self._mergeEnvWithParent(envDict)
         # The process library requires that all env strings be ASCII
         # or all Unicode. We'll just make them all Unicode for now.
+        #XXX This unicode conversion may not be necessary since
+        #    _SaferCreateProcess in process.py.
         uEnvDict = {}
         for key, val in envDict.items():
             uEnvDict[unicode(key)] = unicode(val)
@@ -670,6 +674,8 @@
         envDict = self._mergeEnvWithParent(envDict)
         # The process library requires that all env strings be ASCII
         # or all Unicode. We'll just make them all Unicode for now.
+        #XXX This unicode conversion may not be necessary since
+        #    _SaferCreateProcess in process.py.
         uEnvDict = {}
         for key, val in envDict.items():
             uEnvDict[unicode(key)] = unicode(val)
@@ -717,6 +723,8 @@
         envDict = self._mergeEnvWithParent(envDict)
         # The process library requires that all env strings be ASCII
         # or all Unicode. We'll just make them all Unicode for now.
+        #XXX This unicode conversion may not be necessary since
+        #    _SaferCreateProcess in process.py.
         uEnvDict = {}
         for key, val in envDict.items():
             uEnvDict[unicode(key)] = unicode(val)
Change 44758 by trentm@trentm-planer on 2002/08/22 13:30:16

	typos in comments

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#38 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#38 (text) ====

@@ -889,7 +889,7 @@
     def __init__(self, cmd, mode='t', cwd=None, env=None):
         """Create a Process with proxy threads for each std handle.
 
-        "cmd" is the command string of argument vector to run.
+        "cmd" is the command string or argument vector to run.
         "mode" (Windows only) specifies whether the pipes used to communicate
             with the child are openned in text, 't', or binary, 'b', mode.
             This is ignored on platforms other than Windows. Default is 't'.
@@ -1268,7 +1268,7 @@
                  stdin=None, stdout=None, stderr=None):
         """Create a Process with proxy threads for each std handle.
 
-        "cmd" is the command string of argument vector to run.
+        "cmd" is the command string or argument vector to run.
         "mode" (Windows only) specifies whether the pipes used to communicate
             with the child are openned in text, 't', or binary, 'b', mode.
             This is ignored on platforms other than Windows. Default is 't'.
Change 44595 by trentm@trentm-artemis-winme on 2002/08/19 17:38:31

	Fix process.py (mostly) for Win9x.
	   - Fix search for w9xpopen.exe.
	   - The Win9x shell is, by default, NOT prefixed to given commands for
	     spawning. This is different than anyother OS. This is done because (for
	     some still unknown reason) command.com screws up console control
	     character signalling to terminate subprocesses of spawned commands. And
	     because we are *always* running the user's command via w9xpopen.exe this
	     was *always* true. Work around: try running the command directly and bail
	     if it is an internal shell command, like "dir".
	   - Send Ctrl-Break to subprocesses *before* falling back to TerminateProcess
	     on .kill(). This is much cleaner because the kill'ed process can clean
	     itself up (and besides it didn't work the other way on Win9x).
	   - Deprecate .kill's exitCode optional argument on Windows. YAGNI. Not
	     cross-platform and not guaranteed to work anyway.
	   - Extend which.py to be able to specify a search path.
	   - Clean up the process.py test suite as appropriate.
	
	   process.py still fails the binary-mode pipe translation tests. This is
	   not considered to be a big deal right now.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#37 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#8 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#9 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#8 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#12 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#2 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#37 (text) ====

@@ -247,6 +247,43 @@
     return cmdstr
 
 
+def _whichFirstArg(cmd):
+    """Return the given command ensuring that the first arg (the command to
+    launch) is a full path to an existing file.
+
+    Raise a ProcessError if no such executable could be found.
+    """
+    # Parse out the first arg.
+    if cmd.startswith('"'):
+        # The .replace() is to ensure it does not mistakenly find the
+        # second '"' in, say (escaped quote):
+        #           "C:\foo\"bar" arg1 arg2
+        idx = cmd.replace('\\"', 'XX').find('"', 1)
+        if idx == -1:
+            raise ProcessError("Malformed command: %r" % cmd)
+        first, rest = cmd[1:idx], cmd[idx+1:]
+        rest = rest.lstrip()
+    else:
+        if ' ' in cmd:
+            first, rest = cmd.split(' ', 1)
+        else:
+            first, rest = cmd, ""
+
+    # Ensure the first arg is a valid path to the appropriate file.
+    import which
+    if os.sep in first:
+        altpath = [os.path.dirname(first)]
+        firstbase = os.path.basename(first)
+        candidates = list(which.which(firstbase, path=altpath))
+    else:
+        candidates = list(which.which(first))
+    if candidates:
+        return _joinArgv( [candidates[0]] ) + ' ' + rest
+    else:
+        raise ProcessError("Could not find an appropriate leading command "\
+                           "for: %r" % cmd)
+
+
 # Maintain references to all spawned ProcessProxy objects to avoid hangs.
 #   Otherwise, if the user lets the a ProcessProxy object go out of
 #   scope before the process has terminated, it is possible to get a
@@ -314,19 +351,50 @@
             # Oh gag, we're on Win9x or using COMMAND.COM. Use the
             # workaround listed in KB: Q150956
             w9xpopen = os.path.join(
-                os.path.basename(win32api.GetModuleFileName(0)),
+                os.path.dirname(win32api.GetModuleFileName(0)),
                 'w9xpopen.exe')
             if not os.path.exists(w9xpopen):
                 # Eeek - file-not-found - possibly an embedding
                 # situation - see if we can locate it in sys.exec_prefix
-                w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
+                w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
                                         'w9xpopen.exe')
                 if not os.path.exists(w9xpopen):
                     raise ProcessError(\
                         "Can not locate 'w9xpopen.exe' which is needed "\
                         "for ProcessOpen to work with your shell or "\
                         "platform.")
-            cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
+            # XXX As for other platforms it would be preferable to launch
+            # the given user command via the std shell. However, on
+            # Win9x spawning via command.com causes problems for .kill()
+            # because command.com seems to eat up Ctrl-C's and
+            # Ctrl-Break's sent via win32api.GenerateConsoleCtrlEvent().
+            # Strangely this only happens when spawn via this Python
+            # interface. For example, Ctrl-C get through to
+            # hang.exe here:
+            #   C:\> ...\w9xpopen.exe "C:\WINDOWS\COMMAND.COM /c hang.exe"
+            #   ^C
+            # but not here:
+            #   >>> p = ProcessOpen('hang.exe')
+            #   # This results in the same command to CreateProcess as
+            #   # above.
+            #   >>> p.kill()
+            # 
+            # The work around is to skip launching via the shell and
+            # error out if this is not expected to work. Cons:
+            #   - cannot spawn shell commands like 'dir' directly
+            #   - cannot spawn batch files
+            if 0:
+                cmd = '%s "%s /c %s"'\
+                      % (w9xpopen, comspec, cmd.replace('"', '\\"'))
+            else:
+                try:
+                    cmd = _whichFirstArg(cmd)
+                except ProcessError:
+                    raise ProcessError("Could not find a suitable executable "\
+                        "to launch for '%s'. On Win9x you must manually "\
+                        "prefix shell commands with 'command.com /c' to "\
+                        "have the shell run them." % cmd)
+                cmd = '%s "%s"' % (w9xpopen, cmd.replace('"', '\\"'))
     return cmd
 
 class _FileWrapper:
@@ -657,30 +725,12 @@
             # We cannot then use _fixupCommand because this will cause a
             # shell to be openned as the command is launched. Therefore need
             # to ensure be have the full path to the executable to launch.
-            if cmd.startswith('"'):
-                # The .replace() is to ensure it does not mistakenly find the
-                # second '"' in, say (escaped quote)
-                #           "C:\foo\"bar" arg1 arg2
-                idx = cmd.replace('\\"', 'XX').find('"', 1)
-                if idx == -1:
-                    raise ProcessError("Malformed command: %r" % cmd)
-                first, rest = cmd[1:idx], cmd[idx+1:]
-                rest = rest.lstrip()
-            else:
-                if ' ' in cmd:
-                    first, rest = cmd.split(' ', 1)
-                else:
-                    first, rest = cmd, ""
-            if not os.sep in first:
-                import which
-                candidates = list(which.which(first))
-                if not candidates:
-                    # Could not find the command, perhaps it is an internal
-                    # shell command -- fallback to _fixupCommand
-                    cmd = _fixupCommand(cmd)
-                else:
-                    first = candidates[0]
-                    cmd = _joinArgv([first]) + ' ' + rest
+            try:
+                cmd = _whichFirstArg(cmd)
+            except ProcessError:
+                # Could not find the command, perhaps it is an internal
+                # shell command -- fallback to _fixupCommand
+                cmd = _fixupCommand(cmd)
         else:
             cmd = _fixupCommand(cmd)
         log.debug("cmd = %r", cmd)
@@ -765,8 +815,8 @@
     def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
         """Kill process.
         
-        "exitCode" (Windows only) is the code the terminated process should
-            exit with.
+        "exitCode" [deprecated, not supported] (Windows only) is the
+            code the terminated process should exit with.
         "gracePeriod" (Windows only) is a number of seconds the process is
             allowed to shutdown with a WM_CLOSE signal before a hard
             terminate is called.
@@ -781,19 +831,9 @@
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
-            retval = 0
-            try:
-                self.wait(gracePeriod)
-            except ProcessError, ex:
-                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
-                win32process.TerminateProcess(self._hProcess, exitCode)
-                win32api.Sleep(100) # wait for resources to be released
-
-            # Last resort, send Ctrl-C to all processes attached to this console.
-            # This is done *after* TerminateProcess because the former
-            # allows one to specify the exit code for the top-level process
-            # in the process group. The subsequent CTRL+Break will then (we
-            # hope) terminate any other remaining processes in the group.
+            # Send Ctrl-Break signal to all processes attached to this
+            # console. This is supposed to trigger shutdown handlers in
+            # each of the processes.
             try:
                 win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
                                                   self._processId)
@@ -806,6 +846,15 @@
                     # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
                     #                     'The parameter is incorrect.')
                     raise
+            
+            # Last resort: call TerminateProcess if it has not yet.
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, -1)
+                win32api.Sleep(100) # wait for resources to be released
 
         else:
             if sig is None:
@@ -1040,7 +1089,6 @@
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
             cmd = _fixupCommand(cmd)
-            log.debug("cmd = %r", cmd)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
             try:
@@ -1134,8 +1182,8 @@
     def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
         """Kill process.
         
-        "exitCode" (Windows only) is the code the terminated process should
-            exit with.
+        "exitCode" [deprecated, not supported] (Windows only) is the
+            code the terminated process should exit with.
         "gracePeriod" (Windows only) is a number of seconds the process is
             allowed to shutdown with a WM_CLOSE signal before a hard
             terminate is called.
@@ -1150,19 +1198,9 @@
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
-            retval = 0
-            try:
-                self.wait(gracePeriod)
-            except ProcessError, ex:
-                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
-                win32process.TerminateProcess(self._hProcess, exitCode)
-                win32api.Sleep(100) # wait for resources to be released
-
-            # Last resort, send Ctrl-C to all processes attached to this console.
-            # This is done *after* TerminateProcess because the former
-            # allows one to specify the exit code for the top-level process
-            # in the process group. The subsequent CTRL+Break will then (we
-            # hope) terminate any other remaining processes in the group.
+            # Send Ctrl-Break signal to all processes attached to this
+            # console. This is supposed to trigger shutdown handlers in
+            # each of the processes.
             try:
                 win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
                                                   self._processId)
@@ -1175,6 +1213,15 @@
                     # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
                     #                     'The parameter is incorrect.')
                     raise
+            
+            # Last resort: call TerminateProcess if it has not yet.
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, -1)
+                win32api.Sleep(100) # wait for resources to be released
 
         else:
             if sig is None:
@@ -1561,8 +1608,8 @@
     def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
         """Kill process.
         
-        "exitCode" (Windows only) is the code the terminated process should
-            exit with.
+        "exitCode" [deprecated, not supported] (Windows only) is the
+            code the terminated process should exit with.
         "gracePeriod" (Windows only) is a number of seconds the process is
             allowed to shutdown with a WM_CLOSE signal before a hard
             terminate is called.
@@ -1577,19 +1624,9 @@
             # Send WM_CLOSE to windows in this process group.
             win32gui.EnumWindows(self._close_, 0)
 
-            retval = 0
-            try:
-                self.wait(gracePeriod)
-            except ProcessError, ex:
-                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
-                win32process.TerminateProcess(self._hProcess, exitCode)
-                win32api.Sleep(100) # wait for resources to be released
-
-            # Last resort, send Ctrl-C to all processes attached to this console.
-            # This is done *after* TerminateProcess because the former
-            # allows one to specify the exit code for the top-level process
-            # in the process group. The subsequent CTRL+Break will then (we
-            # hope) terminate any other remaining processes in the group.
+            # Send Ctrl-Break signal to all processes attached to this
+            # console. This is supposed to trigger shutdown handlers in
+            # each of the processes.
             try:
                 win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
                                                   self._processId)
@@ -1602,6 +1639,15 @@
                     # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
                     #                     'The parameter is incorrect.')
                     raise
+            
+            # Last resort: call TerminateProcess if it has not yet.
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, -1)
+                win32api.Sleep(100) # wait for resources to be released
 
         else:
             if sig is None:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#8 (text) ====

@@ -116,12 +116,20 @@
             self.failUnless(output[1:] == ['hi there\n'])
 
     def test_ProcessProxy_simple_cmd(self):
-        p = process.ProcessProxy('echo hi there')
+        try:
+            p = process.ProcessProxy('echo hi there')
+        except process.ProcessError:
+            # On Win9x the shell is not prefixed.
+            p = process.ProcessProxy('command.com /c echo hi there')
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi there')
 
     def test_ProcessProxy_cmd_with_quotes(self):
-        p = process.ProcessProxy('echo hi "there"')
+        try:
+            p = process.ProcessProxy('echo hi "there"')
+        except process.ProcessError:
+            # On Win9x the shell is not prefixed.
+            p = process.ProcessProxy('command.com /c echo hi "there"')
         output = p.stdout.read()
         if sys.platform.startswith("win"):
             expected = 'hi "there"'
@@ -168,12 +176,20 @@
             self.failUnless(output.strip() == expected)
 
     def test_ProcessOpen_simple_cmd(self):
-        p = process.ProcessOpen('echo hi there')
+        try:
+            p = process.ProcessOpen('echo hi there')
+        except process.ProcessError:
+            # On Win9x the shell is not prefixed.
+            p = process.ProcessOpen('command.com /c echo hi there')
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi there')
 
     def test_ProcessOpen_cmd_with_quotes(self):
-        p = process.ProcessOpen('echo hi "there"')
+        try:
+            p = process.ProcessOpen('echo hi "there"')
+        except process.ProcessError:
+            # On Win9x the shell is not prefixed.
+            p = process.ProcessOpen('command.com /c echo hi "there"')
         output = p.stdout.read()
         if sys.platform.startswith("win"):
             expected = 'hi "there"'

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#9 (text) ====

@@ -34,8 +34,10 @@
         match = pattern.search(output)
         self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
                                "output=%r" % (pattern.pattern, output))
-        self.failUnless(match.group(1) == wd,
-                        "%r != %r" % (match.group(1), wd))
+        actual = os.path.normcase(match.group(1))
+        expected = os.path.normcase(wd)
+        self.failUnless(actual == expected,
+                        "%r != %r" % (actual, expected))
 
     def test_ProcessProxy_cwd_specified_doesnotexist(self):
         wd = "foobar"
@@ -162,8 +164,10 @@
         match = pattern.search(output)
         self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
                                "output=%r" % (pattern.pattern, output))
-        self.failUnless(match.group(1) == wd,
-                        "%r != %r" % (match.group(1), wd))
+        actual = os.path.normcase(match.group(1))
+        expected = os.path.normcase(wd)
+        self.failUnless(actual == expected,
+                        "%r != %r" % (actual, expected))
 
     def test_ProcessOpen_cwd_specified_doesnotexist(self):
         wd = "foobar"

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#6 (text) ====


==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#8 (text) ====

@@ -14,16 +14,24 @@
 
 
 class KillTestCase(unittest.TestCase):
+    def _KillAndReturn(self, child):
+        try:
+            child.kill()
+        except OSError, ex:
+            self._failedToKill = 1
+        else:
+            self._failedToKill = 0
+
     def test_ProcessProxy_kill(self):
         p = process.ProcessProxy(['hang'])
         time.sleep(2)
         p.kill()
         retval = p.wait()
-        if sys.platform.startswith("win"):
-            self.failIf(retval)
-        else:
+        if not sys.platform.startswith("win"):
+            # Can check on Unix if the retval indicates that the process
+            # was signaled. Otherwise the test is just to ensure that we
+            # got here (i.e. didn't hang).
             self.failUnless(os.WIFSIGNALED(retval))
-            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
 
     def test_ProcessProxy_kill_twice(self):
         # Killing an already terminated process should not raise an
@@ -32,21 +40,13 @@
         time.sleep(2)
         p.kill()
         retval = p.wait()
-        if sys.platform.startswith("win"):
-            self.failIf(retval)
-        else:
+        if not sys.platform.startswith("win"):
+            # Can check on Unix if the retval indicates that the process
+            # was signaled. Otherwise the test is just to ensure that we
+            # got here (i.e. didn't hang).
             self.failUnless(os.WIFSIGNALED(retval))
-            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
         p.kill()
 
-    if sys.platform.startswith("win"):
-        def test_ProcessProxy_kill_exitcode(self):
-            p = process.ProcessProxy(['hang'])
-            time.sleep(2)
-            p.kill(42)
-            retval = p.wait()
-            self.failUnless(retval == 42)
-
     if not sys.platform.startswith("win"):
         def test_ProcessProxy_kill_SIGKILL(self):
             p = process.ProcessProxy(['hang'])
@@ -60,14 +60,6 @@
         #     app that would respond to those signals in a measurable way and
         #     then terminate.
 
-    def _KillAndReturn(self, child):
-        try:
-            child.kill()
-        except OSError, ex:
-            self._failedToKill = 1
-        else:
-            self._failedToKill = 0
-
     def test_ProcessProxy_kill_from_parent_subthread(self):
         p = process.ProcessProxy(['hang'])
         t = threading.Thread(target=self._KillAndReturn,
@@ -84,11 +76,11 @@
         time.sleep(2)
         p.kill()
         retval = p.wait()
-        if sys.platform.startswith("win"):
-            self.failIf(retval)
-        else:
+        if not sys.platform.startswith("win"):
+            # Can check on Unix if the retval indicates that the process
+            # was signaled. Otherwise the test is just to ensure that we
+            # got here (i.e. didn't hang).
             self.failUnless(os.WIFSIGNALED(retval))
-            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
 
     def test_ProcessOpen_kill_twice(self):
         # Killing an already terminated process should not raise an
@@ -97,21 +89,13 @@
         time.sleep(2)
         p.kill()
         retval = p.wait()
-        if sys.platform.startswith("win"):
-            self.failIf(retval)
-        else:
+        if not sys.platform.startswith("win"):
+            # Can check on Unix if the retval indicates that the process
+            # was signaled. Otherwise the test is just to ensure that we
+            # got here (i.e. didn't hang).
             self.failUnless(os.WIFSIGNALED(retval))
-            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
         p.kill()
 
-    if sys.platform.startswith("win"):
-        def test_ProcessOpen_kill_exitcode(self):
-            p = process.ProcessOpen(['hang'])
-            time.sleep(2)
-            p.kill(42)
-            retval = p.wait()
-            self.failUnless(retval == 42)
-
     if not sys.platform.startswith("win"):
         def test_ProcessOpen_kill_SIGKILL(self):
             p = process.ProcessOpen(['hang'])
@@ -125,14 +109,6 @@
         #     app that would respond to those signals in a measurable way and
         #     then terminate.
 
-    def _KillAndReturn(self, child):
-        try:
-            child.kill()
-        except OSError, ex:
-            self._failedToKill = 1
-        else:
-            self._failedToKill = 0
-
     def test_ProcessOpen_kill_from_parent_subthread(self):
         p = process.ProcessOpen(['hang'])
         t = threading.Thread(target=self._KillAndReturn,

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#12 (text) ====

@@ -137,10 +137,6 @@
     #                    "Unexpected stdout output: %r" % output)
 
     def test_ProcessProxy_stdin_text_mode(self):
-        # On Windows:
-        #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
-        #   but am currently using it because it reacts measurably
-        #   differently to lines with '\r\n' vs '\n' terminators.)
         # On Linux:
         #   There is no distinction btwn text- and binary-modes. So this
         #   really is not providing that useful a test.
@@ -158,7 +154,6 @@
 
     if sys.platform.startswith("win"):
         def test_ProcessProxy_stdin_binary_mode(self):
-            # Expecting to get cygwin sort here. (XXX Should drop that dep.)
             p = process.ProcessProxy(['sort'], mode='b')
             p.stdin.write("2\n")
             p.stdin.write("1\n")
@@ -290,10 +285,6 @@
         #                    "Unexpected stdout output: %r" % output)
 
         def test_ProcessProxyWithThreadFix_stdin_text_mode(self):
-            # On Windows:
-            #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
-            #   but am currently using it because it reacts measurably
-            #   differently to lines with '\r\n' vs '\n' terminators.)
             # On Linux:
             #   There is no distinction btwn text- and binary-modes. So this
             #   really is not providing that useful a test.
@@ -406,10 +397,6 @@
     #                    "Unexpected stdout output: %r" % output)
 
     def test_ProcessOpen_stdin_text_mode(self):
-        # On Windows:
-        #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
-        #   but am currently using it because it reacts measurably
-        #   differently to lines with '\r\n' vs '\n' terminators.)
         # On Linux:
         #   There is no distinction btwn text- and binary-modes. So this
         #   really is not providing that useful a test.
@@ -427,7 +414,6 @@
 
     if sys.platform.startswith("win"):
         def test_ProcessOpen_stdin_binary_mode(self):
-            # Expecting to get cygwin sort here. (XXX Should drop that dep.)
             p = process.ProcessOpen(['sort'], mode='b')
             p.stdin.write("2\n")
             p.stdin.write("1\n")
@@ -437,7 +423,7 @@
             expected = "???\r\n"
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r (expected: %r). "\
-                            "Pipes are not doing text translation."\
+                            "Binary mode pipes are not working as expected."\
                             % (output, expected))
         
             # Note: reusing 'p' here is subtly testing another aspect of the

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#7 (text) ====

@@ -11,13 +11,6 @@
 
 
 class WaitTestCase(unittest.TestCase):
-    def test_ProcessProxy_wait(self):
-        before = time.time()
-        p = process.ProcessProxy(['talk'])
-        p.wait()
-        after = time.time()
-        self.failUnless(4.0 < (after-before) < 10.0)
-
     def _WaitAndReturn(self, child):
         self._hitLinuxThreadsBug = 0
         try:
@@ -27,6 +20,13 @@
         else:
             self._hitLinuxThreadsBug = 0
 
+    def test_ProcessProxy_wait(self):
+        before = time.time()
+        p = process.ProcessProxy(['talk'])
+        p.wait()
+        after = time.time()
+        self.failUnless(4.0 < (after-before) < 10.0)
+
     if not sys.platform.startswith("linux"):
         # This is expected to fail on Linux -- hence
         # ProcessProxyWithThreadFix.
@@ -114,7 +114,7 @@
         self.failUnless(rv1 == rv2)
 
     def test_ProcessProxy_wait_multiple_times(self):
-        p = process.ProcessProxy(['echo', 'hi'])
+        p = process.ProcessProxy(['log', 'hi'])
         rv1 = p.wait()
         rv2 = p.wait()
         self.failUnless(rv1 == rv2)
@@ -127,7 +127,7 @@
             self.failUnless(rv1 == rv2)
 
     def test_ProcessOpen_wait_multiple_times(self):
-        p = process.ProcessOpen(['echo', 'hi'])
+        p = process.ProcessOpen(['log', 'hi'])
         rv1 = p.wait()
         rv2 = p.wait()
         self.failUnless(rv1 == rv2)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#2 (text) ====

@@ -35,6 +35,10 @@
         -v, --verbose   Print out near misses on stderr. [default]
         -q, --quiet     Do not print out near misses.
 
+        -p <altpath>, --path=<altpath>
+                        An alternative path (list of directories) may
+                        be specified for searching.
+
     Show the full path to the program that would be run for each given
     command name, if any. Which, like GNU's which, returns the number of
     failed arguments, or -1 when no <command-name> was given.
@@ -61,7 +65,7 @@
 
 #---- global data
 
-_version_ = (0, 6, 1)
+_version_ = (0, 7, 0)
 gVerbose = 0
 
 
@@ -116,12 +120,16 @@
         
 #---- module API
 
-def which(command):
-    """Generate a list of found apps for the given 'command' on the path."""
+def which(command, path=None):
+    """Generate a list of found apps for the given 'command' on the path.
+    
+    An alternate path list may be specified via the "path" argument.
+    """
     matches = []
-    path = os.environ.get("PATH", "").split(os.pathsep)
-    if sys.platform.startswith("win"):
-        path.insert(0, os.curdir)  # implied by Windows shell
+    if path is None:
+        path = os.environ.get("PATH", "").split(os.pathsep)
+        if sys.platform.startswith("win"):
+            path.insert(0, os.curdir)  # implied by Windows shell
     # Windows has the concept of a list of extensions (PATHEXT env var).
     exts = []
     if sys.platform.startswith("win"):
@@ -164,12 +172,13 @@
     all = 0
     gVerbose = 1 # be verbose through the cmdln interface, by default.
     try:
-        optlist, args = getopt.getopt(argv[1:], 'haVvq',
-            ['help', 'all', 'version', 'verbose', 'quiet'])
+        optlist, args = getopt.getopt(argv[1:], 'haVvqp:',
+            ['help', 'all', 'version', 'verbose', 'quiet', 'path'])
     except getopt.GetoptError, msg:
         print "which: error: %s. Your invocation was: %s\n" % (msg, argv)
         print __doc__
         return 1
+    altpath = None
     for opt, optarg in optlist:
         if opt in ('-h', '--help'):
             print __doc__
@@ -183,6 +192,8 @@
             gVerbose = 1
         elif opt in ('-q', '--quiet'):
             gVerbose = 0
+        elif opt in ('-p', '--path'):
+            altpath = optarg.split(os.pathsep)
 
     if len(args) == 0:
         return -1
@@ -191,7 +202,7 @@
     for arg in args:
         #print "debug: search for %r" % arg
         npaths = 0
-        for path in which(arg):
+        for path in which(arg, altpath):
             print path
             npaths += 1
             if not all:
Change 43837 by trentm@trentm-planer on 2002/08/02 10:26:58

	Fix my code for parsing out the first argument from a command string and
	then for reconstructing the command string after having run 'which' on the
	first arg. Add a bunch of tests for this new code path.
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#36 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile.linux#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#6 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#36 (text) ====

@@ -659,12 +659,13 @@
             # to ensure be have the full path to the executable to launch.
             if cmd.startswith('"'):
                 # The .replace() is to ensure it does not mistakenly find the
-                # second '"' in, say
+                # second '"' in, say (escaped quote)
                 #           "C:\foo\"bar" arg1 arg2
                 idx = cmd.replace('\\"', 'XX').find('"', 1)
                 if idx == -1:
                     raise ProcessError("Malformed command: %r" % cmd)
-                first, rest = cmd[1, idx], cmd[idx+1:]
+                first, rest = cmd[1:idx], cmd[idx+1:]
+                rest = rest.lstrip()
             else:
                 if ' ' in cmd:
                     first, rest = cmd.split(' ', 1)
@@ -679,7 +680,7 @@
                     cmd = _fixupCommand(cmd)
                 else:
                     first = candidates[0]
-                    cmd = _joinArgv([first]) + rest
+                    cmd = _joinArgv([first]) + ' ' + rest
         else:
             cmd = _fixupCommand(cmd)
         log.debug("cmd = %r", cmd)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#5 (text) ====

@@ -9,8 +9,12 @@
 LDFLAGS=kernel32.lib user32.lib gdi32.lib advapi32.lib shlwapi.lib
 RM=del
 
-talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe ask_setvbuf.exe askw_setvbuf.exe ask_then_talk_setvbuf.exe ask_then_talklots_setvbuf.exe ask_then_talk_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.exe talk_setvbuf.exe talklots_setvbuf.exe talk_flushing_setvbuf.exe talklots_flushing_setvbuf.exe ask_then_talkw_setvbuf.exe ask_then_talklotsw_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe talkw_setvbuf.exe talklotsw_setvbuf.exe talk_flushingw_setvbuf.exe talklots_flushingw_setvbuf.exe quiet_setvbuf.exe quietw_setvbuf.exe hang_setvbuf.exe hangw_setvbuf.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe printenv_setvbuf.exe printenvw_setvbuf.exe hello10.exe
+talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe ask_setvbuf.exe askw_setvbuf.exe ask_then_talk_setvbuf.exe ask_then_talklots_setvbuf.exe ask_then_talk_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.exe talk_setvbuf.exe talklots_setvbuf.exe talk_flushing_setvbuf.exe talklots_flushing_setvbuf.exe ask_then_talkw_setvbuf.exe ask_then_talklotsw_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe talkw_setvbuf.exe talklotsw_setvbuf.exe talk_flushingw_setvbuf.exe talklots_flushingw_setvbuf.exe quiet_setvbuf.exe quietw_setvbuf.exe hang_setvbuf.exe hangw_setvbuf.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe printenv_setvbuf.exe printenvw_setvbuf.exe hello10.exe log.exe "log space.exe"
 
+log.exe "log space.exe": talk.cpp
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DLOG /Folog.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:log.exe log.obj
+    copy /y log.exe "log space.exe"
 
 hello10.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DHELLO10  /Fohello10.obj /c talk.cpp

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile.linux#3 (text) ====

@@ -9,8 +9,13 @@
 LDFLAGS=
 RM=rm -f
 
-talkers: ask ask_then_talk ask_then_talklots ask_then_talk_flushing ask_then_talklots_flushing talk talklots talk_flushing talklots_flushing quiet hang printcwd printenv ask_setvbuf  ask_then_talk_setvbuf ask_then_talklots_setvbuf ask_then_talk_flushing_setvbuf ask_then_talklots_flushing_setvbuf talk_setvbuf talklots_setvbuf talk_flushing_setvbuf talklots_flushing_setvbuf         quiet_setvbuf  hang_setvbuf  printcwd_setvbuf  printenv_setvbuf hello10
+talkers: ask ask_then_talk ask_then_talklots ask_then_talk_flushing ask_then_talklots_flushing talk talklots talk_flushing talklots_flushing quiet hang printcwd printenv ask_setvbuf  ask_then_talk_setvbuf ask_then_talklots_setvbuf ask_then_talk_flushing_setvbuf ask_then_talklots_flushing_setvbuf talk_setvbuf talklots_setvbuf talk_flushing_setvbuf talklots_flushing_setvbuf         quiet_setvbuf  hang_setvbuf  printcwd_setvbuf  printenv_setvbuf hello10 log "log space"
+
 
+log "log space": talk.cpp
+	$(CC) $(CFLAGS)    -DLOG -o log.o -c talk.cpp
+	$(LINK) $(LDFLAGS) -o log log.o
+	cp -f log "log space"
 
 hello10: talk.cpp
 	$(CC) $(CFLAGS)    -DHELLO10  -o hello10.o -c talk.cpp

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#6 (text) ====

@@ -93,6 +93,21 @@
     }
 #endif
 
+#ifdef LOG
+    // Log each argument to its line in log.log.
+    FILE* flog = NULL;
+    if ((flog = fopen("log.log", "w")) == NULL) {
+        exit(1);
+    }
+
+    for (int k = 0; k < argc; ++k) {
+        fprintf(flog, argv[k]);
+        fprintf(flog, "\n");
+    }
+
+    fclose(flog);
+#endif
+
 #ifdef HELLO10
     int i;
     for (i = 0; i < 10; ++i) {

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#6 (text) ====

@@ -12,6 +12,108 @@
 
 
 class CmdTestCase(unittest.TestCase):
+    def test_Process_simple_cmd_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process('log hi there')
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_cmd_with_space_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process('"log space" hi there')
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_cmd_with_spaces_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process('"log space" "hi there"')
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi there\n'])
+
+    def test_Process_simple_argv_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process(['log', 'hi', 'there'])
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_argv_with_space_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process(['log space', 'hi', 'there'])
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_argv_with_spaces_no_console(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        p = process.Process(['log space', 'hi there'])
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi there\n'])
+
+    def test_Process_simple_cmd(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process('log hi there', flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_cmd_with_space(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process('"log space" hi there', flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_cmd_with_spaces(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process('"log space" "hi there"', flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi there\n'])
+
+    def test_Process_simple_argv(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process(['log', 'hi', 'there'], flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_argv_with_space(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process(['log space', 'hi', 'there'], flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi\n', 'there\n'])
+
+    def test_Process_argv_with_spaces(self):
+        logfile = "log.log"
+        if os.path.exists(logfile): os.unlink(logfile)
+        flags = process.Process.CREATE_NEW_CONSOLE
+        p = process.Process(['log space', 'hi there'], flags=flags)
+        p.wait()
+        output = open(logfile, 'r').readlines()
+        self.failUnless(output[1:] == ['hi there\n'])
+
     def test_ProcessProxy_simple_cmd(self):
         p = process.ProcessProxy('echo hi there')
         output = p.stdout.read()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#6 (text) ====

@@ -108,7 +108,7 @@
                 p.kill()
 
     def test_Process_wait_multiple_times(self):
-        p = process.Process(['echo', 'hi'])
+        p = process.Process(['log', 'hi'])
         rv1 = p.wait()
         rv2 = p.wait()
         self.failUnless(rv1 == rv2)
Change 43821 by trentm@trentm-planer on 2002/08/01 18:18:41

	   Fix bug 19977. Need which() to be able to do this. If a "GUI program" is
	   specified we try to find that program and launch it *without* the usual
	   "cmd /c " prefix which will cause a console to pop up. (I wonder why I did
	   not notice the console before.)

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/Conscript#21 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#35 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/which.py#1 add

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/Conscript#21 (text) ====

@@ -34,6 +34,7 @@
 $cons->InstallPythonUtility('koXMLPrefs.py');
 $cons->InstallPythonUtility('process.py');
 $cons->InstallPythonUtility('koprocessutils.py');
+$cons->InstallPythonUtility('which.py');
 
 if ($installerType and $installerType =~ /_withmoz$/) {
     $cons->InstallPythonUtility('pythoncom.py');

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#35 (text) ====

@@ -652,7 +652,37 @@
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
         si.wShowWindow = win32con.SW_SHOWDEFAULT
 
-        cmd = _fixupCommand(cmd)
+        if not (self._flags & self.CREATE_NEW_CONSOLE):
+            #XXX This is hacky.
+            # We cannot then use _fixupCommand because this will cause a
+            # shell to be openned as the command is launched. Therefore need
+            # to ensure be have the full path to the executable to launch.
+            if cmd.startswith('"'):
+                # The .replace() is to ensure it does not mistakenly find the
+                # second '"' in, say
+                #           "C:\foo\"bar" arg1 arg2
+                idx = cmd.replace('\\"', 'XX').find('"', 1)
+                if idx == -1:
+                    raise ProcessError("Malformed command: %r" % cmd)
+                first, rest = cmd[1, idx], cmd[idx+1:]
+            else:
+                if ' ' in cmd:
+                    first, rest = cmd.split(' ', 1)
+                else:
+                    first, rest = cmd, ""
+            if not os.sep in first:
+                import which
+                candidates = list(which.which(first))
+                if not candidates:
+                    # Could not find the command, perhaps it is an internal
+                    # shell command -- fallback to _fixupCommand
+                    cmd = _fixupCommand(cmd)
+                else:
+                    first = candidates[0]
+                    cmd = _joinArgv([first]) + rest
+        else:
+            cmd = _fixupCommand(cmd)
+        log.debug("cmd = %r", cmd)
 
         # Start the child process.
         try:
Change 43754 by trentm@trentm-planer on 2002/07/31 15:35:59

	Typo.
	   r=shanec

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#34 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#34 (text) ====

@@ -565,7 +565,7 @@
         CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
     else:
         # .wait() argument constants
-        INIFINITE = 0
+        INFINITE = 0
         # .wait() return error codes
         WAIT_TIMEOUT = 258
         WAIT_FAILED = -1
Change 43663 by trentm@trentm-planer on 2002/07/30 12:25:59

	Add .readline() and .readlines() method to the .stdout/.stdin/.stderr handles 
	on ProcessOpen and ProcessProxy objects.
	
	r=davida (david will change the GUI builder stuff to use this)

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#33 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile.linux#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#9 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#33 (text) ====

@@ -357,6 +357,8 @@
         self._handle = handle
         self._process = process
         self._closed = 0
+        if self._descriptor is not None or self._handle is not None:
+            self._lineBuf = "" # to support .readline()
 
     def __del__(self):
         self.close()
@@ -404,7 +406,7 @@
         if self._descriptor is not None:
             if nBytes <= 0:
                 self._process.wait()
-                text = ""
+                text, self._lineBuf = self._lineBuf, ""
                 while 1:
                     t = os.read(self._descriptor, 4092)
                     if not t:
@@ -412,12 +414,19 @@
                     else:
                         text += t
             else:
-                text = os.read(self._descriptor, nBytes)
+                if len(self._lineBuf) >= nBytes:
+                    text, self._lineBuf =\
+                        self._lineBuf[:nBytes], self._lineBuf[nBytes:]
+                else:
+                    nBytesToGo = nBytes - len(self._lineBuf)
+                    text = self._lineBuf + os.read(self._descriptor,
+                                                   nBytesToGo)
+                    self._lineBuf = ""
             return text
         elif self._handle is not None:
             if nBytes <= 0:
                 self._process.wait()
-                text = ""
+                text, self._lineBuf = self._lineBuf, ""
                 while 1:
                     t = self._win32Read(4092)
                     if not t:
@@ -425,13 +434,56 @@
                     else:
                         text += t
             else:
-                text = self._win32Read(nBytes)
+                if len(self._lineBuf) >= nBytes:
+                    text, self._lineBuf =\
+                        self._lineBuf[:nBytes], self._lineBuf[nBytes:]
+                else:
+                    nBytesToGo = nBytes - len(self._lineBuf)
+                    text, self._lineBuf =\
+                        self._lineBuf + self._win32Read(nBytesToGo), ""
             return text
         elif self._file is not None:
             return self._file.read(nBytes)
         else:   
             raise "FileHandle.read: no handle to read with"
 
+    def readline(self):
+        if self._descriptor is not None or self._handle is not None:
+            while 1:
+                #XXX This is not portable to the Mac.
+                idx = self._lineBuf.find('\n')
+                if idx != -1:
+                    line, self._lineBuf =\
+                        self._lineBuf[:idx+1], self._lineBuf[idx+1:]
+                    break
+                else:
+                    t = self.read(4092)
+                    if not t:
+                        line, self._lineBuf = self._lineBuf, ""
+                        break
+                    else:
+                        self._lineBuf += t
+            return line
+        elif self._file is not None:
+            return self._file.readline()
+        else:
+            raise "FileHandle.readline: no handle to read with"
+
+    def readlines(self):
+        if self._descriptor is not None or self._handle is not None:
+            lines = []
+            while 1:
+                line = self.readline()
+                if line:
+                    lines.append(line)
+                else:
+                    break
+            return lines
+        elif self._file is not None:
+            return self._file.readlines()
+        else:
+            raise "FileHandle.readline: no handle to read with"
+
     def write(self, text):
         if self._descriptor is not None:
             os.write(self._descriptor, text)
@@ -1705,6 +1757,16 @@
         self._mutex.release()
         return retval
 
+    def readlines(self):
+        lines = []
+        while 1:
+            line = self.readline()
+            if line:
+                lines.append(line)
+            else:
+                break
+        return lines
+
     def _doClose(self):
         pass
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#4 (text) ====

@@ -9,8 +9,12 @@
 LDFLAGS=kernel32.lib user32.lib gdi32.lib advapi32.lib shlwapi.lib
 RM=del
 
-talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe ask_setvbuf.exe askw_setvbuf.exe ask_then_talk_setvbuf.exe ask_then_talklots_setvbuf.exe ask_then_talk_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.exe talk_setvbuf.exe talklots_setvbuf.exe talk_flushing_setvbuf.exe talklots_flushing_setvbuf.exe ask_then_talkw_setvbuf.exe ask_then_talklotsw_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe talkw_setvbuf.exe talklotsw_setvbuf.exe talk_flushingw_setvbuf.exe talklots_flushingw_setvbuf.exe quiet_setvbuf.exe quietw_setvbuf.exe hang_setvbuf.exe hangw_setvbuf.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe printenv_setvbuf.exe printenvw_setvbuf.exe
+talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe ask_setvbuf.exe askw_setvbuf.exe ask_then_talk_setvbuf.exe ask_then_talklots_setvbuf.exe ask_then_talk_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.exe talk_setvbuf.exe talklots_setvbuf.exe talk_flushing_setvbuf.exe talklots_flushing_setvbuf.exe ask_then_talkw_setvbuf.exe ask_then_talklotsw_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe talkw_setvbuf.exe talklotsw_setvbuf.exe talk_flushingw_setvbuf.exe talklots_flushingw_setvbuf.exe quiet_setvbuf.exe quietw_setvbuf.exe hang_setvbuf.exe hangw_setvbuf.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe printenv_setvbuf.exe printenvw_setvbuf.exe hello10.exe
+
 
+hello10.exe: talk.cpp
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DHELLO10  /Fohello10.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:hello10.exe hello10.obj
 
 ask.exe askw.exe ask_setvbuf.exe askw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK  /Foask.obj /c talk.cpp

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile.linux#2 (text) ====

@@ -9,8 +9,12 @@
 LDFLAGS=
 RM=rm -f
 
-talkers: ask ask_then_talk ask_then_talklots ask_then_talk_flushing ask_then_talklots_flushing talk talklots talk_flushing talklots_flushing quiet hang printcwd printenv ask_setvbuf  ask_then_talk_setvbuf ask_then_talklots_setvbuf ask_then_talk_flushing_setvbuf ask_then_talklots_flushing_setvbuf talk_setvbuf talklots_setvbuf talk_flushing_setvbuf talklots_flushing_setvbuf         quiet_setvbuf  hang_setvbuf  printcwd_setvbuf  printenv_setvbuf 
+talkers: ask ask_then_talk ask_then_talklots ask_then_talk_flushing ask_then_talklots_flushing talk talklots talk_flushing talklots_flushing quiet hang printcwd printenv ask_setvbuf  ask_then_talk_setvbuf ask_then_talklots_setvbuf ask_then_talk_flushing_setvbuf ask_then_talklots_flushing_setvbuf talk_setvbuf talklots_setvbuf talk_flushing_setvbuf talklots_flushing_setvbuf         quiet_setvbuf  hang_setvbuf  printcwd_setvbuf  printenv_setvbuf hello10
+
 
+hello10: talk.cpp
+	$(CC) $(CFLAGS)    -DHELLO10  -o hello10.o -c talk.cpp
+	$(LINK) $(LDFLAGS) -o hello10 hello10.o
 
 ask ask_setvbuf : talk.cpp
 	$(CC) $(CFLAGS)    -DASK  -o ask.o -c talk.cpp

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#5 (text) ====

@@ -93,6 +93,13 @@
     }
 #endif
 
+#ifdef HELLO10
+    int i;
+    for (i = 0; i < 10; ++i) {
+    	fprintf(stdout, "hello\n");
+    }
+#endif
+
 #ifdef CWD
     char cwd[1024];
     getcwd(cwd, 1024);

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#9 (text) ====

@@ -73,6 +73,17 @@
         error = p.stderr.read()
         self.failUnless(error == 'e0e1e2e3e4')
 
+    def test_ProcessProxy_readline(self):
+        p = process.ProcessProxy('hello10')
+        for i in range(10):
+            output = p.stdout.readline()
+            self.failUnless(output == "hello\n")
+
+    def test_ProcessProxy_readlines(self):
+        p = process.ProcessProxy('hello10')
+        output = p.stdout.readlines()
+        self.failUnless(output == ["hello\n"]*10)
+
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
         def test_ProcessProxyWithThreadFix_stdout_buffer(self):
@@ -124,6 +135,17 @@
         error = p.stderr.read()
         self.failUnless(error == 'e0e1e2e3e4')
 
+    def test_ProcessOpen_readline(self):
+        p = process.ProcessOpen('hello10')
+        for i in range(10):
+            output = p.stdout.readline()
+            self.failUnless(output == "hello\n")
+
+    def test_ProcessOpen_readlines(self):
+        p = process.ProcessOpen('hello10')
+        output = p.stdout.readlines()
+        self.failUnless(output == ["hello\n"]*10)
+
 
 
 def suite():
Change 43511 by trentm@trentm-razor on 2002/07/23 12:23:26

	   Drop the write-to-scintilla buffering previous done in the command output
	   window. Process.py's switch to I/O on file descriptions and the resultant
	   read semantic change make this no longer necessary.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#32 edit
... //depot/main/Apps/Komodo-devel/src/run/koRunTerminal.py#6 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#32 (text) ====

@@ -1751,13 +1751,7 @@
         log.info("[%s] _InFileProxy: done" % self.getName())
 
     def _proxyFromParentToChild(self):
-        # This is a reasonable buffer size, on Windows at least.
-        # Reducing this number will result in more 'ReadFile' calls.
-        # Reducing it will NOT help to get output more smoothly from the
-        # other end of the pipe (this is true for buffered and
-        # unbuffered I/O situations). (Look at the BUFSIZE comments in
-        # _OutFileProxy. Those may apply here at sometime.)
-        BUFSIZE = 4096
+        CHUNKSIZE = 4096
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
@@ -1773,10 +1767,7 @@
             #     below.
             #log.debug("XXX          -> start read on %r" % self.fParent)
             try:
-                # XXX Used to do .readline() here. Would that make
-                #     better sense in certain circumstances? Should
-                #     BUFSIZE be reduced now for smoother throughput?
-                text = self.fParent.read(BUFSIZE)
+                text = self.fParent.read(CHUNKSIZE)
             except ValueError, ex:
                 # ValueError is raised with trying to write to a closed
                 # file/pipe.
@@ -1865,11 +1856,7 @@
         log.info("[%s] _OutFileProxy: done" % self.getName())
 
     def _proxyFromChildToParent(self):
-        # A larger read chunk size results in undesired buffering of
-        # data for interaction with child. This may be a performance
-        # hit. XXX Perhaps there should be an option to specify the
-        # chunk size here?
-        BUFSIZE = 1
+        CHUNKSIZE = 4096
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
@@ -1877,7 +1864,7 @@
             try:
                 log.info("[%s] _OutFileProxy: waiting for read on child (%r)"\
                          % (self.getName(), self.fChild))
-                text = self.fChild.read(BUFSIZE)
+                text = self.fChild.read(CHUNKSIZE)
             except IOError, ex:
                 # Ignore: IOError: [Errno 9] Bad file descriptor
                 # XXX Do we *know* we want to do that?

==== //depot/main/Apps/Komodo-devel/src/run/koRunTerminal.py#6 (text) ====

@@ -16,9 +16,11 @@
 
 #---- globals
 
-# 1==buffer output to scintilla as an optimization (default)
-# 0==do not do buffering (useful to turn off for debugging)
-_WRITE_BUFFERING = 1
+# 1==buffer output to scintilla as an optimization (old, no longer need
+#    for performance, XXX keep code around for now -- should drop before
+#    final release)
+# 0==do not do buffering (default)
+_WRITE_BUFFERING = 0
 
 
 #---- implementation
Change 43508 by trentm@trentm-swatter on 2002/07/23 12:07:20

	   Change the Process*.wait() semantics on Linux s.t. repeated calls to
	   .wait() will return the ext status of the process. Previously this had the
	   os.waitpid() semantics: subsequent calls raised OSError. This makes the
	   .wait() semantics the same as on Windows and simplifies the
	   _FileWrapper.read() code.
	
	   Note:
	    - The code for this semantic change did not attempt to handle the
	      situation of multiple threads calling .wait() at the same time, because
	      this is moot while Linux threads still has the bug for which
	      ProcessProxyWithThreadFix exists.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#31 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#4 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#31 (text) ====

@@ -403,27 +403,7 @@
         #   read returning 0, i.e. it shuts down the pipe.
         if self._descriptor is not None:
             if nBytes <= 0:
-                try:
-                    # XXX This can cause subtle problems on Unix because
-                    #     subsequent calls to .wait() on the process will
-                    #     raise:
-                    #       OSError: [Errno 10] No child processes
-                    #     Which can be an unexpected side-effect of
-                    #     .stdout.read(). The .wait() semantics on Unix
-                    #     should be changed to allow repeated .wait() calls.
-                    #     The tough case is multiple simultaneous .wait()
-                    #     calls.
-                    self._process.wait()
-                except OSError, ex:
-                    # XXX Skip this on Linux:
-                    #   OSError: [Errno 10] No child processes
-                    # Which can happen for multiple waits. Remove this when
-                    # .wait() semantics on Linux are fixed as suggested
-                    # above.
-                    if not sys.platform.startswith("win") and ex.errno == 10:
-                        pass
-                    else:
-                        raise
+                self._process.wait()
                 text = ""
                 while 1:
                     t = os.read(self._descriptor, 4092)
@@ -532,6 +512,9 @@
         #     win32process.CREATE_* constants on windows.
         CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
     else:
+        # .wait() argument constants
+        INIFINITE = 0
+        # .wait() return error codes
         WAIT_TIMEOUT = 258
         WAIT_FAILED = -1
 
@@ -560,6 +543,7 @@
         if sys.platform.startswith("win"):
             self._startOnWindows()
         else:
+            self.__retvalCache = None
             self._startOnUnix()
 
     def _runChildOnUnix(self):
@@ -673,18 +657,26 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
-            # XXX See _FileWrapper.read() potential problem:
-            #     ...the .wait() semantics on Unix should be changed to allow
-            #     repeated .wait() calls.  The tough case is multiple
-            #     simultaneous .wait() calls.
-            if timeout is None:
-                timeout = 0
-            pid, sts = os.waitpid(self._pid, timeout)
-            if pid == self._pid:
-                retval = sts
+            # os.waitpid() will raise:
+            #       OSError: [Errno 10] No child processes
+            # on subsequent .wait() calls. Change these semantics to have
+            # subsequent .wait() calls return the exit status and return
+            # immediately without raising an exception.
+            # (XXX It would require synchronization code to handle the case
+            # of multiple simultaneous .wait() requests, however we can punt
+            # on that because it is moot while Linux still has the problem
+            # for which Process*WithThreadFix() exists.)
+            if self.__retvalCache is not None:
+                retval = self.__retvalCache
             else:
-                raise ProcessError("Wait for process timed out.",
-                                   self.WAIT_TIMEOUT)
+                if timeout is None:
+                    timeout = 0
+                pid, sts = os.waitpid(self._pid, timeout)
+                if pid == self._pid:
+                    self.__retvalCache = retval = sts
+                else:
+                    raise ProcessError("Wait for process timed out.",
+                                       self.WAIT_TIMEOUT)
         return retval
 
     def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
@@ -793,6 +785,7 @@
         if sys.platform.startswith("win"):
             self._startOnWindows()
         else:
+            self.__retvalCache = None
             self._startOnUnix()
 
         _registerProcess(self)
@@ -1032,18 +1025,26 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
-            # XXX See _FileWrapper.read() potential problem:
-            #     ...the .wait() semantics on Unix should be changed to allow
-            #     repeated .wait() calls.  The tough case is multiple
-            #     simultaneous .wait() calls.
-            if timeout is None:
-                timeout = 0
-            pid, sts = os.waitpid(self._pid, timeout)
-            if pid == self._pid:
-                retval = sts
+            # os.waitpid() will raise:
+            #       OSError: [Errno 10] No child processes
+            # on subsequent .wait() calls. Change these semantics to have
+            # subsequent .wait() calls return the exit status and return
+            # immediately without raising an exception.
+            # (XXX It would require synchronization code to handle the case
+            # of multiple simultaneous .wait() requests, however we can punt
+            # on that because it is moot while Linux still has the problem
+            # for which Process*WithThreadFix() exists.)
+            if self.__retvalCache is not None:
+                retval = self.__retvalCache
             else:
-                raise ProcessError("Wait for process timed out.",
-                                   self.WAIT_TIMEOUT)
+                if timeout is None:
+                    timeout = 0
+                pid, sts = os.waitpid(self._pid, timeout)
+                if pid == self._pid:
+                    self.__retvalCache = retval = sts
+                else:
+                    raise ProcessError("Wait for process timed out.",
+                                       self.WAIT_TIMEOUT)
         _unregisterProcess(self)
         return retval
 
@@ -1183,6 +1184,7 @@
         if sys.platform.startswith("win"):
             self._startOnWindows()
         else:
+            self.__retvalCache = None
             self._startOnUnix()
 
         _registerProcess(self)
@@ -1450,18 +1452,26 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
-            # XXX See _FileWrapper.read() potential problem:
-            #     ...the .wait() semantics on Unix should be changed to allow
-            #     repeated .wait() calls.  The tough case is multiple
-            #     simultaneous .wait() calls.
-            if timeout is None:
-                timeout = 0
-            pid, sts = os.waitpid(self._pid, timeout)
-            if pid == self._pid:
-                retval = sts
+            # os.waitpid() will raise:
+            #       OSError: [Errno 10] No child processes
+            # on subsequent .wait() calls. Change these semantics to have
+            # subsequent .wait() calls return the exit status and return
+            # immediately without raising an exception.
+            # (XXX It would require synchronization code to handle the case
+            # of multiple simultaneous .wait() requests, however we can punt
+            # on that because it is moot while Linux still has the problem
+            # for which Process*WithThreadFix() exists.)
+            if self.__retvalCache is not None:
+                retval = self.__retvalCache
             else:
-                raise ProcessError("Wait for process timed out.",
-                                   self.WAIT_TIMEOUT)
+                if timeout is None:
+                    timeout = 0
+                pid, sts = os.waitpid(self._pid, timeout)
+                if pid == self._pid:
+                    self.__retvalCache = retval = sts
+                else:
+                    raise ProcessError("Wait for process timed out.",
+                                       self.WAIT_TIMEOUT)
         _unregisterProcess(self)
         return retval
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#4 (text) ====

@@ -107,6 +107,32 @@
             finally:
                 p.kill()
 
+    def test_Process_wait_multiple_times(self):
+        p = process.Process(['echo', 'hi'])
+        rv1 = p.wait()
+        rv2 = p.wait(os.WNOHANG)
+        self.failUnless(rv1 == rv2)
+
+    def test_ProcessProxy_wait_multiple_times(self):
+        p = process.ProcessProxy(['echo', 'hi'])
+        rv1 = p.wait()
+        rv2 = p.wait(os.WNOHANG)
+        self.failUnless(rv1 == rv2)
+
+    if sys.platform.startswith("linux"):
+        def test_ProcessProxyWithThreadFix_wait_multiple_times(self):
+            p = process.ProcessProxyWithThreadFix(['echo', 'hi'])
+            rv1 = p.wait()
+            rv2 = p.wait(os.WNOHANG)
+            self.failUnless(rv1 == rv2)
+
+    def test_ProcessOpen_wait_multiple_times(self):
+        p = process.ProcessOpen(['echo', 'hi'])
+        rv1 = p.wait()
+        rv2 = p.wait(os.WNOHANG)
+        self.failUnless(rv1 == rv2)
+        
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
Change 43503 by trentm@trentm-swatter on 2002/07/23 11:31:20

	A number of fixes to get process.py working on Linux:
	   - The _FileWrapper class now closes the given descriptor when its .close()
	     is called.
	   - Escaping args was corrected to properly handle multiple quoted arguments.
	     Getting this to work from the user's p.o.v. will generally require then
	     to pass an argv (rather than a command string) to the Process*
	     constructors. E.g.
	       p = ProcessOpen('"program files/myapp" some args')
	     will not work on Linux but this will:
	       p = ProcessOpen(['program files/myapp', 'some', 'args'])
	   - Minor documentation and comment cleanup.
	   - Change the signature of ProcessOpen.__init__ to have the "mode" arg in
	     the same position (second).
	   - Don't create file-objects from the working file-descriptors. We are doing
	     I/O on the fd's now and don't need the file-objects.
	   - Drop the 'bufsize' argument to ProcessProxy. It is no longer useful.
	     We now favour bufferless I/O.
	   - Fix a race condition in ProcessProxyWithThreadFix.
	   - Correct the test suite for proper usage and expectations on Linux.
	
	   Still todo: .wait() semantic change for Linux to allow multiple .wait()
	   calls without raising OSError on all but one.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#30 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#11 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#8 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#30 (text) ====

@@ -489,6 +489,8 @@
                 log.debug("[%s] _FileWrapper.close: close file", id(self))
                 self._file.close()
                 log.debug("[%s] _FileWrapper.close: done file close", id(self))
+            if self._descriptor is not None:
+                os.close(self._descriptor)
             if self._handle is not None:
                 log.debug("[%s] _FileWrapper.close: close handle", id(self))
                 try:
@@ -568,7 +570,7 @@
         if isinstance(self._cmd, types.StringTypes):
             # This is easier than trying to reproduce shell interpretation to
             # separate the arguments.
-            cmd = ['/bin/sh', '-c', _escapeArg(self._cmd)]
+            cmd = ['/bin/sh', '-c', self._cmd]
         else:
             cmd = self._cmd
 
@@ -651,12 +653,10 @@
             core file was produced."
         In the latter case, use the os.W*() methods to interpret the return
         value.
-
-        XXX Or should returning the exit value be move out to another
-            function as on Win32 process control? If so, then should
-            perhaps not make WaitForSingleObject semantic
-            transformation.
         """
+        # XXX Or should returning the exit value be move out to another
+        #     function as on Win32 process control? If so, then should
+        #     perhaps not make WaitForSingleObject semantic transformation.
         if sys.platform.startswith("win"):
             if timeout is None:
                 timeout = win32event.INFINITE
@@ -673,6 +673,10 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
+            # XXX See _FileWrapper.read() potential problem:
+            #     ...the .wait() semantics on Unix should be changed to allow
+            #     repeated .wait() calls.  The tough case is multiple
+            #     simultaneous .wait() calls.
             if timeout is None:
                 timeout = 0
             pid, sts = os.waitpid(self._pid, timeout)
@@ -752,30 +756,19 @@
 class ProcessOpen(Process):
     """Create a process and setup pipes to it standard handles.
 
-    This is a super popen.
-
-    Limitations:
-        The "mode" argument to optionally specify text-mode translation
-        is NOT implemented. (1) This is only available and meaningful on
-        Windows anyway and (2) it requires that one go through the stdio
-        mechanisms on Windows which has the side-effect of adding
-        unwanted buffering and changing read-semantics such that
-        .read(N) does NOT return if there are some but fewer than N
-        bytes to be read. That is a big price to pay for text
-        translation.
-
-        As well, because C-stdio-level IO is NOT being used, there is no
-        option (nor need?) for setting a "bufsize". XXX *Could* still
-        support this on Unix.
+    This is a super popen3.
     """
     # TODO:
     #   - Share some implementation with Process and ProcessProxy.
     #
 
-    def __init__(self, cmd, cwd=None, env=None, mode='t'):
+    def __init__(self, cmd, mode='t', cwd=None, env=None):
         """Create a Process with proxy threads for each std handle.
 
         "cmd" is the command string of argument vector to run.
+        "mode" (Windows only) specifies whether the pipes used to communicate
+            with the child are openned in text, 't', or binary, 'b', mode.
+            This is ignored on platforms other than Windows. Default is 't'.
         "cwd" optionally specifies the directory in which the child process
             should be started. Default is None, a.k.a. inherits the cwd from
             the parent.
@@ -785,8 +778,8 @@
         """
         # Keep a reference to ensure it is around for this object's destruction.
         self.__log = log
-        log.info("ProcessOpen.__init__(cmd=%r, cwd=%r, env=%r)",
-                 cmd, cwd, env)
+        log.info("ProcessOpen.__init__(cmd=%r, mode=%r, cwd=%r, env=%r)",
+                 cmd, mode, cwd, env)
         self._cmd = cmd
         if not self._cmd:
             raise ProcessError("You must specify a command.")
@@ -814,25 +807,25 @@
 
             # Ensure that all IOBuffer's are closed. If they are not, these
             # can cause hangs. 
-            self.__log.info("[%s] ProcessOpen: closing stdin (%r)."\
-                            % (id(self), self.stdin))
             try:
+                self.__log.info("[%s] ProcessOpen: closing stdin (%r)."\
+                                % (id(self), self.stdin))
                 self.stdin.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stdin, etc.
                 pass
-            self.__log.info("[%s] ProcessOpen: closing stdout (%r)."\
-                            % (id(self), self.stdout))
             try:
+                self.__log.info("[%s] ProcessOpen: closing stdout (%r)."\
+                                % (id(self), self.stdout))
                 self.stdout.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
                 # self.stdin, etc.
                 pass
-            self.__log.info("[%s] ProcessOpen: closing stderr (%r)."\
-                            % (id(self), self.stderr))
             try:
+                self.__log.info("[%s] ProcessOpen: closing stderr (%r)."\
+                                % (id(self), self.stderr))
                 self.stderr.close()
             except AttributeError:
                 # May not have gotten far enough in the __init__ to set
@@ -875,19 +868,16 @@
             os.chdir(oldDir)
 
         os.close(fdChildStdinRd)
-        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w', -1)
         os.close(fdChildStdoutWr)
-        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r', -1)
         os.close(fdChildStderrWr)
-        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', -1)
 
-        self.stdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
+        self.stdin = _FileWrapper(descriptor=fdChildStdinWr, process=self)
         logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
                     id(self), self.stdin)
-        self.stdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+        self.stdout = _FileWrapper(descriptor=fdChildStdoutRd, process=self)
         logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
                     id(self), self.stdout)
-        self.stderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
+        self.stderr = _FileWrapper(descriptor=fdChildStderrRd, process=self)
         logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
                     id(self), self.stderr)
 
@@ -1042,6 +1032,10 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
+            # XXX See _FileWrapper.read() potential problem:
+            #     ...the .wait() semantics on Unix should be changed to allow
+            #     repeated .wait() calls.  The tough case is multiple
+            #     simultaneous .wait() calls.
             if timeout is None:
                 timeout = 0
             pid, sts = os.waitpid(self._pid, timeout)
@@ -1139,7 +1133,7 @@
     #TODO:
     #   - .suspend() and .resume()? See Win32::Process Perl module.
     #
-    def __init__(self, cmd, mode='t', cwd=None, env=None, bufsize=-1,
+    def __init__(self, cmd, mode='t', cwd=None, env=None,
                  stdin=None, stdout=None, stderr=None):
         """Create a Process with proxy threads for each std handle.
 
@@ -1153,9 +1147,6 @@
         "env" is optionally a mapping specifying the environment in which to
             start the child. Default is None, a.k.a. inherits the environment
             of the parent.
-        "bufsize" is used to specify the bufsize for std handles used to
-            communicate with the child. This is specified via os.fdopen(...,
-            bufsize). See os.fdopen() for more information. Default is -1.
         "stdin", "stdout", "stderr" can be used to specify an objects with
             file-like interfaces to handle read (stdout/stderr) and write
             (stdin) events from the child. By default a process.IOBuffer
@@ -1165,8 +1156,8 @@
         # Keep a reference to ensure it is around for this object's destruction.
         self.__log = log
         log.info("ProcessProxy.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
-                 "bufsize=%r, stdin=%r, stdout=%r, stderr=%r)",
-                 cmd, mode, cwd, env, bufsize, stdin, stdout, stderr)
+                 "stdin=%r, stdout=%r, stderr=%r)",
+                 cmd, mode, cwd, env, stdin, stdout, stderr)
         self._cmd = cmd
         if not self._cmd:
             raise ProcessError("You must specify a command.")
@@ -1175,7 +1166,6 @@
             raise ProcessError("'mode' must be 't' or 'b'.")
         self._cwd = cwd
         self._env = env
-        self._bufsize = bufsize
         if stdin is None:
             self.stdin = IOBuffer(name='<stdin>')
         else:
@@ -1268,19 +1258,16 @@
             os.chdir(oldDir)
 
         os.close(fdChildStdinRd)
-        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w', self._bufsize)
         os.close(fdChildStdoutWr)
-        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r', self._bufsize)
         os.close(fdChildStderrWr)
-        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', self._bufsize)
 
-        childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
+        childStdin = _FileWrapper(descriptor=fdChildStdinWr, process=self)
         logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                     id(self), childStdin)
-        childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+        childStdout = _FileWrapper(descriptor=fdChildStdoutRd, process=self)
         logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                     id(self), childStdout)
-        childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
+        childStderr = _FileWrapper(descriptor=fdChildStderrRd, process=self)
         logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                     id(self), childStderr)
 
@@ -1443,12 +1430,10 @@
             core file was produced."
         In the latter case, use the os.W*() methods to interpret the return
         value.
-
-        XXX Or should returning the exit value be move out to another
-            function as on Win32 process control? If so, then should
-            perhaps not make WaitForSingleObject semantic
-            transformation.
         """
+        # XXX Or should returning the exit value be move out to another
+        #     function as on Win32 process control? If so, then should
+        #     perhaps not make WaitForSingleObject semantic transformation.
         if sys.platform.startswith("win"):
             if timeout is None:
                 timeout = win32event.INFINITE
@@ -1465,6 +1450,10 @@
 
             retval = win32process.GetExitCodeProcess(self._hProcess)
         else:
+            # XXX See _FileWrapper.read() potential problem:
+            #     ...the .wait() semantics on Unix should be changed to allow
+            #     repeated .wait() calls.  The tough case is multiple
+            #     simultaneous .wait() calls.
             if timeout is None:
                 timeout = 0
             pid, sts = os.waitpid(self._pid, timeout)
@@ -1930,7 +1919,8 @@
             # be launched then return the child's pid.
             self.__waiter.start()
             self.__pidReady.acquire()
-            self.__pidReady.wait()  #XXX What if .notify() happens first?
+            if self.__pid is None:
+                self.__pidReady.wait()
             self.__pidReady.release()
             return self.__pid
 
@@ -1955,8 +1945,8 @@
             # parent
 
             # Pass the PID back to the main thread.
+            self.__pidReady.acquire()
             self.__pid = pid
-            self.__pidReady.acquire()
             self.__pidReady.notifyAll()
             self.__pidReady.release()
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#5 (text) ====

@@ -20,7 +20,11 @@
     def test_ProcessProxy_cmd_with_quotes(self):
         p = process.ProcessProxy('echo hi "there"')
         output = p.stdout.read()
-        self.failUnless(output.strip() == 'hi "there"')
+        if sys.platform.startswith("win"):
+            expected = 'hi "there"'
+        else:
+            expected = 'hi there'
+        self.failUnless(output.strip() == expected)
 
     def test_ProcessProxy_cmd_with_multiples_quoted_args(self):
         dname = "program files"
@@ -54,7 +58,11 @@
         def test_ProcessProxyWithThreadFix_cmd_with_quotes(self):
             p = process.ProcessProxyWithThreadFix('echo hi "there"')
             output = p.stdout.read()
-            self.failUnless(output.strip() == 'hi "there"')
+            if sys.platform.startswith("win"):
+                expected = 'hi "there"'
+            else:
+                expected = 'hi there'
+            self.failUnless(output.strip() == expected)
 
     def test_ProcessOpen_simple_cmd(self):
         p = process.ProcessOpen('echo hi there')
@@ -64,7 +72,11 @@
     def test_ProcessOpen_cmd_with_quotes(self):
         p = process.ProcessOpen('echo hi "there"')
         output = p.stdout.read()
-        self.failUnless(output.strip() == 'hi "there"')
+        if sys.platform.startswith("win"):
+            expected = 'hi "there"'
+        else:
+            expected = 'hi there'
+        self.failUnless(output.strip() == expected)
 
     def test_ProcessOpen_cmd_with_multiples_quoted_args(self):
         dname = "program files"

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#11 (text) ====

@@ -190,8 +190,7 @@
                             % (output, expected))
 
     def test_ProcessProxy_stdin_buffering_with_mystdin(self):
-        p = process.ProcessProxy(['ask'], stdin=MyInFile("Trent\n"),
-                                 bufsize=0)
+        p = process.ProcessProxy(['ask'], stdin=MyInFile("Trent\n"))
         output = p.stdout.read()
         expected = "What is your name?\nYour name is 'Trent'.\n"
         self.failUnless(output == expected,
@@ -311,8 +310,8 @@
                             % (output, expected))
 
         def test_ProcessProxyWithThreadFix_stdin_buffering_with_mystdin(self):
-            p = process.ProcessProxyWithThreadFix(['ask'], stdin=MyInFile("Trent\n"),
-                                     bufsize=0)
+            p = process.ProcessProxyWithThreadFix(['ask'],
+                    stdin=MyInFile("Trent\n"))
             output = p.stdout.read()
             expected = "What is your name?\nYour name is 'Trent'.\n"
             self.failUnless(output == expected,
@@ -362,6 +361,7 @@
     def test_ProcessOpen_stdin_buffer(self):
         p = process.ProcessOpen(['ask'])
         p.stdin.write("Trent\n")
+        p.stdin.close()
         output = p.stdout.read()
         expected = "What is your name?\nYour name is 'Trent'.\n"
         self.failUnless(output == expected,

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#8 (text) ====

@@ -66,6 +66,13 @@
                         "Write events were not spread over a few seconds."\
                         "timespan=%r" % timespan)
 
+    def test_ProcessProxy_read_all(self):
+        p = process.ProcessProxy(['talk'])
+        output = p.stdout.read()
+        self.failUnless(output == 'o0o1o2o3o4')
+        error = p.stderr.read()
+        self.failUnless(error == 'e0e1e2e3e4')
+
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
         def test_ProcessProxyWithThreadFix_stdout_buffer(self):
Change 43501 by trentm@trentm-razor on 2002/07/23 10:57:01

	   Std handle reading/writing in the _FileWrapper is now done via the file
	   descriptor. This provides the read semantics that we want (don't block if
	   there is anything to return) AND provides text-mode translation on Windows.
	   I don't know why I ignored r/w on the fd before. So now ProcessOpen
	   supports the "mode" argument (defaulting to text-mode translation on
	   Windows) and ProcessProxy should have the "better" read semantics, though I
	   have not tested that.
	
	   Some cleanup on Linux remains.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#29 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#10 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#29 (text) ====

@@ -333,11 +333,20 @@
     """Wrap a system file object, hiding some nitpicky details.
     
     This class provides a Python file-like interface to either a Python
-    file object (pretty easy job) or an OS-specific file handle (e.g.
-    Win32 handles to file objects on Windows).
+    file object (pretty easy job), a file descriptor, or an OS-specific
+    file handle (e.g.  Win32 handles to file objects on Windows). Any or
+    all of these object types may be passed to this wrapper. If more
+    than one is specified this wrapper prefers to work with certain one
+    in this order:
+        - file descriptor (because usually this allows for
+          return-immediately-on-read-if-anything-available semantics and
+          also provides text mode translation on Windows)
+        - OS-specific handle (allows for the above read semantics)
+        - file object (buffering can cause difficulty for interacting
+          with spawned programs)
 
-    It also provides a place where related such object can be kept alive
-    together to prevent premature ref-counted collection. (E.g. on
+    It also provides a place where related such objects can be kept
+    alive together to prevent premature ref-counted collection. (E.g. on
     Windows a Python file object may be associated with a Win32 file
     handle. If the file handle is not kept alive the Python file object
     will cease to function.)
@@ -387,15 +396,46 @@
         return text
 
     def read(self, nBytes=-1):
-        if self._file is not None:
-            return self._file.read(nBytes)
+        # nBytes <= 0 means "read everything"
+        #   Note that we are changing the "read everything" cue to
+        #   include 0, because actually doing
+        #   win32file.ReadFile(<handle>, 0) results in every subsequent
+        #   read returning 0, i.e. it shuts down the pipe.
+        if self._descriptor is not None:
+            if nBytes <= 0:
+                try:
+                    # XXX This can cause subtle problems on Unix because
+                    #     subsequent calls to .wait() on the process will
+                    #     raise:
+                    #       OSError: [Errno 10] No child processes
+                    #     Which can be an unexpected side-effect of
+                    #     .stdout.read(). The .wait() semantics on Unix
+                    #     should be changed to allow repeated .wait() calls.
+                    #     The tough case is multiple simultaneous .wait()
+                    #     calls.
+                    self._process.wait()
+                except OSError, ex:
+                    # XXX Skip this on Linux:
+                    #   OSError: [Errno 10] No child processes
+                    # Which can happen for multiple waits. Remove this when
+                    # .wait() semantics on Linux are fixed as suggested
+                    # above.
+                    if not sys.platform.startswith("win") and ex.errno == 10:
+                        pass
+                    else:
+                        raise
+                text = ""
+                while 1:
+                    t = os.read(self._descriptor, 4092)
+                    if not t:
+                        break
+                    else:
+                        text += t
+            else:
+                text = os.read(self._descriptor, nBytes)
+            return text
         elif self._handle is not None:
             if nBytes <= 0:
-                # Read everything. Note that we are changing the "read
-                # everything" cue to include 0, because actually doing
-                # win32file.ReadFile(<handle>, 0) results in every
-                # subsequent read returning 0, i.e. is shuts down the
-                # pipe.
                 self._process.wait()
                 text = ""
                 while 1:
@@ -407,12 +447,14 @@
             else:
                 text = self._win32Read(nBytes)
             return text
+        elif self._file is not None:
+            return self._file.read(nBytes)
         else:   
             raise "FileHandle.read: no handle to read with"
 
     def write(self, text):
-        if self._file is not None:
-            return self._file.write(text)
+        if self._descriptor is not None:
+            os.write(self._descriptor, text)
         elif self._handle is not None:
             try:
                 errCode, nBytesWritten = win32file.WriteFile(self._handle, text)
@@ -433,6 +475,8 @@
             else:
                 log.info("[%s] _FileWrapper.write: wrote %d bytes to pipe: %r",
                          id(self), len(text), text)
+        elif self._file is not None:
+            self._file.write(text)
         else:   
             raise "FileHandle.write: nothing to write with"
 
@@ -728,7 +772,7 @@
     #   - Share some implementation with Process and ProcessProxy.
     #
 
-    def __init__(self, cmd, cwd=None, env=None):
+    def __init__(self, cmd, cwd=None, env=None, mode='t'):
         """Create a Process with proxy threads for each std handle.
 
         "cmd" is the command string of argument vector to run.
@@ -748,6 +792,9 @@
             raise ProcessError("You must specify a command.")
         self._cwd = cwd
         self._env = env
+        self._mode = mode
+        if self._mode not in ('t', 'b'):
+            raise ProcessError("'mode' must be 't' or 'b'.")
         self._closed = 0
 
         if sys.platform.startswith("win"):
@@ -892,14 +939,27 @@
             win32api.CloseHandle(hChildStderrRd)
             self._hChildStderrRd = hChildStderrRdDup
 
-            self.stdin = _FileWrapper(handle=self._hChildStdinWr, process=self)
+            # Set the translation mode and buffering.
+            if self._mode == 't':
+                flags = os.O_TEXT
+            else:
+                flags = 0
+            fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
+            fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
+            fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
+
+            self.stdin = _FileWrapper(descriptor=fdChildStdinWr,
+                                      handle=self._hChildStdinWr,
+                                      process=self)
             logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
                         id(self), self.stdin)
-            self.stdout = _FileWrapper(handle=self._hChildStdoutRd,
+            self.stdout = _FileWrapper(descriptor=fdChildStdoutRd,
+                                       handle=self._hChildStdoutRd,
                                        process=self)
             logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
                         id(self), self.stdout)
-            self.stderr = _FileWrapper(handle=self._hChildStderrRd,
+            self.stderr = _FileWrapper(descriptor=fdChildStderrRd,
+                                       handle=self._hChildStderrRd,
                                        process=self)
             logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
                         id(self), self.stderr)
@@ -1287,15 +1347,7 @@
             win32api.CloseHandle(hChildStderrRd)
             self._hChildStderrRd = hChildStderrRdDup
 
-            # Set the translation mode and buffering.
-            # Note that setting the bufsize of the *read* end of pipes does
-            # not seem to affect buffering for that pipe (and perhaps it
-            # should not). This means that bufsize=0 will *not* cause stdout
-            # and stderr from the child to come in smoothly. Apparently it
-            # is up to the child end to set the handlers to be unbuffered.
-            # XXX Idea, set the current handlers to be unbuffered, then get
-            #     child to inherit *those* handles, then set the parent's
-            #     handlers back. Could that work?
+            # Set the translation mode.
             if self._mode == 't':
                 flags = os.O_TEXT
                 mode = ''
@@ -1303,22 +1355,22 @@
                 flags = 0
                 mode = 'b'
             fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
-            fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
             fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
-            fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
             fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
-            fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
 
-            childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr,
-                                     self._hChildStdinWr)
+            childStdin = _FileWrapper(descriptor=fdChildStdinWr,
+                                      handle=self._hChildStdinWr,
+                                      process=self)
             logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                         id(self), childStdin)
-            childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd,
-                                      self._hChildStdoutRd)
+            childStdout = _FileWrapper(descriptor=fdChildStdoutRd,
+                                       handle=self._hChildStdoutRd,
+                                       process=self)
             logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                         id(self), childStdout)
-            childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd,
-                                      self._hChildStderrRd)
+            childStderr = _FileWrapper(descriptor=fdChildStderrRd,
+                                       handle=self._hChildStderrRd,
+                                       process=self)
             logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                         id(self), childStderr)
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#10 (text) ====

@@ -336,11 +336,7 @@
         p1.stdin.close()
 
         output = p1.stdout.read()
-        if sys.platform.startswith("win"):
-            newl = '\r\n'
-        else:
-            newl = '\n'
-        expected = "What is your name?%sYour name is 'Mick'.%s" % (newl, newl)
+        expected = "What is your name?\nYour name is 'Mick'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
         p2.kill()
@@ -367,11 +363,7 @@
         p = process.ProcessOpen(['ask'])
         p.stdin.write("Trent\n")
         output = p.stdout.read()
-        if sys.platform.startswith("win"):
-            newl = '\r\n'
-        else:
-            newl = '\n'
-        expected = "What is your name?%sYour name is 'Trent'.%s" % (newl, newl)
+        expected = "What is your name?\nYour name is 'Trent'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
@@ -386,11 +378,7 @@
         # inheritability having been properly set.)
         p.stdin.close()
         output = p.stdout.read()
-        if sys.platform.startswith("win"):
-            newl = '\r\n'
-        else:
-            newl = '\n'
-        expected = "What is your name?%sYour name is 'Tre'.%s" % (newl, newl)
+        expected = "What is your name?\nYour name is 'Tre'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
@@ -437,6 +425,39 @@
                         "Pipes are not doing text translation."\
                         % (output, expected))
 
+    if sys.platform.startswith("win"):
+        def test_ProcessOpen_stdin_binary_mode(self):
+            # Expecting to get cygwin sort here. (XXX Should drop that dep.)
+            p = process.ProcessOpen(['sort'], mode='b')
+            p.stdin.write("2\n")
+            p.stdin.write("1\n")
+            p.stdin.write("3\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "???\r\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r (expected: %r). "\
+                            "Pipes are not doing text translation."\
+                            % (output, expected))
+        
+            # Note: reusing 'p' here is subtly testing another aspect of the
+            #       ProcessOpen stuff. If self._hChildStdinWr (and the
+            #       stdout/stderr equivs) are not handled in ProcessOpen.__del__
+            #       then a win32api error on CloseHandle is raised when the
+            #       C runtime closes these handles asynchronously.
+
+            p = process.ProcessOpen(['sort'], mode='b')
+            p.stdin.write("2\r\n")
+            p.stdin.write("1\r\n")
+            p.stdin.write("3\r\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "1\r\n2\r\n3\r\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r (expected: %r). "\
+                            "Pipes are not doing text translation."\
+                            % (output, expected))
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
Change 43423 by trentm@trentm-pliers on 2002/07/19 15:22:24

	Finish writing ProcessOpen for linux.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#28 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#28 (text) ====

@@ -1,5 +1,5 @@
 
-"""
+r"""
     Python interface for process control.
 
     This module defines three Process classes for spawning,
@@ -834,30 +834,15 @@
         os.close(fdChildStderrWr)
         fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', -1)
 
-        childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
+        self.stdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
         logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
-                    id(self), childStdin)
-        childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+                    id(self), self.stdin)
+        self.stdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
         logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
-                    id(self), childStdout)
-        childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
+                    id(self), self.stdout)
+        self.stderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
         logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
-                    id(self), childStderr)
-
-        # Create proxy threads for the out pipes.
-        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
-        stdinProxy.start()
-        # Clean up the parent's side of <stdin> when it is observed that
-        # the child has closed its side of <stdout>. (This is one way of
-        # determining when it is appropriate to clean up this pipe, with
-        # compromises. See the discussion at the top of this module.)
-        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
-                                   [self.stdin, childStdin, self],
-                                   name='<stdout>')
-        stdoutProxy.start()
-        stderrProxy = _OutFileProxy(childStderr, self.stderr,
-                                   name='<stderr>')
-        stderrProxy.start()
+                    id(self), self.stderr)
 
     def _startOnWindows(self):
         if type(self._cmd) in (types.ListType, types.TupleType):
Change 43416 by trentm@trentm-razor on 2002/07/19 13:17:03

	   Allow "start ...", for example, to work for the "no-console" run command
	   option. "no-console" uses process.Process() which was the only one of the
	   Process* classes that was not prefixing cmd strings with "cmd /c".
	   r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#27 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#27 (text) ====

@@ -570,8 +570,7 @@
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
         si.wShowWindow = win32con.SW_SHOWDEFAULT
 
-        #XXX Should I "fixup" the command, i.e. prefix "cmd.exe /c".
-        #    Otherwise cmd="start ...", and the like, will not work.
+        cmd = _fixupCommand(cmd)
 
         # Start the child process.
         try:
Change 43353 by trentm@trentm-razor on 2002/07/18 15:55:46

	ProcessOpen and ProcessProxy would not launch a program successfully if the
	cmd string had two quoted arguments and one of them is the first arg (i.e.
	the executable to launch) and the path to that executable has a space in
	it. This is because I prefix "cmd.exe /c" to command strings and was not
	properly handling the full glory of cmd's quote processing (see "cmd /?").

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#26 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#4 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#26 (text) ====

@@ -293,6 +293,42 @@
         pass
 
 
+def _fixupCommand(cmd):
+    if sys.platform.startswith("win"):
+        # Fixup the command string to spawn.
+        # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
+        comspec = os.environ.get("COMSPEC", None)
+        if comspec is None:
+            raise ProcessError("Cannot locate a COMSPEC environment "\
+                               "variable to use as the shell")
+        # Explicitly check if we are using COMMAND.COM.  If we
+        # are then use the w9xpopen hack.
+        elif win32api.GetVersion() < 0x80000000L and\
+             os.path.basename(comspec).lower() != "command.com":
+            # NT/2000 and not using command.com.
+            if '"' in cmd or "'" in cmd:
+                cmd = comspec + ' /c "%s"' % cmd
+            else:
+                cmd = comspec + ' /c ' + cmd
+        else:
+            # Oh gag, we're on Win9x or using COMMAND.COM. Use the
+            # workaround listed in KB: Q150956
+            w9xpopen = os.path.join(
+                os.path.basename(win32api.GetModuleFileName(0)),
+                'w9xpopen.exe')
+            if not os.path.exists(w9xpopen):
+                # Eeek - file-not-found - possibly an embedding
+                # situation - see if we can locate it in sys.exec_prefix
+                w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
+                                        'w9xpopen.exe')
+                if not os.path.exists(w9xpopen):
+                    raise ProcessError(\
+                        "Can not locate 'w9xpopen.exe' which is needed "\
+                        "for ProcessOpen to work with your shell or "\
+                        "platform.")
+            cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
+    return cmd
+
 class _FileWrapper:
     """Wrap a system file object, hiding some nitpicky details.
     
@@ -534,6 +570,9 @@
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
         si.wShowWindow = win32con.SW_SHOWDEFAULT
 
+        #XXX Should I "fixup" the command, i.e. prefix "cmd.exe /c".
+        #    Otherwise cmd="start ...", and the like, will not work.
+
         # Start the child process.
         try:
             self._hProcess, self._hThread, self._processId, self._threadId\
@@ -890,35 +929,7 @@
             si.hStdError = hChildStderrWr
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-            # Fixup the command string to spawn.
-            # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
-            comspec = os.environ.get("COMSPEC", None)
-            if comspec is None:
-                raise ProcessError("Cannot locate a COMSPEC environment "\
-                                   "variable to use as the shell")
-            # Explicitly check if we are using COMMAND.COM.  If we
-            # are then use the w9xpopen hack.
-            elif win32api.GetVersion() < 0x80000000L and\
-                 os.path.basename(comspec).lower() != "command.com":
-                # NT/2000 and not using command.com.
-                cmd = comspec + " /c " + cmd
-            else:
-                # Oh gag, we're on Win9x or using COMMAND.COM. Use the
-                # workaround listed in KB: Q150956
-                w9xpopen = os.path.join(
-                    os.path.basename(win32api.GetModuleFileName(0)),
-                    'w9xpopen.exe')
-                if not os.path.exists(w9xpopen):
-                    # Eeek - file-not-found - possibly an embedding
-                    # situation - see if we can locate it in sys.exec_prefix
-                    w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
-                                            'w9xpopen.exe')
-                    if not os.path.exists(w9xpopen):
-                        raise ProcessError(\
-                            "Can not locate 'w9xpopen.exe' which is needed "\
-                            "for ProcessOpen to work with your shell or "\
-                            "platform.")
-                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
+            cmd = _fixupCommand(cmd)
             log.debug("cmd = %r", cmd)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
@@ -1336,35 +1347,7 @@
             si.hStdError = hChildStderrWr
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-            # Fixup the command string to spawn.
-            # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
-            comspec = os.environ.get("COMSPEC", None)
-            if comspec is None:
-                raise ProcessError("Cannot locate a COMSPEC environment "\
-                                   "variable to use as the shell")
-            # Explicitly check if we are using COMMAND.COM.  If we
-            # are then use the w9xpopen hack.
-            elif win32api.GetVersion() < 0x80000000L and\
-                 os.path.basename(comspec).lower() != "command.com":
-                # NT/2000 and not using command.com.
-                cmd = comspec + " /c " + cmd
-            else:
-                # Oh gag, we're on Win9x or using COMMAND.COM. Use the
-                # workaround listed in KB: Q150956
-                w9xpopen = os.path.join(
-                    os.path.basename(win32api.GetModuleFileName(0)),
-                    'w9xpopen.exe')
-                if not os.path.exists(w9xpopen):
-                    # Eeek - file-not-found - possibly an embedding
-                    # situation - see if we can locate it in sys.exec_prefix
-                    w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
-                                            'w9xpopen.exe')
-                    if not os.path.exists(w9xpopen):
-                        raise ProcessError(\
-                            "Can not locate 'w9xpopen.exe' which is needed "\
-                            "for ProcessProxy to work with your shell or "\
-                            "platform.")
-                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
+            cmd = _fixupCommand(cmd)
             log.debug("cmd = %r", cmd)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#4 (text) ====

@@ -5,6 +5,7 @@
 import re
 import pprint
 import unittest
+import shutil
 import testsupport
 
 import process
@@ -21,6 +22,28 @@
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi "there"')
 
+    def test_ProcessProxy_cmd_with_multiples_quoted_args(self):
+        dname = "program files"
+        if not os.path.exists(dname):
+            os.makedirs(dname)
+        if sys.platform.startswith("win"):
+            talk = "talk.exe"
+        else:
+            talk = "talk"
+        talkWithSpaces = os.path.join(dname, talk)
+        shutil.copy(talk, talkWithSpaces)
+
+        try:
+            p = process.ProcessProxy('"%s" and here are "some" args'\
+                                     % talkWithSpaces)
+            output = p.stdout.read()
+            self.failUnless(output.strip() == 'o0o1o2o3o4')
+        finally:
+            if os.path.exists(talkWithSpaces):
+                os.unlink(talkWithSpaces)
+            if os.path.exists(dname):
+                os.removedirs(dname)
+
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
         def test_ProcessProxyWithThreadFix_simple_cmd(self):
@@ -43,6 +66,28 @@
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi "there"')
 
+    def test_ProcessOpen_cmd_with_multiples_quoted_args(self):
+        dname = "program files"
+        if not os.path.exists(dname):
+            os.makedirs(dname)
+        if sys.platform.startswith("win"):
+            talk = "talk.exe"
+        else:
+            talk = "talk"
+        talkWithSpaces = os.path.join(dname, talk)
+        shutil.copy(talk, talkWithSpaces)
+
+        try:
+            p = process.ProcessOpen('"%s" and here are "some" args'\
+                                    % talkWithSpaces)
+            output = p.stdout.read()
+            self.failUnless(output.strip() == 'o0o1o2o3o4')
+        finally:
+            if os.path.exists(talkWithSpaces):
+                os.unlink(talkWithSpaces)
+            if os.path.exists(dname):
+                os.removedirs(dname)
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
Change 43335 by trentm@trentm-razor on 2002/07/18 14:34:03

	   Add the ProcessOpen class that is basically a super-popen3 (it does not do
	   any of the heavy threaded proxying that ProcessProxy does). Note that I/O
	   is done directly via win32file.Read/WriteFile calls on the Win32 file
	   handle. This gives us better read semantics (.read(N) returns even if there
	   are < N chars to return) but costs us text-mode translation.
	
	   Also rename private classes with a leading underscore, greatly improve the
	   module doc string, beef up _FileWrapper to be able wrapping *just* a Win32
	   file handle and provide the right read semantics.
	
	   Add testing of ProcessOpen to the test suite.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#25 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#8 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#9 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#3 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#25 (text) ====

@@ -2,31 +2,62 @@
 """
     Python interface for process control.
 
-    This module defines a Process classes that can be used to spawn,
-    communicate with, and control a process.
+    This module defines three Process classes for spawning,
+    communicating and control processes. They are: Process, ProcessOpen,
+    ProcessProxy. All of the classes allow one to specify the command (cmd),
+    starting working directory (cwd), and environment to create for the
+    new process (env) and to "wait" for termination of the child and
+    "kill" the child.
+
+    Process:
+        Use this class to simply launch a process (either a GUI app or a
+        console app in a new console) with which you do not intend to
+        communicate via it std handles.
+
+    ProcessOpen:
+        Think of this as a super version of Python's os.popen3() method.
+        This spawns the given command and sets up pipes for
+        stdin/stdout/stderr which can then be used to communicate with
+        the child.
+
+    ProcessProxy:
+        This is a heavy-weight class that, similar to ProcessOpen,
+        spawns the given commands and sets up pipes to the child's
+        stdin/stdout/stderr. However, it also starts three threads to
+        proxy communication between each of the child's and parent's std
+        handles. At the parent end of this communication are, by
+        default, IOBuffer objects. You may specify your own objects here
+        (usually sub-classing from IOBuffer, which handles some
+        synchronization issues for you). The result is that it is
+        possible to have your own IOBuffer instance that gets, say, a
+        .write() "event" for every write that the child does on its
+        stdout.
+
+        Understanding ProcessProxy is pretty complex. Some examples
+        below attempt to help show some uses. Here is a diagram of the
+        comminucation:
+
+                            <parent process>
+               ,---->->->------'   ^   `------<-<-<----,
+               |                   |                   v
+           IOBuffer             IOBuffer            IOBuffer        
+           (p.stdout)           (p.stderr)          (p.stdin)
+               |                   |                   |
+           _OutFileProxy        _OutFileProxy       _InFileProxy
+           thread               thread              thread
+               |                   ^                   |
+               `----<-<-<------,   |   ,------>->->----'
+                            <child process>
 
     Usage:
-        from process import ProcessProxy
-        # You must specify at minimum a 'cmd' to spawn. Optionally you
-        # can specify a cwd, environment dictionary, stdout/stdin/stderr
-        # file-like objects to communicate with the spawned process.
-        p = ProcessProxy(cmd='...', ...)
+        import process
+        p = process.<Process class>(cmd='echo hi', ...)
         #... use the various methods and attributes
 
-    When your specifed process is spawned, ProcessProxy creates three proxy
-    threads (classes InFileProxy and OutFileProxy), one for each
-    standard handle, which pump information between the calling Python
-    code and the spawned child process. You can optionally pass in
-    file-like objects to ProcessProxy.__init__ to be responsible for handling
-    incoming writes on stdout and stderr and for outgoing write on
-    stdin. If you do not specify such handlers, ProcessProxy adds an IOBuffer
-    object for each handle, on which you can read or write, as
-    appropriate.
-    
     Examples:
       A simple 'hello world':
-        >>> from process import ProcessProxy
-        >>> p = ProcessProxy(['echo', 'hello'])
+        >>> import process
+        >>> p = process.ProcessOpen(['echo', 'hello'])
         >>> p.stdout.read()
         'hello\r\n'
         >>> p.wait()   # .wait() returns the child's exit status
@@ -34,11 +65,13 @@
 
       Redirecting the stdout handler:
         >>> import sys
-        >>> p = ProcessProxy(['echo', 'hello'], stdout=sys.stdout)
+        >>> p = process.ProcessProxy(['echo', 'hello'], stdout=sys.stdout)
         hello
 
-      Using stdin:
-        >>> p = ProcessProxy(['sort'])
+      Using stdin (need to use ProcessProxy here because it defaults to
+      text-mode translation on Windows, ProcessOpen does not support
+      this):
+        >>> p = process.ProcessProxy(['sort'])
         >>> p.stdin.write('5\n')
         >>> p.stdin.write('2\n')
         >>> p.stdin.write('7\n')
@@ -47,16 +80,17 @@
         '2\n5\n7\n'
 
       Specifying environment variables:
-        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}'])
+        >>> p = process.ProcessOpen(['perl', '-e', 'print $ENV{FOO}'])
         >>> p.stdout.read()
         ''
-        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}'],
-        ...             env={'FOO':'bar'}).start()
+        >>> p = process.ProcessOpen(['perl', '-e', 'print $ENV{FOO}'],
+        ...                         env={'FOO':'bar'}).start()
         >>> p.stdout.read()
         'bar'
 
-      Killing a long running process:
-        >>> p = ProcessProxy(['perl', '-e', 'while (1) {}'])
+      Killing a long running process (On Linux, to poll you must use
+      p.wait(os.WNOHANG)):
+        >>> p = ProcessOpen(['perl', '-e', 'while (1) {}'])
         >>> try:
         ...     p.wait(0)  # poll to see if is process still running
         ... except ProcessError, ex:
@@ -72,10 +106,7 @@
         XXX write this, mention IOBuffer subclassing.
 """
 #TODO:
-#   o the above (stdout good, stderr good, stdin good)
-#   o define a nice API
-#       o still need to add .wait() and .kill() and perhaps more tests
-#   - Discuss the decision to NOT have the stdout OutFileProxy wait for
+#   - Discuss the decision to NOT have the stdout _OutFileProxy wait for
 #     process termination before closing stdin. It will just close stdin
 #     when stdout is seen to have been closed. That is considered Good
 #     Enough (tm). Theoretically it would be nice to only abort the
@@ -85,18 +116,10 @@
 #     still running. That sucks.
 #     XXX Note that I don't even know if the current stdout proxy even
 #         closes the stdin proxy at all.
-#   o ensure get return value properly
-#   - ensure don't pop up consoles
-#   o proper termination 
 #   - DavidA: if I specify "unbuffered" for my stdin handler (in the
 #     ProcessProxy constructor) then the stdin IOBuffer should do a
 #     fparent.read() rather than a fparent.readline(). TrentM: can I do
 #     that? What happens?
-#   - Passing in handlers, or callbacks? Nah, Komodo side can handle
-#     that.
-#   o ensure can pass things like cwd and the environment to use
-#   o handling failure to launch, what are the semantics
-#   - make it work for linux too
 #
 
 import os
@@ -270,7 +293,140 @@
         pass
 
 
-#---- public routines
+class _FileWrapper:
+    """Wrap a system file object, hiding some nitpicky details.
+    
+    This class provides a Python file-like interface to either a Python
+    file object (pretty easy job) or an OS-specific file handle (e.g.
+    Win32 handles to file objects on Windows).
+
+    It also provides a place where related such object can be kept alive
+    together to prevent premature ref-counted collection. (E.g. on
+    Windows a Python file object may be associated with a Win32 file
+    handle. If the file handle is not kept alive the Python file object
+    will cease to function.)
+    """
+    def __init__(self, file=None, descriptor=None, handle=None, process=None):
+        self._file = file
+        self._descriptor = descriptor
+        self._handle = handle
+        self._process = process
+        self._closed = 0
+
+    def __del__(self):
+        self.close()
+
+    def __getattr__(self, name):
+        """Forward to the underlying file object."""
+        if self._file is not None:
+            return getattr(self._file, name)
+        else:
+            raise ProcessError("no file object to pass '%s' attribute to"
+                               % name)
+
+    def _win32Read(self, nBytes):
+        try:
+            log.info("[%s] _FileWrapper.read: waiting for read on pipe",
+                     id(self))
+            errCode, text = win32file.ReadFile(self._handle, nBytes)
+        except pywintypes.error, ex:
+            # Ignore errors for now, like "The pipe is being closed.",
+            # etc. XXX There *may* be errors we don't want to avoid.
+            log.info("[%s] _FileWrapper.read: error reading from pipe: %s",
+                     id(self), ex)
+            return ""
+        assert errCode == 0,\
+               "Why is 'errCode' from ReadFile non-zero? %r" % errCode
+        if not text:
+            # Empty text signifies that the pipe has been closed on
+            # the parent's end.
+            log.info("[%s] _FileWrapper.read: observed close of parent",
+                     id(self))
+            # Signal the child so it knows to stop listening.
+            self.close()
+            return ""
+        else:
+            log.info("[%s] _FileWrapper.read: read %d bytes from pipe: %r",
+                     id(self), len(text), text)
+        return text
+
+    def read(self, nBytes=-1):
+        if self._file is not None:
+            return self._file.read(nBytes)
+        elif self._handle is not None:
+            if nBytes <= 0:
+                # Read everything. Note that we are changing the "read
+                # everything" cue to include 0, because actually doing
+                # win32file.ReadFile(<handle>, 0) results in every
+                # subsequent read returning 0, i.e. is shuts down the
+                # pipe.
+                self._process.wait()
+                text = ""
+                while 1:
+                    t = self._win32Read(4092)
+                    if not t:
+                        break
+                    else:
+                        text += t
+            else:
+                text = self._win32Read(nBytes)
+            return text
+        else:   
+            raise "FileHandle.read: no handle to read with"
+
+    def write(self, text):
+        if self._file is not None:
+            return self._file.write(text)
+        elif self._handle is not None:
+            try:
+                errCode, nBytesWritten = win32file.WriteFile(self._handle, text)
+            except pywintypes.error, ex:
+                # Ingore errors like "The pipe is being closed.", for
+                # now.
+                log.info("[%s] _FileWrapper.write: error writing to pipe, "\
+                         "ignored", id(self))
+                return
+            assert errCode == 0,\
+                   "Why is 'errCode' from WriteFile non-zero? %r" % errCode
+            if not nBytesWritten:
+                # No bytes written signifies that the pipe has been
+                # closed on the child's end.
+                log.info("[%s] _FileWrapper.write: observed close of pipe",
+                         id(self))
+                return
+            else:
+                log.info("[%s] _FileWrapper.write: wrote %d bytes to pipe: %r",
+                         id(self), len(text), text)
+        else:   
+            raise "FileHandle.write: nothing to write with"
+
+    def close(self):
+        """Close all associated file objects and handles."""
+        log.debug("[%s] _FileWrapper.close()", id(self))
+        if not self._closed:
+            self._closed = 1
+            if self._file is not None:
+                log.debug("[%s] _FileWrapper.close: close file", id(self))
+                self._file.close()
+                log.debug("[%s] _FileWrapper.close: done file close", id(self))
+            if self._handle is not None:
+                log.debug("[%s] _FileWrapper.close: close handle", id(self))
+                try:
+                    win32api.CloseHandle(self._handle)
+                except win32api.error:
+                    log.debug("[%s] _FileWrapper.close: closing handle raised",
+                              id(self))
+                    pass
+                log.debug("[%s] _FileWrapper.close: done closing handle",
+                          id(self))
+
+    def __repr__(self):
+        return "<_FileWrapper: file:%r fd:%r os_handle:%r>"\
+               % (self._file, self._descriptor, self._handle)
+
+
+
+#---- public interface
 
 class Process:
     """Create a process.
@@ -280,6 +436,9 @@
     inherit (all defaults are the parent's current settings). 'wait' and
     'kill' method allow for control of the child's termination.
     """
+    # TODO:
+    #   - Rename this or merge it with ProcessOpen somehow.
+    #
     if sys.platform.startswith("win"):
         # .wait() argument constants
         INFINITE = win32event.INFINITE
@@ -508,42 +667,403 @@
             win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
 
 
-class FileWrapper:
-    """Wrap a system file object, hiding some nitpicky details."""
-    def __init__(self, file, descriptor, handle=None):
-        self._file = file
-        self._descriptor = descriptor
-        self._handle = handle
+class ProcessOpen(Process):
+    """Create a process and setup pipes to it standard handles.
+
+    This is a super popen.
+
+    Limitations:
+        The "mode" argument to optionally specify text-mode translation
+        is NOT implemented. (1) This is only available and meaningful on
+        Windows anyway and (2) it requires that one go through the stdio
+        mechanisms on Windows which has the side-effect of adding
+        unwanted buffering and changing read-semantics such that
+        .read(N) does NOT return if there are some but fewer than N
+        bytes to be read. That is a big price to pay for text
+        translation.
+
+        As well, because C-stdio-level IO is NOT being used, there is no
+        option (nor need?) for setting a "bufsize". XXX *Could* still
+        support this on Unix.
+    """
+    # TODO:
+    #   - Share some implementation with Process and ProcessProxy.
+    #
+
+    def __init__(self, cmd, cwd=None, env=None):
+        """Create a Process with proxy threads for each std handle.
+
+        "cmd" is the command string of argument vector to run.
+        "cwd" optionally specifies the directory in which the child process
+            should be started. Default is None, a.k.a. inherits the cwd from
+            the parent.
+        "env" is optionally a mapping specifying the environment in which to
+            start the child. Default is None, a.k.a. inherits the environment
+            of the parent.
+        """
+        # Keep a reference to ensure it is around for this object's destruction.
+        self.__log = log
+        log.info("ProcessOpen.__init__(cmd=%r, cwd=%r, env=%r)",
+                 cmd, cwd, env)
+        self._cmd = cmd
+        if not self._cmd:
+            raise ProcessError("You must specify a command.")
+        self._cwd = cwd
+        self._env = env
         self._closed = 0
 
+        if sys.platform.startswith("win"):
+            self._startOnWindows()
+        else:
+            self._startOnUnix()
+
+        _registerProcess(self)
+
     def __del__(self):
+        #XXX Should probably not rely upon this.
         self.close()
 
-    def __getattr__(self, name):
-        """Forward to the underlying file object."""
-        return getattr(self._file, name)
-
     def close(self):
-        """Close the handle when the file is closed."""
-        log.debug("[%s] FileWrapper.close()", id(self))
         if not self._closed:
+            self.__log.info("[%s] ProcessOpen.close()" % id(self))
+
+            # Ensure that all IOBuffer's are closed. If they are not, these
+            # can cause hangs. 
+            self.__log.info("[%s] ProcessOpen: closing stdin (%r)."\
+                            % (id(self), self.stdin))
+            try:
+                self.stdin.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+            self.__log.info("[%s] ProcessOpen: closing stdout (%r)."\
+                            % (id(self), self.stdout))
+            try:
+                self.stdout.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+            self.__log.info("[%s] ProcessOpen: closing stderr (%r)."\
+                            % (id(self), self.stderr))
+            try:
+                self.stderr.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+
+            del self.__log # drop reference
             self._closed = 1
-            log.debug("[%s] FileWrapper.close: close file", id(self))
-            retval = self._file.close()
-            log.debug("[%s] FileWrapper.close: done closing file", id(self))
-            if self._handle is not None:
-                log.debug("[%s] FileWrapper.close: close handle", id(self))
-                try:
-                    win32api.CloseHandle(self._handle)
-                except win32api.error:
-                    log.debug("[%s] FileWrapper.close: closing handle raised", id(self))
-                    pass
-                log.debug("[%s] FileWrapper.close: done closing handle", id(self))
-            return retval
+
+    def _forkAndExecChildOnUnix(self, fdChildStdinRd, fdChildStdoutWr,
+                                fdChildStderrWr):
+        """Fork and start the child process.
+
+        Returns the child pid.
+        """
+        pid = os.fork()
+        if pid == 0: # child
+            os.dup2(fdChildStdinRd, 0)
+            os.dup2(fdChildStdoutWr, 1)
+            os.dup2(fdChildStderrWr, 2)
+            self._runChildOnUnix()
+        # parent
+        return pid
+
+    def _startOnUnix(self):
+        # Create pipes for std handles.
+        fdChildStdinRd, fdChildStdinWr = os.pipe()
+        fdChildStdoutRd, fdChildStdoutWr = os.pipe()
+        fdChildStderrRd, fdChildStderrWr = os.pipe()
+
+        if self._cwd:
+            oldDir = os.getcwd()
+            try:
+                os.chdir(self._cwd)
+            except OSError, ex:
+                raise ProcessError(msg=str(ex), errno=ex.errno)
+        self._pid = self._forkAndExecChildOnUnix(fdChildStdinRd,
+            fdChildStdoutWr, fdChildStderrWr)
+        if self._cwd:
+            os.chdir(oldDir)
+
+        os.close(fdChildStdinRd)
+        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w', -1)
+        os.close(fdChildStdoutWr)
+        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r', -1)
+        os.close(fdChildStderrWr)
+        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', -1)
+
+        childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
+        logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
+                    id(self), childStdin)
+        childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+        logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
+                    id(self), childStdout)
+        childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
+        logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
+                    id(self), childStderr)
+
+        # Create proxy threads for the out pipes.
+        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
+        stdinProxy.start()
+        # Clean up the parent's side of <stdin> when it is observed that
+        # the child has closed its side of <stdout>. (This is one way of
+        # determining when it is appropriate to clean up this pipe, with
+        # compromises. See the discussion at the top of this module.)
+        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
+                                   [self.stdin, childStdin, self],
+                                   name='<stdout>')
+        stdoutProxy.start()
+        stderrProxy = _OutFileProxy(childStderr, self.stderr,
+                                   name='<stderr>')
+        stderrProxy.start()
+
+    def _startOnWindows(self):
+        if type(self._cmd) in (types.ListType, types.TupleType):
+            # An arg vector was passed in.
+            cmd = _joinArgv(self._cmd)
+        else:
+            cmd = self._cmd
+
+        # Create pipes for std handles.
+        # (Set the bInheritHandle flag so pipe handles are inherited.)
+        saAttr = pywintypes.SECURITY_ATTRIBUTES()
+        saAttr.bInheritHandle = 1
+        #XXX Should maybe try with os.pipe. Dunno what that does for
+        #    inheritability though.
+        hChildStdinRd, hChildStdinWr = win32pipe.CreatePipe(saAttr, 0) 
+        hChildStdoutRd, hChildStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
+        hChildStderrRd, hChildStderrWr = win32pipe.CreatePipe(saAttr, 0) 
+
+        try:
+            # Duplicate the parent ends of the pipes so they are not
+            # inherited. 
+            hChildStdinWrDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStdinWr,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStdinWr)
+            self._hChildStdinWr = hChildStdinWrDup
+            hChildStdoutRdDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStdoutRd,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStdoutRd)
+            self._hChildStdoutRd = hChildStdoutRdDup
+            hChildStderrRdDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStderrRd,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStderrRd)
+            self._hChildStderrRd = hChildStderrRdDup
+
+            self.stdin = _FileWrapper(handle=self._hChildStdinWr, process=self)
+            logres.info("[%s] ProcessOpen._start(): create child stdin: %r",
+                        id(self), self.stdin)
+            self.stdout = _FileWrapper(handle=self._hChildStdoutRd,
+                                       process=self)
+            logres.info("[%s] ProcessOpen._start(): create child stdout: %r",
+                        id(self), self.stdout)
+            self.stderr = _FileWrapper(handle=self._hChildStderrRd,
+                                       process=self)
+            logres.info("[%s] ProcessOpen._start(): create child stderr: %r",
+                        id(self), self.stderr)
+
+            # Start the child process.
+            si = win32process.STARTUPINFO() 
+            si.dwFlags = win32process.STARTF_USESHOWWINDOW
+            si.wShowWindow = 0 # SW_HIDE
+            si.hStdInput = hChildStdinRd
+            si.hStdOutput = hChildStdoutWr
+            si.hStdError = hChildStderrWr
+            si.dwFlags |= win32process.STARTF_USESTDHANDLES
+
+            # Fixup the command string to spawn.
+            # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
+            comspec = os.environ.get("COMSPEC", None)
+            if comspec is None:
+                raise ProcessError("Cannot locate a COMSPEC environment "\
+                                   "variable to use as the shell")
+            # Explicitly check if we are using COMMAND.COM.  If we
+            # are then use the w9xpopen hack.
+            elif win32api.GetVersion() < 0x80000000L and\
+                 os.path.basename(comspec).lower() != "command.com":
+                # NT/2000 and not using command.com.
+                cmd = comspec + " /c " + cmd
+            else:
+                # Oh gag, we're on Win9x or using COMMAND.COM. Use the
+                # workaround listed in KB: Q150956
+                w9xpopen = os.path.join(
+                    os.path.basename(win32api.GetModuleFileName(0)),
+                    'w9xpopen.exe')
+                if not os.path.exists(w9xpopen):
+                    # Eeek - file-not-found - possibly an embedding
+                    # situation - see if we can locate it in sys.exec_prefix
+                    w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
+                                            'w9xpopen.exe')
+                    if not os.path.exists(w9xpopen):
+                        raise ProcessError(\
+                            "Can not locate 'w9xpopen.exe' which is needed "\
+                            "for ProcessOpen to work with your shell or "\
+                            "platform.")
+                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
+            log.debug("cmd = %r", cmd)
+
+            creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
+            try:
+                self._hProcess, hThread, self._processId, threadId\
+                    = win32process.CreateProcess(
+                        None,           # app name
+                        cmd,            # command line 
+                        None,           # process security attributes 
+                        None,           # primary thread security attributes 
+                        1,              # handles are inherited 
+                        creationFlags,  # creation flags 
+                        self._env,      # environment
+                        self._cwd,      # current working directory
+                        si)             # STARTUPINFO pointer 
+            except win32api.error, ex:
+                raise ProcessError(msg=ex.args[2], errno=ex.args[0])
+            win32api.CloseHandle(hThread)
+
+        finally:
+            # Close child ends of pipes on the parent's side (the
+            # parent's ends of the pipe are closed in the _FileWrappers.)
+            win32file.CloseHandle(hChildStdinRd)
+            win32file.CloseHandle(hChildStdoutWr)
+            win32file.CloseHandle(hChildStderrWr)
+
+    def wait(self, timeout=None): 
+        """Wait for the started process to complete.
+        
+        "timeout" (on Windows) is a floating point number of seconds after
+            which to timeout.  Default is win32event.INFINITE.
+        "timeout" (on Unix) is akin to the os.waitpid() "options" argument
+            (os.WNOHANG may be used to return immediately if the process has
+            not exited). Default is 0, i.e. wait forever.
+
+        If the wait time's out it will raise a ProcessError. Otherwise it
+        will return the child's exit value (on Windows) or the child's exit
+        status excoded as per os.waitpid() (on Linux):
+            "a 16-bit number, whose low byte is the signal number that killed
+            the process, and whose high byte is the exit status (if the
+            signal number is zero); the high bit of the low byte is set if a
+            core file was produced."
+        In the latter case, use the os.W*() methods to interpret the return
+        value.
+        """
+        # XXX Or should returning the exit value be move out to another
+        #    function as on Win32 process control? If so, then should
+        #    perhaps not make WaitForSingleObject semantic
+        #    transformation.
+        # TODO:
+        #   - Need to rationalize the .wait() API for Windows vs. Unix.
+        #     It is a real pain in the current situation.
+        if sys.platform.startswith("win"):
+            if timeout is None:
+                timeout = win32event.INFINITE
+            else:
+                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+
+            rc = win32event.WaitForSingleObject(self._hProcess, timeout)
+            if rc == win32event.WAIT_FAILED:
+                raise ProcessError("'WAIT_FAILED' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
+            elif rc == win32event.WAIT_TIMEOUT:
+                raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
+
+            retval = win32process.GetExitCodeProcess(self._hProcess)
+        else:
+            if timeout is None:
+                timeout = 0
+            pid, sts = os.waitpid(self._pid, timeout)
+            if pid == self._pid:
+                retval = sts
+            else:
+                raise ProcessError("Wait for process timed out.",
+                                   self.WAIT_TIMEOUT)
+        _unregisterProcess(self)
+        return retval
+
+    def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
+        """Kill process.
+        
+        "exitCode" (Windows only) is the code the terminated process should
+            exit with.
+        "gracePeriod" (Windows only) is a number of seconds the process is
+            allowed to shutdown with a WM_CLOSE signal before a hard
+            terminate is called.
+        "sig" (Unix only) is the signal to use to kill the process. Defaults
+            to signal.SIGKILL. See os.kill() for more information.
+
+        Windows:
+            Try for an orderly shutdown via WM_CLOSE.  If still running
+            after gracePeriod (1 sec. default), terminate.
+        """
+        if sys.platform.startswith("win"):
+            # Send WM_CLOSE to windows in this process group.
+            win32gui.EnumWindows(self._close_, 0)
+
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, exitCode)
+                win32api.Sleep(100) # wait for resources to be released
+
+            # Last resort, send Ctrl-C to all processes attached to this console.
+            # This is done *after* TerminateProcess because the former
+            # allows one to specify the exit code for the top-level process
+            # in the process group. The subsequent CTRL+Break will then (we
+            # hope) terminate any other remaining processes in the group.
+            try:
+                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                                                  self._processId)
+            except AttributeError:
+                log.warn("The win32api module does not have "\
+                         "GenerateConsoleCtrlEvent(). This may mean that "\
+                         "parts of this process group have NOT been killed.")
+            except win32api.error, ex:
+                if ex.args[0] != 87:
+                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
+                    #                     'The parameter is incorrect.')
+                    raise
+
+        else:
+            if sig is None:
+                sig = signal.SIGKILL
+            try:
+                os.kill(self._pid, sig)
+            except OSError, ex:
+                if ex.errno != 3:
+                    # Ignore:   OSError: [Errno 3] No such process
+                    raise
+
+        _unregisterProcess(self)
+
+    def _close_(self, hwnd, dummy):
+        """Callback used by .kill() on Windows.
 
-    def __repr__(self):
-        return "<FileWrapper: file:%r fd:%r handle:%r"\
-               % (self._file, self._descriptor, self._handle)
+        EnumWindows callback - sends WM_CLOSE to any window owned by this
+        process.
+        """
+        threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
+        if processId == self._processId:
+            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
 
 
 class ProcessProxy(Process):
@@ -699,28 +1219,28 @@
         os.close(fdChildStderrWr)
         fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', self._bufsize)
 
-        childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr)
+        childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr)
         logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                     id(self), childStdin)
-        childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+        childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd)
         logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                     id(self), childStdout)
-        childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd)
+        childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd)
         logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                     id(self), childStderr)
 
         # Create proxy threads for the out pipes.
-        stdinProxy = InFileProxy(self.stdin, childStdin, name='<stdin>')
+        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
         stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
         # the child has closed its side of <stdout>. (This is one way of
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
-        stdoutProxy = OutFileProxy(childStdout, self.stdout, 
+        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
                                    [self.stdin, childStdin, self],
                                    name='<stdout>')
         stdoutProxy.start()
-        stderrProxy = OutFileProxy(childStderr, self.stderr,
+        stderrProxy = _OutFileProxy(childStderr, self.stderr,
                                    name='<stderr>')
         stderrProxy.start()
 
@@ -794,15 +1314,15 @@
             fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
             fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
 
-            childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr,
+            childStdin = _FileWrapper(fChildStdinWr, fdChildStdinWr,
                                      self._hChildStdinWr)
             logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                         id(self), childStdin)
-            childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd,
+            childStdout = _FileWrapper(fChildStdoutRd, fdChildStdoutRd,
                                       self._hChildStdoutRd)
             logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                         id(self), childStdout)
-            childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd,
+            childStderr = _FileWrapper(fChildStderrRd, fdChildStderrRd,
                                       self._hChildStderrRd)
             logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                         id(self), childStderr)
@@ -866,23 +1386,23 @@
 
         finally:
             # Close child ends of pipes on the parent's side (the
-            # parent's ends of the pipe are closed in the FileWrappers.)
+            # parent's ends of the pipe are closed in the _FileWrappers.)
             win32file.CloseHandle(hChildStdinRd)
             win32file.CloseHandle(hChildStdoutWr)
             win32file.CloseHandle(hChildStderrWr)
 
         # Create proxy threads for the out pipes.
-        stdinProxy = InFileProxy(self.stdin, childStdin, name='<stdin>')
+        stdinProxy = _InFileProxy(self.stdin, childStdin, name='<stdin>')
         stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
         # the child has closed its side of <stdout>. (This is one way of
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
-        stdoutProxy = OutFileProxy(childStdout, self.stdout, 
+        stdoutProxy = _OutFileProxy(childStdout, self.stdout, 
                                    [self.stdin, childStdin, self],
                                    name='<stdout>')
         stdoutProxy.start()
-        stderrProxy = OutFileProxy(childStderr, self.stderr,
+        stderrProxy = _OutFileProxy(childStderr, self.stderr,
                                    name='<stderr>')
         stderrProxy.start()
 
@@ -1102,7 +1622,7 @@
             # (or until the buffer is closed, i.e. no more writes will
             # come).
             # XXX WARNING: I *think* there is a race condition around
-            #     here whereby self.fparent.read() in InFileProxy can
+            #     here whereby self.fparent.read() in _InFileProxy can
             #     hang. *Sometime* test_stdin::test_stdin_buffer() will
             #     hang. This was *before* I moved the
             #     _stateChange.acquire() and .release() calls out side
@@ -1185,7 +1705,7 @@
         #    and .readline() calls that are waiting for more data???
 
 
-class InFileProxy(threading.Thread):
+class _InFileProxy(threading.Thread):
     """A thread to proxy stdin.write()'s from the parent to the child."""
     def __init__(self, fParent, fChild, name=None):
         """
@@ -1193,24 +1713,24 @@
         "fChild" is a Win32 handle to the a child process' output pipe.
         "name" can be set for debugging, it will be used in log messages.
         """
-        log.info("[%s, %s] InFileProxy.__init__(fChild=%r, fParent=%r)",
+        log.info("[%s, %s] _InFileProxy.__init__(fChild=%r, fParent=%r)",
                  name, id(self), fChild, fParent)
         threading.Thread.__init__(self, name=name)
         self.fChild = fChild
         self.fParent = fParent
 
     def run(self):
-        log.info("[%s] InFileProxy: start" % self.getName())
+        log.info("[%s] _InFileProxy: start" % self.getName())
         try:
             self._proxyFromParentToChild()
         finally:
-            log.info("[%s] InFileProxy: closing parent (%r)"\
+            log.info("[%s] _InFileProxy: closing parent (%r)"\
                      % (self.getName(), self.fParent))
             try:
                 self.fParent.close()
             except IOError:
                 pass # Ignore: IOError: [Errno 4] Interrupted system call
-        log.info("[%s] InFileProxy: done" % self.getName())
+        log.info("[%s] _InFileProxy: done" % self.getName())
 
     def _proxyFromParentToChild(self):
         # This is a reasonable buffer size, on Windows at least.
@@ -1218,12 +1738,12 @@
         # Reducing it will NOT help to get output more smoothly from the
         # other end of the pipe (this is true for buffered and
         # unbuffered I/O situations). (Look at the BUFSIZE comments in
-        # OutFileProxy. Those may apply here at sometime.)
+        # _OutFileProxy. Those may apply here at sometime.)
         BUFSIZE = 4096
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
-            log.info("[%s] InFileProxy: waiting for read on parent (%r)"\
+            log.info("[%s] _InFileProxy: waiting for read on parent (%r)"\
                      % (self.getName(), self.fParent))
             # XXX Get hangs here (!) even with
             #     self.stdin.close() in ProcessProxy' __del__() under this
@@ -1231,7 +1751,7 @@
             #           p = ProcessProxy([...], stdin=sys.stdin)
             #     The user must manually send '\n' via <Enter> or EOF
             #     via <Ctrl-Z> to unlock this. How to get around that?
-            #     See cleanOnTermination note in OutFileProxy.run()
+            #     See cleanOnTermination note in _OutFileProxy.run()
             #     below.
             #log.debug("XXX          -> start read on %r" % self.fParent)
             try:
@@ -1247,11 +1767,11 @@
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the parent's end.
-                log.info("[%s] InFileProxy: observed close of parent (%r)"\
+                log.info("[%s] _InFileProxy: observed close of parent (%r)"\
                          % (self.getName(), self.fParent))
                 # Signal the child so it knows to stop listening.
                 try:
-                    logres.info("[%s] InFileProxy: closing child after "\
+                    logres.info("[%s] _InFileProxy: closing child after "\
                                 "observing parent's close: %r", self.getName(),
                                 self.fChild)
                     try:
@@ -1264,24 +1784,24 @@
                     pass
                 break
             else:
-                log.info("[%s] InFileProxy: read %d bytes from parent: %r"\
+                log.info("[%s] _InFileProxy: read %d bytes from parent: %r"\
                          % (self.getName(), len(text), text))
 
-            log.info("[%s, %s] InFileProxy: writing %r to child (%r)",
+            log.info("[%s, %s] _InFileProxy: writing %r to child (%r)",
                      self.getName(), id(self), text, self.fChild)
             try:
                 self.fChild.write(text)
             except IOError, ex:
                 # Ignore errors for now.
                 # XXX There *may* be errors we don't want to avoid.
-                log.info("[%s] InFileProxy: error writing to child (%r), "\
+                log.info("[%s] _InFileProxy: error writing to child (%r), "\
                          "closing: %s" % (self.getName(), self.fParent, ex))
                 break
-            log.info("[%s] InFileProxy: wrote %d bytes to child: %r"\
+            log.info("[%s] _InFileProxy: wrote %d bytes to child: %r"\
                      % (self.getName(), len(text), text))
 
 
-class OutFileProxy(threading.Thread):
+class _OutFileProxy(threading.Thread):
     """A thread to watch an "out" file from the spawned child process
     and pass on write's to the parent.
     """
@@ -1293,7 +1813,7 @@
             proxy is terminating.
         "name" can be set for debugging, it will be used in log messages.
         """
-        log.info("[%s] OutFileProxy.__init__(fChild=%r, fParent=%r, "\
+        log.info("[%s] _OutFileProxy.__init__(fChild=%r, fParent=%r, "\
                  "toClose=%r)", name, fChild, fParent, toClose)
         threading.Thread.__init__(self, name=name)
         self.fChild = fChild
@@ -1301,30 +1821,30 @@
         self.toClose = toClose
 
     def run(self):
-        log.info("[%s] OutFileProxy: start" % self.getName())
+        log.info("[%s] _OutFileProxy: start" % self.getName())
         try:
             self._proxyFromChildToParent()
         finally:
-            logres.info("[%s] OutFileProxy: terminating, close child (%r)",
+            logres.info("[%s] _OutFileProxy: terminating, close child (%r)",
                         self.getName(), self.fChild)
             try:
                 self.fChild.close()
             except IOError:
                 pass # Ignore: IOError: [Errno 4] Interrupted system call
-            log.info("[%s] OutFileProxy: closing parent (%r)",
+            log.info("[%s] _OutFileProxy: closing parent (%r)",
                      self.getName(), self.fParent)
             try:
                 self.fParent.close()
             except IOError:
                 pass # Ignore: IOError: [Errno 4] Interrupted system call
             for item in self.toClose:
-                logres.info("[%s] OutFileProxy: closing %r after "\
+                logres.info("[%s] _OutFileProxy: closing %r after "\
                             "closing parent", self.getName(), item)
                 try:
                     item.close()
                 except IOError:
                     pass # Ignore: IOError: [Errno 4] Interrupted system call
-        log.info("[%s] OutFileProxy: done" % self.getName())
+        log.info("[%s] _OutFileProxy: done" % self.getName())
 
     def _proxyFromChildToParent(self):
         # A larger read chunk size results in undesired buffering of
@@ -1337,23 +1857,23 @@
         while 1:
             text = None
             try:
-                log.info("[%s] OutFileProxy: waiting for read on child (%r)"\
+                log.info("[%s] _OutFileProxy: waiting for read on child (%r)"\
                          % (self.getName(), self.fChild))
                 text = self.fChild.read(BUFSIZE)
             except IOError, ex:
                 # Ignore: IOError: [Errno 9] Bad file descriptor
                 # XXX Do we *know* we want to do that?
-                log.info("[%s] OutFileProxy: error reading from child (%r), "\
+                log.info("[%s] _OutFileProxy: error reading from child (%r), "\
                          "shutting down: %s", self.getName(), self.fChild, ex)
                 break
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the child's end.
-                log.info("[%s] OutFileProxy: observed close of child (%r)"\
+                log.info("[%s] _OutFileProxy: observed close of child (%r)"\
                          % (self.getName(), self.fChild))
                 break
 
-            log.info("[%s] OutFileProxy: text(len=%d): %r"\
+            log.info("[%s] _OutFileProxy: text(len=%d): %r"\
                      % (self.getName(), len(text), text))
             self.fParent.write(text)
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#3 (text) ====

@@ -11,28 +11,38 @@
 
 
 class CmdTestCase(unittest.TestCase):
-    def test_simple_cmd(self):
+    def test_ProcessProxy_simple_cmd(self):
         p = process.ProcessProxy('echo hi there')
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi there')
 
-    def test_cmd_with_quotes(self):
+    def test_ProcessProxy_cmd_with_quotes(self):
         p = process.ProcessProxy('echo hi "there"')
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi "there"')
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_simple_cmd_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_simple_cmd(self):
             p = process.ProcessProxyWithThreadFix('echo hi there')
             output = p.stdout.read()
             self.failUnless(output.strip() == 'hi there')
 
-        def test_cmd_with_quotes_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_cmd_with_quotes(self):
             p = process.ProcessProxyWithThreadFix('echo hi "there"')
             output = p.stdout.read()
             self.failUnless(output.strip() == 'hi "there"')
 
+    def test_ProcessOpen_simple_cmd(self):
+        p = process.ProcessOpen('echo hi there')
+        output = p.stdout.read()
+        self.failUnless(output.strip() == 'hi there')
+
+    def test_ProcessOpen_cmd_with_quotes(self):
+        p = process.ProcessOpen('echo hi "there"')
+        output = p.stdout.read()
+        self.failUnless(output.strip() == 'hi "there"')
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#8 (text) ====

@@ -11,7 +11,7 @@
 
 
 class CwdTestCase(unittest.TestCase):
-    def test_cwd_notspecified(self):
+    def test_ProcessProxy_cwd_notspecified(self):
         cwd = os.getcwd()
 
         p = process.ProcessProxy(['printcwd'])
@@ -24,7 +24,7 @@
         self.failUnless(match.group(1) == cwd,
                         "%r != %r" % (match.group(1), cwd))
 
-    def test_cwd_specified(self):
+    def test_ProcessProxy_cwd_specified(self):
         wd = os.path.expanduser('~')
 
         p = process.ProcessProxy(['printcwd'], cwd=wd)
@@ -37,12 +37,12 @@
         self.failUnless(match.group(1) == wd,
                         "%r != %r" % (match.group(1), wd))
 
-    def test_cwd_specified_doesnotexist(self):
+    def test_ProcessProxy_cwd_specified_doesnotexist(self):
         wd = "foobar"
         self.failUnlessRaises(process.ProcessError, process.ProcessProxy,
                               cmd=['printcwd'], cwd=wd)
 
-    def test_cwd_specified_relative(self):
+    def test_ProcessProxy_cwd_specified_relative(self):
         wd = "mytmprelativedir"
         testsupport.mkdir(wd)
 
@@ -58,7 +58,7 @@
     
         testsupport.rmtree(wd)
 
-    def test_cwd_specified_withspaces(self):
+    def test_ProcessProxy_cwd_specified_withspaces(self):
         wd = "my tmp relative dir with spaces"
         testsupport.mkdir(wd)
 
@@ -76,7 +76,7 @@
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_cwd_notspecified_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_cwd_notspecified(self):
             cwd = os.getcwd()
 
             p = process.ProcessProxyWithThreadFix(['printcwd'])
@@ -89,7 +89,7 @@
             self.failUnless(match.group(1) == cwd,
                             "%r != %r" % (match.group(1), cwd))
 
-        def test_cwd_specified_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_cwd_specified(self):
             wd = os.path.expanduser('~')
 
             p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
@@ -102,12 +102,12 @@
             self.failUnless(match.group(1) == wd,
                             "%r != %r" % (match.group(1), wd))
 
-        def test_cwd_specified_doesnotexist_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_cwd_specified_doesnotexist(self):
             wd = "foobar"
             self.failUnlessRaises(process.ProcessError, process.ProcessProxyWithThreadFix,
                                   cmd=['printcwd'], cwd=wd)
 
-        def test_cwd_specified_relative(self):
+        def test_ProcessProxyWithThreadFix_cwd_specified_relative(self):
             wd = "mytmprelativedir"
             testsupport.mkdir(wd)
 
@@ -123,7 +123,7 @@
         
             testsupport.rmtree(wd)
 
-        def test_cwd_specified_withspaces_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_cwd_specified_withspaces(self):
             wd = "my tmp relative dir with spaces"
             testsupport.mkdir(wd)
 
@@ -139,6 +139,53 @@
         
             testsupport.rmtree(wd)
 
+    def test_ProcessOpen_cwd_notspecified(self):
+        cwd = os.getcwd()
+
+        p = process.ProcessOpen(['printcwd'])
+        output = p.stdout.read()
+
+        pattern = re.compile("CWD is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == cwd,
+                        "%r != %r" % (match.group(1), cwd))
+
+    def test_ProcessOpen_cwd_specified(self):
+        wd = os.path.expanduser('~')
+
+        p = process.ProcessOpen(['printcwd'], cwd=wd)
+        output = p.stdout.read()
+
+        pattern = re.compile("CWD is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == wd,
+                        "%r != %r" % (match.group(1), wd))
+
+    def test_ProcessOpen_cwd_specified_doesnotexist(self):
+        wd = "foobar"
+        self.failUnlessRaises(process.ProcessError, process.ProcessOpen,
+                              cmd=['printcwd'], cwd=wd)
+
+    def test_ProcessOpen_cwd_specified_relative(self):
+        wd = "mytmprelativedir"
+        testsupport.mkdir(wd)
+
+        p = process.ProcessOpen(['printcwd'], cwd=wd)
+        output = p.stdout.read()
+
+        pattern = re.compile("CWD is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == os.path.abspath(wd),
+                        "%r != %r" % (match.group(1), os.path.abspath(wd)))
+    
+        testsupport.rmtree(wd)
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#5 (text) ====

@@ -11,7 +11,7 @@
 
 
 class EnvTestCase(unittest.TestCase):
-    def test_env_unspecified(self):
+    def test_ProcessProxy_env_unspecified(self):
         talkenv = ''
 
         p = process.ProcessProxy(['printenv'])
@@ -24,7 +24,7 @@
         self.failUnless(match.group(1) == talkenv,
                         "%r != %r" % (match.group(1), talkenv))
 
-    def test_env_inherited(self):
+    def test_ProcessProxy_env_inherited(self):
         talkenv = 'foo'
         os.environ['TALK_ENV'] = 'foo'
 
@@ -40,7 +40,7 @@
 
         os.environ['TALK_ENV'] = ''
 
-    def test_env_specified(self):
+    def test_ProcessProxy_env_specified(self):
         talkenv = 'bar'
         env = {'TALK_ENV': talkenv}
 
@@ -54,7 +54,7 @@
         self.failUnless(match.group(1) == talkenv,
                         "%r != %r" % (match.group(1), talkenv))
 
-    def test_env_overridden(self):
+    def test_ProcessProxy_env_overridden(self):
         os.environ['TALK_ENV'] = 'spam'
         talkenv = 'eggs'
         env = {'TALK_ENV': talkenv}
@@ -74,10 +74,10 @@
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_env_unspecified_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_env_unspecified(self):
             talkenv = ''
 
-            p = process.ProcessProxy(['printenv'])
+            p = process.ProcessProxyWithThreadFix(['printenv'])
             output = p.stdout.read()
 
             pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -87,11 +87,11 @@
             self.failUnless(match.group(1) == talkenv,
                             "%r != %r" % (match.group(1), talkenv))
 
-        def test_env_inherited_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_env_inherited(self):
             talkenv = 'foo'
             os.environ['TALK_ENV'] = 'foo'
 
-            p = process.ProcessProxy(['printenv'])
+            p = process.ProcessProxyWithThreadFix(['printenv'])
             output = p.stdout.read()
 
             pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -103,11 +103,11 @@
 
             os.environ['TALK_ENV'] = ''
 
-        def test_env_specified_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_env_specified(self):
             talkenv = 'bar'
             env = {'TALK_ENV': talkenv}
 
-            p = process.ProcessProxy(['printenv'], env=env)
+            p = process.ProcessProxyWithThreadFix(['printenv'], env=env)
             output = p.stdout.read()
 
             pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -117,12 +117,12 @@
             self.failUnless(match.group(1) == talkenv,
                             "%r != %r" % (match.group(1), talkenv))
 
-        def test_env_overridden_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_env_overridden(self):
             os.environ['TALK_ENV'] = 'spam'
             talkenv = 'eggs'
             env = {'TALK_ENV': talkenv}
 
-            p = process.ProcessProxy(['printenv'], env=env)
+            p = process.ProcessProxyWithThreadFix(['printenv'], env=env)
             output = p.stdout.read()
 
             pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -135,6 +135,67 @@
             self.failUnless(os.environ['TALK_ENV'] == 'spam')
             os.environ['TALK_ENV'] = ''
 
+    def test_ProcessOpen_env_unspecified(self):
+        talkenv = ''
+
+        p = process.ProcessOpen(['printenv'])
+        output = p.stdout.read()
+
+        pattern = re.compile("TALK_ENV is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == talkenv,
+                        "%r != %r" % (match.group(1), talkenv))
+
+    def test_ProcessOpen_env_inherited(self):
+        talkenv = 'foo'
+        os.environ['TALK_ENV'] = 'foo'
+
+        p = process.ProcessOpen(['printenv'])
+        output = p.stdout.read()
+
+        pattern = re.compile("TALK_ENV is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == talkenv,
+                        "%r != %r" % (match.group(1), talkenv))
+
+        os.environ['TALK_ENV'] = ''
+
+    def test_ProcessOpen_env_specified(self):
+        talkenv = 'bar'
+        env = {'TALK_ENV': talkenv}
+
+        p = process.ProcessOpen(['printenv'], env=env)
+        output = p.stdout.read()
+
+        pattern = re.compile("TALK_ENV is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == talkenv,
+                        "%r != %r" % (match.group(1), talkenv))
+
+    def test_ProcessOpen_env_overridden(self):
+        os.environ['TALK_ENV'] = 'spam'
+        talkenv = 'eggs'
+        env = {'TALK_ENV': talkenv}
+
+        p = process.ProcessOpen(['printenv'], env=env)
+        output = p.stdout.read()
+
+        pattern = re.compile("TALK_ENV is '(.*?)'")
+        match = pattern.search(output)
+        self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                               "output=%r" % (pattern.pattern, output))
+        self.failUnless(match.group(1) == talkenv,
+                        "%r != %r" % (match.group(1), talkenv))
+
+        self.failUnless(os.environ['TALK_ENV'] == 'spam')
+        os.environ['TALK_ENV'] = ''
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#7 (text) ====

@@ -14,7 +14,7 @@
 
 
 class KillTestCase(unittest.TestCase):
-    def test_kill(self):
+    def test_ProcessProxy_kill(self):
         p = process.ProcessProxy(['hang'])
         time.sleep(2)
         p.kill()
@@ -25,7 +25,7 @@
             self.failUnless(os.WIFSIGNALED(retval))
             self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
 
-    def test_kill_twice(self):
+    def test_ProcessProxy_kill_twice(self):
         # Killing an already terminated process should not raise an
         # exception.
         p = process.ProcessProxy(['hang'])
@@ -40,7 +40,7 @@
         p.kill()
 
     if sys.platform.startswith("win"):
-        def test_kill_exitcode(self):
+        def test_ProcessProxy_kill_exitcode(self):
             p = process.ProcessProxy(['hang'])
             time.sleep(2)
             p.kill(42)
@@ -48,7 +48,7 @@
             self.failUnless(retval == 42)
 
     if not sys.platform.startswith("win"):
-        def test_kill_SIGKILL(self):
+        def test_ProcessProxy_kill_SIGKILL(self):
             p = process.ProcessProxy(['hang'])
             time.sleep(1)
             p.kill(sig=signal.SIGKILL)
@@ -68,7 +68,7 @@
         else:
             self._failedToKill = 0
 
-    def test_kill_from_parent_subthread(self):
+    def test_ProcessProxy_kill_from_parent_subthread(self):
         p = process.ProcessProxy(['hang'])
         t = threading.Thread(target=self._KillAndReturn,
                              kwargs={'child':p})
@@ -79,6 +79,71 @@
             self.fail("Could not kill the child process from a thread "\
                       "spawned by the parent *after* the child was spawn.\n")
 
+    def test_ProcessOpen_kill(self):
+        p = process.ProcessOpen(['hang'])
+        time.sleep(2)
+        p.kill()
+        retval = p.wait()
+        if sys.platform.startswith("win"):
+            self.failIf(retval)
+        else:
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+
+    def test_ProcessOpen_kill_twice(self):
+        # Killing an already terminated process should not raise an
+        # exception.
+        p = process.ProcessOpen(['hang'])
+        time.sleep(2)
+        p.kill()
+        retval = p.wait()
+        if sys.platform.startswith("win"):
+            self.failIf(retval)
+        else:
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+        p.kill()
+
+    if sys.platform.startswith("win"):
+        def test_ProcessOpen_kill_exitcode(self):
+            p = process.ProcessOpen(['hang'])
+            time.sleep(2)
+            p.kill(42)
+            retval = p.wait()
+            self.failUnless(retval == 42)
+
+    if not sys.platform.startswith("win"):
+        def test_ProcessOpen_kill_SIGKILL(self):
+            p = process.ProcessOpen(['hang'])
+            time.sleep(1)
+            p.kill(sig=signal.SIGKILL)
+            retval = p.wait()
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+
+        # XXX Could add tests for other signals but would have to launch an
+        #     app that would respond to those signals in a measurable way and
+        #     then terminate.
+
+    def _KillAndReturn(self, child):
+        try:
+            child.kill()
+        except OSError, ex:
+            self._failedToKill = 1
+        else:
+            self._failedToKill = 0
+
+    def test_ProcessOpen_kill_from_parent_subthread(self):
+        p = process.ProcessOpen(['hang'])
+        t = threading.Thread(target=self._KillAndReturn,
+                             kwargs={'child':p})
+        t.start()
+        p.wait()
+        t.join()
+        if self._failedToKill:
+            self.fail("Could not kill the child process from a thread "\
+                      "spawned by the parent *after* the child was spawn.\n")
+
 
 
 def suite():

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#5 (text) ====

@@ -20,38 +20,53 @@
             if exitStatus >= 2**7: exitStatus -= 2**8
             self.failUnless(exitStatus == expected)
 
-    def test_0(self):
+    def test_ProcessProxy_0(self):
         p = process.ProcessProxy(['quiet'])
         retval = p.wait()
         self._assertRetvalIs(0, retval)
 
-    def test_42(self):
+    def test_ProcessProxy_42(self):
         p = process.ProcessProxy(['quiet', '42'])
         retval = p.wait()
         self._assertRetvalIs(42, retval)
 
-    def test_minus_42(self):
+    def test_ProcessProxy_minus_42(self):
         p = process.ProcessProxy(['quiet', '-42'])
         retval = p.wait()
         self._assertRetvalIs(-42, retval)
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_0_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_0(self):
             p = process.ProcessProxyWithThreadFix(['quiet'])
             retval = p.wait()
             self._assertRetvalIs(0, retval)
 
-        def test_42_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_42(self):
             p = process.ProcessProxyWithThreadFix(['quiet', '42'])
             retval = p.wait()
             self._assertRetvalIs(42, retval)
 
-        def test_minus_42_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_minus_42(self):
             p = process.ProcessProxyWithThreadFix(['quiet', '-42'])
             retval = p.wait()
             self._assertRetvalIs(-42, retval)
 
+    def test_ProcessOpen_0(self):
+        p = process.ProcessOpen(['quiet'])
+        retval = p.wait()
+        self._assertRetvalIs(0, retval)
+
+    def test_ProcessOpen_42(self):
+        p = process.ProcessOpen(['quiet', '42'])
+        retval = p.wait()
+        self._assertRetvalIs(42, retval)
+
+    def test_ProcessOpen_minus_42(self):
+        p = process.ProcessOpen(['quiet', '-42'])
+        retval = p.wait()
+        self._assertRetvalIs(-42, retval)
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#9 (text) ====

@@ -46,7 +46,7 @@
         return output
 
 class StdinTestCase(unittest.TestCase):
-    def test_stdin_handle_cleanup_1(self):
+    def test_ProcessProxy_stdin_handle_cleanup_1(self):
         p1 = process.ProcessProxy(['ask'])
         p2 = process.ProcessProxy(['ask'])
         p1.stdin.write("Trent\n")
@@ -69,7 +69,7 @@
                         "Unexpected stdout output: %r" % output)
         p2.kill()
 
-    def test_stdin_handle_cleanup_2(self):
+    def test_ProcessProxy_stdin_handle_cleanup_2(self):
         p1 = process.ProcessProxy(['ask'])
         p2 = process.ProcessProxy(['ask'])
         p1.stdin.write("Trent\n")
@@ -87,7 +87,7 @@
 
         p2.kill()
 
-    def test_stdin_buffer(self):
+    def test_ProcessProxy_stdin_buffer(self):
         p = process.ProcessProxy(['ask'])
         p.stdin.write("Trent\n")
         p.stdin.close()
@@ -96,7 +96,7 @@
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
-    def test_stdin_buffer_nonewline(self):
+    def test_ProcessProxy_stdin_buffer_nonewline(self):
         p = process.ProcessProxy(['ask'])
         p.stdin.write("Tre")
         # Note that we have not sent a newline, so the scanf() (or
@@ -111,7 +111,7 @@
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
-    def test_stdin_donotrespond(self):
+    def test_ProcessProxy_stdin_donotrespond(self):
         p = process.ProcessProxy(['ask_then_talk'],
                             stdout=MyOutFile(), stderr=MyOutFile())
         # Expect this to hang, as the child waits for input that we do
@@ -129,14 +129,14 @@
 
     ## This is left commented out because the use of 'sys.stdin' requires
     ## user interaction -- not really an automated test suite then.
-    #def test_stdin_sysstdin(self):
+    #def test_ProcessProxy_stdin_sysstdin(self):
     #    p = process.ProcessProxy(['ask'], stdin=sys.stdin)
     #    output = p.stdout.read()
     #    expected = "What is your name?\nYour name is"
     #    self.failUnless(output.find(expected) != -1,
     #                    "Unexpected stdout output: %r" % output)
 
-    def test_stdin_text_mode(self):
+    def test_ProcessProxy_stdin_text_mode(self):
         # On Windows:
         #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
         #   but am currently using it because it reacts measurably
@@ -157,7 +157,7 @@
                         % (output, expected))
 
     if sys.platform.startswith("win"):
-        def test_stdin_binary_mode(self):
+        def test_ProcessProxy_stdin_binary_mode(self):
             # Expecting to get cygwin sort here. (XXX Should drop that dep.)
             p = process.ProcessProxy(['sort'], mode='b')
             p.stdin.write("2\n")
@@ -189,7 +189,7 @@
                             "Pipes are not doing text translation."\
                             % (output, expected))
 
-    def test_stdin_buffering_with_mystdin(self):
+    def test_ProcessProxy_stdin_buffering_with_mystdin(self):
         p = process.ProcessProxy(['ask'], stdin=MyInFile("Trent\n"),
                                  bufsize=0)
         output = p.stdout.read()
@@ -200,7 +200,7 @@
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_stdin_handle_cleanup_1_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_handle_cleanup_1(self):
             p1 = process.ProcessProxyWithThreadFix(['ask'])
             p2 = process.ProcessProxyWithThreadFix(['ask'])
             p1.stdin.write("Trent\n")
@@ -223,7 +223,7 @@
                             "Unexpected stdout output: %r" % output)
             p2.kill()
 
-        def test_stdin_handle_cleanup_2_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_handle_cleanup_2(self):
             p1 = process.ProcessProxyWithThreadFix(['ask'])
             p2 = process.ProcessProxyWithThreadFix(['ask'])
             p1.stdin.write("Trent\n")
@@ -241,7 +241,7 @@
 
             p2.kill()
 
-        def test_stdin_buffer_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_buffer(self):
             p = process.ProcessProxyWithThreadFix(['ask'])
             p.stdin.write("Trent\n")
             p.stdin.close()
@@ -250,7 +250,7 @@
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r" % output)
 
-        def test_stdin_buffer_nonewline_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_buffer_nonewline(self):
             p = process.ProcessProxyWithThreadFix(['ask'])
             p.stdin.write("Tre")
             # Note that we have not sent a newline, so the scanf() (or
@@ -265,7 +265,7 @@
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r" % output)
 
-        def test_stdin_donotrespond_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_donotrespond(self):
             p = process.ProcessProxyWithThreadFix(['ask_then_talk'],
                                 stdout=MyOutFile(), stderr=MyOutFile())
             # Expect this to hang, as the child waits for input that we do
@@ -283,14 +283,14 @@
 
         ## This is left commented out because the use of 'sys.stdin' requires
         ## user interaction -- not really an automated test suite then.
-        #def test_stdin_sysstdin_withthreadfix(self):
+        #def test_ProcessProxyWithThreadFix_stdin_sysstdin(self):
         #    p = process.ProcessProxyWithThreadFix(['ask'], stdin=sys.stdin)
         #    output = p.stdout.read()
         #    expected = "What is your name?\nYour name is"
         #    self.failUnless(output.find(expected) != -1,
         #                    "Unexpected stdout output: %r" % output)
 
-        def test_stdin_text_mode_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_text_mode(self):
             # On Windows:
             #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
             #   but am currently using it because it reacts measurably
@@ -310,7 +310,7 @@
                             "Pipes are not doing text translation."\
                             % (output, expected))
 
-        def test_stdin_buffering_with_mystdin_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdin_buffering_with_mystdin(self):
             p = process.ProcessProxyWithThreadFix(['ask'], stdin=MyInFile("Trent\n"),
                                      bufsize=0)
             output = p.stdout.read()
@@ -318,6 +318,125 @@
             self.failUnless(output == expected,
                             "Unexpected stdout output: %r" % output)
 
+    def test_ProcessOpen_stdin_handle_cleanup_1(self):
+        p1 = process.ProcessOpen(['ask'])
+        p2 = process.ProcessOpen(['ask'])
+        p1.stdin.write("Trent\n")
+        p2.stdin.write("Andrew\n")
+        p1.stdin.close()
+        p2.stdin.close()
+
+        p1.wait()
+        del p1
+        p2.wait()
+
+        p1 = process.ProcessOpen(['ask'])
+        p2 = process.ProcessOpen(['ask'])
+        p1.stdin.write("Mick\n")
+        p1.stdin.close()
+
+        output = p1.stdout.read()
+        if sys.platform.startswith("win"):
+            newl = '\r\n'
+        else:
+            newl = '\n'
+        expected = "What is your name?%sYour name is 'Mick'.%s" % (newl, newl)
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r" % output)
+        p2.kill()
+
+    def test_ProcessOpen_stdin_handle_cleanup_2(self):
+        p1 = process.ProcessOpen(['ask'])
+        p2 = process.ProcessOpen(['ask'])
+        p1.stdin.write("Trent\n")
+        p2.stdin.write("Andrew\n")
+        p1.stdin.close()
+        p2.stdin.close()
+
+        p1.wait()
+        p2.wait()
+
+        p1 = process.ProcessOpen(['ask'])
+        p2 = process.ProcessOpen(['ask'])
+        p1.stdin.write("Mick\n")
+        p1.stdin.close()
+
+        p2.kill()
+
+    def test_ProcessOpen_stdin_buffer(self):
+        p = process.ProcessOpen(['ask'])
+        p.stdin.write("Trent\n")
+        output = p.stdout.read()
+        if sys.platform.startswith("win"):
+            newl = '\r\n'
+        else:
+            newl = '\n'
+        expected = "What is your name?%sYour name is 'Trent'.%s" % (newl, newl)
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r" % output)
+
+    def test_ProcessOpen_stdin_buffer_nonewline(self):
+        p = process.ProcessOpen(['ask'])
+        p.stdin.write("Tre")
+        # Note that we have not sent a newline, so the scanf() (or
+        # fread() or whatever) in ask.exe is still waiting for input.
+        # This is testing that the subsequent p.stdin.close()
+        # successfully communicates to the child that the pipe is closed
+        # and no more data is forth coming. (This relies on the pipe
+        # inheritability having been properly set.)
+        p.stdin.close()
+        output = p.stdout.read()
+        if sys.platform.startswith("win"):
+            newl = '\r\n'
+        else:
+            newl = '\n'
+        expected = "What is your name?%sYour name is 'Tre'.%s" % (newl, newl)
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r" % output)
+
+    def test_ProcessOpen_stdin_donotrespond(self):
+        p = process.ProcessOpen('ask_then_talk')
+        # Expect this to hang, as the child waits for input that we do
+        # not send it.
+        time.sleep(2)
+        try:
+            output = p.stdout.read(4092)
+            self.failUnless(output.strip() == "What is your name?",
+                "Stdout has unexpectedly received other than one "\
+                "'What is your name?' write. The process should "\
+                "be hung. output=%r" % output)
+        finally:
+            p.kill()
+
+    ## This is left commented out because the use of 'sys.stdin' requires
+    ## user interaction -- not really an automated test suite then.
+    #def test_ProcessOpen_stdin_sysstdin(self):
+    #    p = process.ProcessOpen(['ask'], stdin=sys.stdin)
+    #    output = p.stdout.read()
+    #    expected = "What is your name?\nYour name is"
+    #    self.failUnless(output.find(expected) != -1,
+    #                    "Unexpected stdout output: %r" % output)
+
+    def test_ProcessOpen_stdin_text_mode(self):
+        # On Windows:
+        #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
+        #   but am currently using it because it reacts measurably
+        #   differently to lines with '\r\n' vs '\n' terminators.)
+        # On Linux:
+        #   There is no distinction btwn text- and binary-modes. So this
+        #   really is not providing that useful a test.
+        p = process.ProcessOpen(['sort'])
+        p.stdin.write("2\n")
+        p.stdin.write("1\n")
+        p.stdin.write("3\n")
+        p.stdin.close()
+        output = p.stdout.read()
+        expected = "1\n2\n3\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r (expected: %r). "\
+                        "Pipes are not doing text translation."\
+                        % (output, expected))
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#7 (text) ====

@@ -24,14 +24,14 @@
         return output
 
 class StdoutTestCase(unittest.TestCase):
-    def test_stdout_buffer(self):
+    def test_ProcessProxy_stdout_buffer(self):
         p = process.ProcessProxy(['talk'])
         output = p.stdout.read()
         self.failUnless(output == 'o0o1o2o3o4')
         error = p.stderr.read()
         self.failUnless(error == 'e0e1e2e3e4')
 
-    def test_my_stdout_with_buffered_child(self):
+    def test_ProcessProxy_my_stdout_with_buffered_child(self):
         p = process.ProcessProxy(['talk'], stdout=MyOutFile(),
                                  stderr=MyOutFile())
         p.wait()
@@ -51,7 +51,7 @@
         #    possibly at all. How does Cygwin's bash do it? or 4DOS?
         ## Ensure that the writes came in one about every second.
 
-    def test_my_stdout_with_unbuffered_child(self):
+    def test_ProcessProxy_my_stdout_with_unbuffered_child(self):
         p = process.ProcessProxy(['talk_setvbuf'], stdout=MyOutFile(),
                                  stderr=MyOutFile())
         p.wait()
@@ -68,14 +68,14 @@
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_stdout_buffer_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_stdout_buffer(self):
             p = process.ProcessProxyWithThreadFix(['talk'])
             output = p.stdout.read()
             self.failUnless(output == 'o0o1o2o3o4')
             error = p.stderr.read()
             self.failUnless(error == 'e0e1e2e3e4')
 
-        def test_my_stdout_with_buffered_child_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_my_stdout_with_buffered_child(self):
             p = process.ProcessProxyWithThreadFix(['talk'], stdout=MyOutFile(),
                                      stderr=MyOutFile())
             p.wait()
@@ -95,7 +95,7 @@
             #    possibly at all. How does Cygwin's bash do it? or 4DOS?
             ## Ensure that the writes came in one about every second.
 
-        def test_my_stdout_with_unbuffered_child_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_my_stdout_with_unbuffered_child(self):
             p = process.ProcessProxyWithThreadFix(['talk_setvbuf'], stdout=MyOutFile(),
                                      stderr=MyOutFile())
             p.wait()
@@ -110,6 +110,13 @@
                             "Write events were not spread over a few seconds."\
                             "timespan=%r" % timespan)
 
+    def test_ProcessOpen_read_all(self):
+        p = process.ProcessOpen(['talk'])
+        output = p.stdout.read()
+        self.failUnless(output == 'o0o1o2o3o4')
+        error = p.stderr.read()
+        self.failUnless(error == 'e0e1e2e3e4')
+
 
 
 def suite():

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#3 (text) ====

@@ -11,7 +11,7 @@
 
 
 class WaitTestCase(unittest.TestCase):
-    def test_wait(self):
+    def test_ProcessProxy_wait(self):
         before = time.time()
         p = process.ProcessProxy(['talk'])
         p.wait()
@@ -30,7 +30,7 @@
     if not sys.platform.startswith("linux"):
         # This is expected to fail on Linux -- hence
         # ProcessProxyWithThreadFix.
-        def test_wait_from_parent_subthread(self):
+        def test_ProcessProxy_wait_from_parent_subthread(self):
             before = time.time()
             p = process.ProcessProxy(['talk'])
             try:
@@ -49,21 +49,21 @@
 
     if sys.platform.startswith("linux"):
         # Run all tests with "ProcessProxyWithThreadFix" as well.
-        def test_wait_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_wait(self):
             before = time.time()
             p = process.ProcessProxyWithThreadFix(['talk'])
             p.wait()
             after = time.time()
             self.failUnless(4.0 < (after-before) < 10.0)
 
-        def test_no_wait_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_no_wait(self):
             # This tests whether ProcessProxyWithThreadFix() will cleanup and
             # terminate worker threads properly. If not, the test suite will
             # likely hang.
             before = time.time()
             p = process.ProcessProxyWithThreadFix(['talk'])
 
-        def test_wait_from_parent_subthread_withthreadfix(self):
+        def test_ProcessProxyWithThreadFix_wait_from_parent_subthread(self):
             before = time.time()
             p = process.ProcessProxyWithThreadFix(['talk'])
             try:
@@ -80,6 +80,33 @@
             finally:
                 p.kill()
 
+    def test_ProcessOpen_wait(self):
+        before = time.time()
+        p = process.ProcessOpen(['talk'])
+        p.wait()
+        after = time.time()
+        self.failUnless(4.0 < (after-before) < 10.0)
+
+    if not sys.platform.startswith("linux"):
+        # This is expected to fail on Linux -- hence should write
+        # ProcessOpenWithThreadFix.
+        def test_ProcessOpen_wait_from_parent_subthread(self):
+            before = time.time()
+            p = process.ProcessOpen(['talk'])
+            try:
+                t = threading.Thread(target=self._WaitAndReturn,
+                                     kwargs={'child':p})
+                t.start()
+                t.join()
+                after = time.time()
+                if self._hitLinuxThreadsBug:
+                    self.fail("Hit known bug in Linux threads: cannot wait "\
+                              "on a process from a different thread from "\
+                              "which it was spawned.")
+                self.failUnless(4.0 < (after-before) < 10.0)
+            finally:
+                p.kill()
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
Change 43236 by davida@davida-newloom on 2002/07/17 10:50:18

	Modifying an uninitialized variable bug.
	r=trentm

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#24 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#24 (text) ====

@@ -312,6 +312,7 @@
             raise ProcessError("You must specify a command.")
         self._cwd = cwd
         self._env = env
+        self._flags = flags
         if sys.platform.startswith("win"):
             self._flags |= win32process.CREATE_NEW_PROCESS_GROUP
 
Change 43049 by trentm@trentm-razor on 2002/07/12 14:09:02

	Make the necessary change to have process.py pass the new requirement that
	kill's on terminated processes not be an error.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#23 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#23 (text) ====

@@ -480,6 +480,11 @@
                 log.warn("The win32api module does not have "\
                          "GenerateConsoleCtrlEvent(). This may mean that "\
                          "parts of this process group have NOT been killed.")
+            except win32api.error, ex:
+                if ex.args[0] != 87:
+                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
+                    #                     'The parameter is incorrect.')
+                    raise
 
         else:
             if sig is None:
@@ -970,6 +975,11 @@
                 log.warn("The win32api module does not have "\
                          "GenerateConsoleCtrlEvent(). This may mean that "\
                          "parts of this process group have NOT been killed.")
+            except win32api.error, ex:
+                if ex.args[0] != 87:
+                    # Ignore: api_error: (87, 'GenerateConsoleCtrlEvent',
+                    #                     'The parameter is incorrect.')
+                    raise
 
         else:
             if sig is None:
Change 43048 by trentm@trentm-swatter on 2002/07/12 14:02:04

	Create the ProcessProxyWithThreadFix object on Linux. This is a subclass of
	ProcessProxy that works around the Linux threads problem where by one
	cannot wait on a process from a thread other than the one that created it.
	One can now. This is done by creating the child process in a "__waiter"
	thread that proxy's .wait() calls from other threads. Extend the test suite
	to test this waiting from another thread directly and also test
	ProcessProxyWithThreadFix with everything that we were testing ProcessProxy
	before.
	
	Also, some minor doc tweaks and change the semantics of .kill() such that
	killing a process that has already terminated is not an error.
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#22 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#8 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#2 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#22 (text) ====

@@ -175,6 +175,7 @@
 # Loggers:
 #   - 'log' to log normal process handling
 #   - 'logres' to track system resource life
+#   - 'logfix' to track wait/kill proxying in ProcessProxyWithThreadFix
 if 1:   # normal/production usage
     log = Logger("process", Logger.WARN)
 else:   # development/debugging usage
@@ -183,6 +184,10 @@
     logres = Logger("process.res", Logger.WARN)
 else:   # development/debugging usage
     logres = Logger("process.res", Logger.DEBUG, sys.stdout)
+if 1:   # normal/production usage
+    logfix = Logger("process.waitfix", Logger.WARN)
+else:   # development/debugging usage
+    logfix = Logger("process.waitfix", Logger.DEBUG, sys.stdout)
 
 
 
@@ -390,8 +395,7 @@
         """Wait for the started process to complete.
         
         "timeout" (on Windows) is a floating point number of seconds after
-            which to timeout.
-            Default is win32event.INIFINITE.
+            which to timeout.  Default is win32event.INFINITE.
         "timeout" (on Unix) is akin to the os.waitpid() "options" argument
             (os.WNOHANG may be used to return immediately if the process has
             not exited). Default is 0, i.e. wait forever.
@@ -480,7 +484,12 @@
         else:
             if sig is None:
                 sig = signal.SIGKILL
-            os.kill(self._pid, sig)
+            try:
+                os.kill(self._pid, sig)
+            except OSError, ex:
+                if ex.errno != 3:
+                    # Ignore:   OSError: [Errno 3] No such process
+                    raise
 
     def _close_(self, hwnd, dummy):
         """Callback used by .kill() on Windows.
@@ -598,6 +607,7 @@
             self.stderr = IOBuffer(name='<stderr>')
         else:
             self.stderr = stderr
+        self._closed = 0
 
         if sys.platform.startswith("win"):
             self._startOnWindows()
@@ -607,36 +617,57 @@
         _registerProcess(self)
 
     def __del__(self):
-        self.__log.info("[%s] ProcessProxy.__del__()" % id(self))
+        #XXX Should probably not rely upon this.
+        self.close()
+
+    def close(self):
+        if not self._closed:
+            self.__log.info("[%s] ProcessProxy.close()" % id(self))
+
+            # Ensure that all IOBuffer's are closed. If they are not, these
+            # can cause hangs. 
+            self.__log.info("[%s] ProcessProxy: closing stdin (%r)."\
+                            % (id(self), self.stdin))
+            try:
+                self.stdin.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+            self.__log.info("[%s] ProcessProxy: closing stdout (%r)."\
+                            % (id(self), self.stdout))
+            try:
+                self.stdout.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+            self.__log.info("[%s] ProcessProxy: closing stderr (%r)."\
+                            % (id(self), self.stderr))
+            try:
+                self.stderr.close()
+            except AttributeError:
+                # May not have gotten far enough in the __init__ to set
+                # self.stdin, etc.
+                pass
+
+            del self.__log # drop reference
+            self._closed = 1
 
-        # Ensure that all IOBuffer's are closed. If they are not, these
-        # can cause hangs. 
-        self.__log.info("[%s] ProcessProxy: closing stdin (%r)."\
-                        % (id(self), self.stdin))
-        try:
-            self.stdin.close()
-        except AttributeError:
-            # May not have gotten far enough in the __init__ to set
-            # self.stdin, etc.
-            pass
-        self.__log.info("[%s] ProcessProxy: closing stdout (%r)."\
-                        % (id(self), self.stdout))
-        try:
-            self.stdout.close()
-        except AttributeError:
-            # May not have gotten far enough in the __init__ to set
-            # self.stdin, etc.
-            pass
-        self.__log.info("[%s] ProcessProxy: closing stderr (%r)."\
-                        % (id(self), self.stderr))
-        try:
-            self.stderr.close()
-        except AttributeError:
-            # May not have gotten far enough in the __init__ to set
-            # self.stdin, etc.
-            pass
+    def _forkAndExecChildOnUnix(self, fdChildStdinRd, fdChildStdoutWr,
+                                fdChildStderrWr):
+        """Fork and start the child process.
 
-        del self.__log # drop reference
+        Returns the child pid.
+        """
+        pid = os.fork()
+        if pid == 0: # child
+            os.dup2(fdChildStdinRd, 0)
+            os.dup2(fdChildStdoutWr, 1)
+            os.dup2(fdChildStderrWr, 2)
+            self._runChildOnUnix()
+        # parent
+        return pid
 
     def _startOnUnix(self):
         # Create pipes for std handles.
@@ -650,13 +681,8 @@
                 os.chdir(self._cwd)
             except OSError, ex:
                 raise ProcessError(msg=str(ex), errno=ex.errno)
-        self._pid = os.fork()
-        if self._pid == 0: # child
-            os.dup2(fdChildStdinRd, 0)
-            os.dup2(fdChildStdoutWr, 1)
-            os.dup2(fdChildStderrWr, 2)
-            self._runChildOnUnix()
-        # parent
+        self._pid = self._forkAndExecChildOnUnix(fdChildStdinRd,
+            fdChildStdoutWr, fdChildStderrWr)
         if self._cwd:
             os.chdir(oldDir)
 
@@ -685,7 +711,7 @@
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
         stdoutProxy = OutFileProxy(childStdout, self.stdout, 
-                                   self.stdin, childStdin,
+                                   [self.stdin, childStdin, self],
                                    name='<stdout>')
         stdoutProxy.start()
         stderrProxy = OutFileProxy(childStderr, self.stderr,
@@ -847,7 +873,7 @@
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
         stdoutProxy = OutFileProxy(childStdout, self.stdout, 
-                                   self.stdin, childStdin,
+                                   [self.stdin, childStdin, self],
                                    name='<stdout>')
         stdoutProxy.start()
         stderrProxy = OutFileProxy(childStderr, self.stderr,
@@ -858,8 +884,7 @@
         """Wait for the started process to complete.
         
         "timeout" (on Windows) is a floating point number of seconds after
-            which to timeout.
-            Default is win32event.INIFINITE.
+            which to timeout.  Default is win32event.INFINITE.
         "timeout" (on Unix) is akin to the os.waitpid() "options" argument
             (os.WNOHANG may be used to return immediately if the process has
             not exited). Default is 0, i.e. wait forever.
@@ -949,7 +974,12 @@
         else:
             if sig is None:
                 sig = signal.SIGKILL
-            os.kill(self._pid, sig)
+            try:
+                os.kill(self._pid, sig)
+            except OSError, ex:
+                if ex.errno != 3:
+                    # Ignore:   OSError: [Errno 3] No such process
+                    raise
 
         _unregisterProcess(self)
 
@@ -1244,23 +1274,20 @@
     """A thread to watch an "out" file from the spawned child process
     and pass on write's to the parent.
     """
-    def __init__(self, fChild, fParent, fToCleanRd=None, fToCleanWr=None,
-                 name=None):
+    def __init__(self, fChild, fParent, toClose=[], name=None):
         """
         "fChild" is a Win32 handle to the a child process' output pipe.
         "fParent" is a Python file-like object setup for writing.
-        "fToCleanRd"  and "fToCleanWr" are file-like objects to clean up
-            on close of this proxy.
+        "toClose" is a list of objects on which to call .close when this
+            proxy is terminating.
         "name" can be set for debugging, it will be used in log messages.
         """
         log.info("[%s] OutFileProxy.__init__(fChild=%r, fParent=%r, "\
-                 "fToCleanRd=%r, fToCleanWr=%r)", name, fChild, fParent,
-                 fToCleanRd, fToCleanWr)
+                 "toClose=%r)", name, fChild, fParent, toClose)
         threading.Thread.__init__(self, name=name)
         self.fChild = fChild
         self.fParent = fParent
-        self.fToCleanRd = fToCleanRd
-        self.fToCleanWr = fToCleanWr
+        self.toClose = toClose
 
     def run(self):
         log.info("[%s] OutFileProxy: start" % self.getName())
@@ -1279,35 +1306,11 @@
                 self.fParent.close()
             except IOError:
                 pass # Ignore: IOError: [Errno 4] Interrupted system call
-            #XXX Are these both necessary?
-            # XXX *One* of self.fToClean*.write('') and .close()
-            #     seems to be necessary for the current test suite.
-            #     Which one is appropriate? The latter seems more
-            #     so, but that is just a shallow guess.
-            # XXX Doing this relieves the
-            #     must-<Enter>-to-term-test_stdin_sysstdin problem
-            #     but I don't think it is the right thing to do.
-            #     Over my head. Update: This does not seem to effect
-            #     the result of this test anymore. That test also
-            #     now requires *two* manual EOF's to finish. ???
-            if self.fToCleanRd:
-                # Necessary to notify, and possibly unwedge, the
-                # process' stdin object (either an IOBuffer, or a user
-                # supplied object).
-                logres.info("[%s] OutFileProxy: closing additional file "\
-                            "after closing parent: %r", self.getName(),
-                            self.fToCleanRd)
+            for item in self.toClose:
+                logres.info("[%s] OutFileProxy: closing %r after "\
+                            "closing parent", self.getName(), item)
                 try:
-                    self.fToCleanRd.close()
-                except IOError:
-                    pass # Ignore: IOError: [Errno 4] Interrupted system call
-
-            if self.fToCleanWr:
-                logres.info("[%s] OutFileProxy: closing additional file "\
-                            "after closing parent: %r", self.getName(),
-                            self.fToCleanWr)
-                try:
-                    self.fToCleanWr.close()
+                    item.close()
                 except IOError:
                     pass # Ignore: IOError: [Errno 4] Interrupted system call
         log.info("[%s] OutFileProxy: done" % self.getName())
@@ -1344,3 +1347,129 @@
             self.fParent.write(text)
 
 
+
+if sys.platform.startswith("linux"):
+    import Queue
+
+    class ProcessProxyWithThreadFix(ProcessProxy):
+        """Present the same semantics as ProcessProxy but try to work around
+        the known LinuxThreads bug where one cannot .wait() on a created
+        process from a subthread of the thread that created the process.
+        """
+        def __init__(self, *args, **kwargs):
+            self.__pid = None
+            self.__pidReady = threading.Condition()
+            self.__requestResult = None
+            self.__requestFinished = threading.Condition()
+            self.__requests = Queue.Queue()
+            self.__terminated = 0
+            self.__exitStatus = None
+            self.__waiter = None
+            ProcessProxy.__init__(self, *args, **kwargs)
+
+        def _forkAndExecChildOnUnix(self, *args, **kwargs):
+            """Fork and start the child process do it in a special subthread
+            that will negotiate subsequent .wait()'s.
+
+            Returns the child pid.
+            """
+            self.__waiter = threading.Thread(
+                target=self.__launchAndWait, args=args, kwargs=kwargs)
+
+            # Start subthread which will launch child. Wait for the child to
+            # be launched then return the child's pid.
+            self.__waiter.start()
+            self.__pidReady.acquire()
+            self.__pidReady.wait()  #XXX What if .notify() happens first?
+            self.__pidReady.release()
+            return self.__pid
+
+        def close(self):
+            logfix.info("request waiter stop from thread %s",
+                        threading.currentThread().getName())
+            self.__requests.put( ("stop",) )
+            if self.__waiter:
+                self.__waiter.join()
+            ProcessProxy.close(self)
+
+        def __launchAndWait(self, fdChildStdinRd, fdChildStdoutWr,
+                            fdChildStderrWr):
+            logfix.info("start child in thread %s",
+                        threading.currentThread().getName())
+            pid = os.fork()
+            if pid == 0: # child
+                os.dup2(fdChildStdinRd, 0)
+                os.dup2(fdChildStdoutWr, 1)
+                os.dup2(fdChildStderrWr, 2)
+                self._runChildOnUnix()
+            # parent
+
+            # Pass the PID back to the main thread.
+            self.__pid = pid
+            self.__pidReady.acquire()
+            self.__pidReady.notifyAll()
+            self.__pidReady.release()
+
+            # Process requests until done.
+            while 1:
+                request = self.__requests.get()
+                logfix.info("waiter: '%s' request", request[0])
+                if request[0] == "wait":
+                    try:
+                        self.__requestResult =\
+                            ProcessProxy.wait(self, timeout=request[1])
+                        self.__terminated = 1
+                        self.__exitStatus = self.__requestResult
+                    except Exception, ex:
+                        self.__requestResult = ex
+                    logfix.info("waiter: wait for process: result=%r",
+                                self.__requestResult)
+                    self.__requestFinished.acquire()
+                    self.__requestFinished.notify()
+                    self.__requestFinished.release()
+                elif request[0] == "stop":
+                    self.__terminated = 1
+
+                if self.__terminated:
+                    # No need to proxy .wait() and .kill() requests if the
+                    # process is done.
+                    if self.__exitStatus is None:
+                        self.__exitStatus = ProcessProxy.wait(self, os.WNOHANG)
+                    logfix.info("waiter: process terminated, exiting, sts=%s",
+                                self.__exitStatus)
+                    break
+
+            # Now that the process is terminated, no new requests
+            # will come to this thread, but still need to exhaust the
+            # current Queue of requests.
+            while 1:
+                try:
+                    request = self.__requests.get_nowait()
+                except Queue.Empty:
+                    break
+                logfix.info("waiter: cleaning out '%s' request after "\
+                            "termination", request[0])
+                if request[0] == "wait":
+                    self.__requestResult = self.__exitStatus
+                    self.__requestFinished.acquire()
+                    self.__requestFinished.notify()
+                    self.__requestFinished.release()
+                elif request[0] == "stop":
+                    pass
+
+        def wait(self, timeout=None): 
+            if self.__terminated:
+                return self.__exitStatus
+            else:
+                logfix.info("request wait from thread %s",
+                            threading.currentThread().getName())
+                self.__requestFinished.acquire()
+                self.__requests.put( ('wait', timeout) )
+                self.__requestFinished.wait()
+                self.__requestFinished.release()
+
+                if isinstance(self.__requestResult, Exception):
+                    raise self.__requestResult
+                else:
+                    return self.__requestResult
+

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#2 (text) ====

@@ -21,6 +21,18 @@
         output = p.stdout.read()
         self.failUnless(output.strip() == 'hi "there"')
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_simple_cmd_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix('echo hi there')
+            output = p.stdout.read()
+            self.failUnless(output.strip() == 'hi there')
+
+        def test_cmd_with_quotes_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix('echo hi "there"')
+            output = p.stdout.read()
+            self.failUnless(output.strip() == 'hi "there"')
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#7 (text) ====

@@ -74,6 +74,71 @@
     
         testsupport.rmtree(wd)
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_cwd_notspecified_withthreadfix(self):
+            cwd = os.getcwd()
+
+            p = process.ProcessProxyWithThreadFix(['printcwd'])
+            output = p.stdout.read()
+
+            pattern = re.compile("CWD is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == cwd,
+                            "%r != %r" % (match.group(1), cwd))
+
+        def test_cwd_specified_withthreadfix(self):
+            wd = os.path.expanduser('~')
+
+            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
+            output = p.stdout.read()
+
+            pattern = re.compile("CWD is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == wd,
+                            "%r != %r" % (match.group(1), wd))
+
+        def test_cwd_specified_doesnotexist_withthreadfix(self):
+            wd = "foobar"
+            self.failUnlessRaises(process.ProcessError, process.ProcessProxyWithThreadFix,
+                                  cmd=['printcwd'], cwd=wd)
+
+        def test_cwd_specified_relative(self):
+            wd = "mytmprelativedir"
+            testsupport.mkdir(wd)
+
+            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
+            output = p.stdout.read()
+
+            pattern = re.compile("CWD is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == os.path.abspath(wd),
+                            "%r != %r" % (match.group(1), os.path.abspath(wd)))
+        
+            testsupport.rmtree(wd)
+
+        def test_cwd_specified_withspaces_withthreadfix(self):
+            wd = "my tmp relative dir with spaces"
+            testsupport.mkdir(wd)
+
+            p = process.ProcessProxyWithThreadFix(['printcwd'], cwd=wd)
+            output = p.stdout.read()
+
+            pattern = re.compile("CWD is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printcwd' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == os.path.abspath(wd),
+                            "%r != %r" % (match.group(1), os.path.abspath(wd)))
+        
+            testsupport.rmtree(wd)
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#4 (text) ====

@@ -72,6 +72,69 @@
         self.failUnless(os.environ['TALK_ENV'] == 'spam')
         os.environ['TALK_ENV'] = ''
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_env_unspecified_withthreadfix(self):
+            talkenv = ''
+
+            p = process.ProcessProxy(['printenv'])
+            output = p.stdout.read()
+
+            pattern = re.compile("TALK_ENV is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == talkenv,
+                            "%r != %r" % (match.group(1), talkenv))
+
+        def test_env_inherited_withthreadfix(self):
+            talkenv = 'foo'
+            os.environ['TALK_ENV'] = 'foo'
+
+            p = process.ProcessProxy(['printenv'])
+            output = p.stdout.read()
+
+            pattern = re.compile("TALK_ENV is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == talkenv,
+                            "%r != %r" % (match.group(1), talkenv))
+
+            os.environ['TALK_ENV'] = ''
+
+        def test_env_specified_withthreadfix(self):
+            talkenv = 'bar'
+            env = {'TALK_ENV': talkenv}
+
+            p = process.ProcessProxy(['printenv'], env=env)
+            output = p.stdout.read()
+
+            pattern = re.compile("TALK_ENV is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == talkenv,
+                            "%r != %r" % (match.group(1), talkenv))
+
+        def test_env_overridden_withthreadfix(self):
+            os.environ['TALK_ENV'] = 'spam'
+            talkenv = 'eggs'
+            env = {'TALK_ENV': talkenv}
+
+            p = process.ProcessProxy(['printenv'], env=env)
+            output = p.stdout.read()
+
+            pattern = re.compile("TALK_ENV is '(.*?)'")
+            match = pattern.search(output)
+            self.failUnless(match, "Could not find '%s' in 'printenv' output: "\
+                                   "output=%r" % (pattern.pattern, output))
+            self.failUnless(match.group(1) == talkenv,
+                            "%r != %r" % (match.group(1), talkenv))
+
+            self.failUnless(os.environ['TALK_ENV'] == 'spam')
+            os.environ['TALK_ENV'] = ''
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#6 (text) ====

@@ -5,6 +5,7 @@
 import time
 import pprint
 import unittest
+import threading
 
 if not sys.platform.startswith("win"):
     import signal
@@ -24,6 +25,20 @@
             self.failUnless(os.WIFSIGNALED(retval))
             self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
 
+    def test_kill_twice(self):
+        # Killing an already terminated process should not raise an
+        # exception.
+        p = process.ProcessProxy(['hang'])
+        time.sleep(2)
+        p.kill()
+        retval = p.wait()
+        if sys.platform.startswith("win"):
+            self.failIf(retval)
+        else:
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+        p.kill()
+
     if sys.platform.startswith("win"):
         def test_kill_exitcode(self):
             p = process.ProcessProxy(['hang'])
@@ -45,6 +60,26 @@
         #     app that would respond to those signals in a measurable way and
         #     then terminate.
 
+    def _KillAndReturn(self, child):
+        try:
+            child.kill()
+        except OSError, ex:
+            self._failedToKill = 1
+        else:
+            self._failedToKill = 0
+
+    def test_kill_from_parent_subthread(self):
+        p = process.ProcessProxy(['hang'])
+        t = threading.Thread(target=self._KillAndReturn,
+                             kwargs={'child':p})
+        t.start()
+        p.wait()
+        t.join()
+        if self._failedToKill:
+            self.fail("Could not kill the child process from a thread "\
+                      "spawned by the parent *after* the child was spawn.\n")
+
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#4 (text) ====

@@ -35,6 +35,24 @@
         retval = p.wait()
         self._assertRetvalIs(-42, retval)
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_0_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['quiet'])
+            retval = p.wait()
+            self._assertRetvalIs(0, retval)
+
+        def test_42_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['quiet', '42'])
+            retval = p.wait()
+            self._assertRetvalIs(42, retval)
+
+        def test_minus_42_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['quiet', '-42'])
+            retval = p.wait()
+            self._assertRetvalIs(-42, retval)
+
+
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
     return unittest.makeSuite(RetvalTestCase)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#8 (text) ====

@@ -198,6 +198,126 @@
                         "Unexpected stdout output: %r" % output)
 
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_stdin_handle_cleanup_1_withthreadfix(self):
+            p1 = process.ProcessProxyWithThreadFix(['ask'])
+            p2 = process.ProcessProxyWithThreadFix(['ask'])
+            p1.stdin.write("Trent\n")
+            p2.stdin.write("Andrew\n")
+            p1.stdin.close()
+            p2.stdin.close()
+
+            p1.wait()
+            del p1
+            p2.wait()
+
+            p1 = process.ProcessProxyWithThreadFix(['ask'])
+            p2 = process.ProcessProxyWithThreadFix(['ask'])
+            p1.stdin.write("Mick\n")
+            p1.stdin.close()
+
+            output = p1.stdout.read()
+            expected = "What is your name?\nYour name is 'Mick'.\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r" % output)
+            p2.kill()
+
+        def test_stdin_handle_cleanup_2_withthreadfix(self):
+            p1 = process.ProcessProxyWithThreadFix(['ask'])
+            p2 = process.ProcessProxyWithThreadFix(['ask'])
+            p1.stdin.write("Trent\n")
+            p2.stdin.write("Andrew\n")
+            p1.stdin.close()
+            p2.stdin.close()
+
+            p1.wait()
+            p2.wait()
+
+            p1 = process.ProcessProxyWithThreadFix(['ask'])
+            p2 = process.ProcessProxyWithThreadFix(['ask'])
+            p1.stdin.write("Mick\n")
+            p1.stdin.close()
+
+            p2.kill()
+
+        def test_stdin_buffer_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['ask'])
+            p.stdin.write("Trent\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "What is your name?\nYour name is 'Trent'.\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r" % output)
+
+        def test_stdin_buffer_nonewline_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['ask'])
+            p.stdin.write("Tre")
+            # Note that we have not sent a newline, so the scanf() (or
+            # fread() or whatever) in ask.exe is still waiting for input.
+            # This is testing that the subsequent p.stdin.close()
+            # successfully communicates to the child that the pipe is closed
+            # and no more data is forth coming. (This relies on the pipe
+            # inheritability having been properly set.)
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "What is your name?\nYour name is 'Tre'.\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r" % output)
+
+        def test_stdin_donotrespond_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['ask_then_talk'],
+                                stdout=MyOutFile(), stderr=MyOutFile())
+            # Expect this to hang, as the child waits for input that we do
+            # not send it.
+            time.sleep(6)
+            # There should be no output, other that
+            output = ''.join([item[2] for item in p.stdout.log])
+            try:
+                self.failUnless(output == "What is your name?\n",
+                    "Stdout has unexpectedly received other than one "\
+                    "'What is your name?' write. The process should "\
+                    "be hung. log=%r" % p.stdout.log)
+            finally:
+                p.kill()
+
+        ## This is left commented out because the use of 'sys.stdin' requires
+        ## user interaction -- not really an automated test suite then.
+        #def test_stdin_sysstdin_withthreadfix(self):
+        #    p = process.ProcessProxyWithThreadFix(['ask'], stdin=sys.stdin)
+        #    output = p.stdout.read()
+        #    expected = "What is your name?\nYour name is"
+        #    self.failUnless(output.find(expected) != -1,
+        #                    "Unexpected stdout output: %r" % output)
+
+        def test_stdin_text_mode_withthreadfix(self):
+            # On Windows:
+            #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
+            #   but am currently using it because it reacts measurably
+            #   differently to lines with '\r\n' vs '\n' terminators.)
+            # On Linux:
+            #   There is no distinction btwn text- and binary-modes. So this
+            #   really is not providing that useful a test.
+            p = process.ProcessProxyWithThreadFix(['sort'])
+            p.stdin.write("2\n")
+            p.stdin.write("1\n")
+            p.stdin.write("3\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "1\n2\n3\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r (expected: %r). "\
+                            "Pipes are not doing text translation."\
+                            % (output, expected))
+
+        def test_stdin_buffering_with_mystdin_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['ask'], stdin=MyInFile("Trent\n"),
+                                     bufsize=0)
+            output = p.stdout.read()
+            expected = "What is your name?\nYour name is 'Trent'.\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r" % output)
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#6 (text) ====

@@ -66,6 +66,52 @@
                         "Write events were not spread over a few seconds."\
                         "timespan=%r" % timespan)
 
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_stdout_buffer_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['talk'])
+            output = p.stdout.read()
+            self.failUnless(output == 'o0o1o2o3o4')
+            error = p.stderr.read()
+            self.failUnless(error == 'e0e1e2e3e4')
+
+        def test_my_stdout_with_buffered_child_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['talk'], stdout=MyOutFile(),
+                                     stderr=MyOutFile())
+            p.wait()
+            self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
+            self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
+
+            #XXX Cannot test this part until the setvbuf work is done to
+            #    make the child pipes unbuffered. Update: even with the
+            #    setvbuf calls (done via os.fdopen(..., bufsize=0)) stdout
+            #    and stderr do *not* seem to be unbuffered. It *does* make a
+            #    difference for stdin though. Perhaps setvbuf can only be
+            #    used to affect *write* end of pipe, i.e. we cannot affect
+            #    what the child side of stdout/stderr will do. I suspect
+            #    that the only way to get this to work is to get the parent
+            #    side of stdout (and possibly stderr) to look like a tty.
+            #    This might require platform-specific hack, if it is indeed
+            #    possibly at all. How does Cygwin's bash do it? or 4DOS?
+            ## Ensure that the writes came in one about every second.
+
+        def test_my_stdout_with_unbuffered_child_withthreadfix(self):
+            p = process.ProcessProxyWithThreadFix(['talk_setvbuf'], stdout=MyOutFile(),
+                                     stderr=MyOutFile())
+            p.wait()
+            self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
+            self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
+
+            # Ensure that the writes are spread over about 5 seconds.
+            writeEvents = [e for e in p.stdout.log if e[1] == 'write']
+            timespan = writeEvents[-1][0] - writeEvents[0][0]
+            epsilon = 1.0
+            self.failUnless(timespan > epsilon,
+                            "Write events were not spread over a few seconds."\
+                            "timespan=%r" % timespan)
+
+
+
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
     return unittest.makeSuite(StdoutTestCase)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_wait.py#2 (text) ====

@@ -19,6 +19,7 @@
         self.failUnless(4.0 < (after-before) < 10.0)
 
     def _WaitAndReturn(self, child):
+        self._hitLinuxThreadsBug = 0
         try:
             child.wait()
         except OSError, ex:
@@ -26,22 +27,58 @@
         else:
             self._hitLinuxThreadsBug = 0
 
-    def test_wait_from_parent_subthread(self):
-        before = time.time()
-        p = process.ProcessProxy(['talk'])
-        try:
-            t = threading.Thread(target=self._WaitAndReturn,
-                                 kwargs={'child':p})
-            t.start()
-            t.join()
+    if not sys.platform.startswith("linux"):
+        # This is expected to fail on Linux -- hence
+        # ProcessProxyWithThreadFix.
+        def test_wait_from_parent_subthread(self):
+            before = time.time()
+            p = process.ProcessProxy(['talk'])
+            try:
+                t = threading.Thread(target=self._WaitAndReturn,
+                                     kwargs={'child':p})
+                t.start()
+                t.join()
+                after = time.time()
+                if self._hitLinuxThreadsBug:
+                    self.fail("Hit known bug in Linux threads: cannot wait "\
+                              "on a process from a different thread from "\
+                              "which it was spawned.")
+                self.failUnless(4.0 < (after-before) < 10.0)
+            finally:
+                p.kill()
+
+    if sys.platform.startswith("linux"):
+        # Run all tests with "ProcessProxyWithThreadFix" as well.
+        def test_wait_withthreadfix(self):
+            before = time.time()
+            p = process.ProcessProxyWithThreadFix(['talk'])
+            p.wait()
             after = time.time()
-            if self._hitLinuxThreadsBug:
-                self.fail("Hit known bug in Linux threads: cannot wait on a "\
-                          "process from a different thread from which it was "\
-                          "spawned.")
             self.failUnless(4.0 < (after-before) < 10.0)
-        finally:
-            p.kill()
+
+        def test_no_wait_withthreadfix(self):
+            # This tests whether ProcessProxyWithThreadFix() will cleanup and
+            # terminate worker threads properly. If not, the test suite will
+            # likely hang.
+            before = time.time()
+            p = process.ProcessProxyWithThreadFix(['talk'])
+
+        def test_wait_from_parent_subthread_withthreadfix(self):
+            before = time.time()
+            p = process.ProcessProxyWithThreadFix(['talk'])
+            try:
+                t = threading.Thread(target=self._WaitAndReturn,
+                                     kwargs={'child':p})
+                t.start()
+                t.join()
+                after = time.time()
+                if self._hitLinuxThreadsBug:
+                    self.fail("Hit known bug in Linux threads: cannot wait "\
+                              "on a process from a different thread from "\
+                              "which it was spawned.")
+                self.failUnless(4.0 < (after-before) < 10.0)
+            finally:
+                p.kill()
 
 
 def suite():
Change 42953 by trentm@trentm-razor on 2002/07/11 10:03:19

	The port to Linux borke this on Windows. Fix that.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#21 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#21 (text) ====

@@ -437,7 +437,7 @@
                                    self.WAIT_TIMEOUT)
         return retval
 
-    def kill(self, exitCode=0, gracePeriod=1.0, sig=signal.SIGKILL):
+    def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
         """Kill process.
         
         "exitCode" (Windows only) is the code the terminated process should
@@ -478,6 +478,8 @@
                          "parts of this process group have NOT been killed.")
 
         else:
+            if sig is None:
+                sig = signal.SIGKILL
             os.kill(self._pid, sig)
 
     def _close_(self, hwnd, dummy):
@@ -793,7 +795,7 @@
             elif win32api.GetVersion() < 0x80000000L and\
                  os.path.basename(comspec).lower() != "command.com":
                 # NT/2000 and not using command.com.
-                cmd = comspec + " /c " + self._cmd
+                cmd = comspec + " /c " + cmd
             else:
                 # Oh gag, we're on Win9x or using COMMAND.COM. Use the
                 # workaround listed in KB: Q150956
@@ -810,7 +812,7 @@
                             "Can not locate 'w9xpopen.exe' which is needed "\
                             "for ProcessProxy to work with your shell or "\
                             "platform.")
-                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, self._cmd)
+                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, cmd)
             log.debug("cmd = %r", cmd)
 
             creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
@@ -904,7 +906,7 @@
         _unregisterProcess(self)
         return retval
 
-    def kill(self, exitCode=0, gracePeriod=1.0, sig=signal.SIGKILL):
+    def kill(self, exitCode=0, gracePeriod=1.0, sig=None):
         """Kill process.
         
         "exitCode" (Windows only) is the code the terminated process should
@@ -945,6 +947,8 @@
                          "parts of this process group have NOT been killed.")
 
         else:
+            if sig is None:
+                sig = signal.SIGKILL
             os.kill(self._pid, sig)
 
         _unregisterProcess(self)
Change 42939 by trentm@trentm-swatter on 2002/07/10 17:33:49

	Get process.py to run and pass the test suite on Linux.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#20 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#7 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#20 (text) ====

@@ -104,15 +104,18 @@
 import threading
 import types
 import pprint 
-import msvcrt
-import win32api
-import win32file
-import win32pipe
-import pywintypes
-import win32process
-import win32event
-import win32con
-import win32gui
+if sys.platform.startswith("win"):
+    import msvcrt
+    import win32api
+    import win32file
+    import win32pipe
+    import pywintypes
+    import win32process
+    import win32event
+    import win32con
+    import win32gui
+else:
+    import signal
 
 
 #---- exceptions
@@ -182,6 +185,7 @@
     logres = Logger("process.res", Logger.DEBUG, sys.stdout)
 
 
+
 #---- globals
 
 # List of registered processes (see _(un)registerProcess).
@@ -193,7 +197,7 @@
 
 def _escapeArg(arg):
     """Escape the given command line argument for the shell."""
-    #XXX There is a *lot* more that we should escape here.
+    #XXX There is a probably more that we should escape here.
     return arg.replace('"', r'\"')
 
 
@@ -220,6 +224,7 @@
 #   scope before the process has terminated, it is possible to get a
 #   hang (at least it *used* to be so when we had the
 #   win32api.CloseHandle(<stdin handle>) call in the __del__() method).
+#   XXX Is this hang possible on Linux as well?
 # A reference is removed from this list when the process's .wait or
 # .kill method is called.
 # XXX Should an atexit() handler be registered to kill all curently
@@ -235,7 +240,12 @@
     #   is a big memory waste. Cleaning up here alleviates that.
     for p in _processes[:]: # use copy of _process, because we may modifiy it
         try:
-            p.wait(0)  # poll to see if is process still running
+            # poll to see if is process still running
+            if sys.platform.startswith("win"):
+                timeout = 0
+            else:
+                timeout = os.WNOHANG
+            p.wait(timeout)
             _unregisterProcess(p)
         except ProcessError, ex:
             if ex.errno == ProcessProxy.WAIT_TIMEOUT:
@@ -265,70 +275,106 @@
     inherit (all defaults are the parent's current settings). 'wait' and
     'kill' method allow for control of the child's termination.
     """
-    # .wait() argument constants
-    INFINITE = win32event.INFINITE
-    # .wait() return error codes
-    WAIT_FAILED = win32event.WAIT_FAILED
-    WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
-    # creation "flags" constants
-    CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
-    CREATE_NEW_PROCESS_GROUP = win32process.CREATE_NEW_PROCESS_GROUP
+    if sys.platform.startswith("win"):
+        # .wait() argument constants
+        INFINITE = win32event.INFINITE
+        # .wait() return error codes
+        WAIT_FAILED = win32event.WAIT_FAILED
+        WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
+        # creation "flags" constants
+        # XXX Should drop these and just document usage of
+        #     win32process.CREATE_* constants on windows.
+        CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
+    else:
+        WAIT_TIMEOUT = 258
+        WAIT_FAILED = -1
 
-    def __init__(self, cmd, cwd=None, env=None, flags=None):
+    def __init__(self, cmd, cwd=None, env=None, flags=0):
         """Create a child process.
 
         "cmd" is a command string or argument vector to spawn.
         "cwd" is a working directory in which to start the child process.
         "env" is an environment dictionary for the child.
         "flags" are system-specific process creation flags. On Windows
-            this default to CREATE_NEW_PROCESS_GROUP.
+            this can be a bitwise-OR of any of the win32process.CREATE_*
+            constants (Note: win32process.CREATE_NEW_PROCESS_GROUP is always
+            OR'd in). On Unix, this is currently ignored.
         """
         log.info("Process.__init__(cmd=%r, cwd=%r, env=%r, flags=%r)",
                  cmd, cwd, env, flags)
-        if type(cmd) in (types.ListType, types.TupleType):
-            # And arg vector was passed in.
-            self._cmd = _joinArgv(cmd)
-        else:
-            self._cmd = cmd
+        self._cmd = cmd
         if not self._cmd:
             raise ProcessError("You must specify a command.")
         self._cwd = cwd
         self._env = env
-        if flags is None:
-            self._flags = self.CREATE_NEW_PROCESS_GROUP
+        if sys.platform.startswith("win"):
+            self._flags |= win32process.CREATE_NEW_PROCESS_GROUP
+
+        if sys.platform.startswith("win"):
+            self._startOnWindows()
+        else:
+            self._startOnUnix()
+
+    def _runChildOnUnix(self):
+        #XXX Errors running the child do *not* get communicated back.
+
+        #XXX Perhaps we should *always* prefix with '/bin/sh -c'? There is a
+        #    disparity btwn how this works on Linux and Windows.
+        if isinstance(self._cmd, types.StringTypes):
+            # This is easier than trying to reproduce shell interpretation to
+            # separate the arguments.
+            cmd = ['/bin/sh', '-c', _escapeArg(self._cmd)]
+        else:
+            cmd = self._cmd
+
+        # Close all file descriptors (except std*) inherited from the parent.
+        MAXFD = 256 # Max number of file descriptors (os.getdtablesize()???)
+        for i in range(3, MAXFD):
+            try:
+                os.close(i)
+            except OSError:
+                pass
+
+        try:
+            if self._env:
+                os.execvpe(cmd[0], cmd, self._env)
+            else:
+                os.execvp(cmd[0], cmd)
+        finally:
+            os._exit(1)  # Should never get here.
+
+    def _startOnUnix(self):
+        if self._cwd:
+            oldDir = os.getcwd()
+            try:
+                os.chdir(self._cwd)
+            except OSError, ex:
+                raise ProcessError(msg=str(ex), errno=ex.errno)
+        self._pid = os.fork()
+        if self._pid == 0: # child
+            self._runChildOnUnix()
+
+        # parent
+        if self._cwd:
+            os.chdir(oldDir)
+
+    def _startOnWindows(self):
+        if type(self._cmd) in (types.ListType, types.TupleType):
+            # And arg vector was passed in.
+            cmd = _joinArgv(self._cmd)
         else:
-            self._flags = flags
-        self._start()
+            cmd = self._cmd
 
-    def _start(self):
         si = win32process.STARTUPINFO() 
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
         si.wShowWindow = win32con.SW_SHOWDEFAULT
 
-        #XXX May later want to allow hooking up of std handles but will
-        #    need some way to NOT do this because that is what Komodo
-        #    requires.
-        ## Get the std handles to pass to the child
-        #if self._stdin is None:
-        #    si.hStdInput = win32api.GetStdHandle(win32api.STD_INPUT_HANDLE)
-        #else:
-        #    si.hStdInput = msvcrt.get_osfhandle(stdin.fileno())
-        #if self._stdout is None:
-        #    si.hStdOutput = win32api.GetStdHandle(win32api.STD_OUTPUT_HANDLE)
-        #else:
-        #    si.hStdOutput = msvcrt.get_osfhandle(stdout.fileno())
-        #if self._stderr is None:
-        #    si.hStdError = win32api.GetStdHandle(win32api.STD_ERROR_HANDLE)
-        #else:
-        #    si.hStdError = msvcrt.get_osfhandle(stderr.fileno())
-        #si.dwFlags |= win32process.STARTF_USESTDHANDLES
-
         # Start the child process.
         try:
             self._hProcess, self._hThread, self._processId, self._threadId\
                 = win32process.CreateProcess(
                     None,           # app name
-                    self._cmd,      # command line 
+                    cmd,            # command line 
                     None,           # process security attributes 
                     None,           # primary thread security attributes 
                     0,              # handles are inherited 
@@ -343,75 +389,102 @@
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
         
-        A 'timeout' floating point number of seconds after which to
-        timeout.  If the wait time's out or there is some other error it
-        will raise a ProcessError. Otherwise it returns the child's exit
+        "timeout" (on Windows) is a floating point number of seconds after
+            which to timeout.
+            Default is win32event.INIFINITE.
+        "timeout" (on Unix) is akin to the os.waitpid() "options" argument
+            (os.WNOHANG may be used to return immediately if the process has
+            not exited). Default is 0, i.e. wait forever.
+
+        If the wait time's out it will raise a ProcessError. Otherwise it
+        will return the child's exit value (on Windows) or the child's exit
+        status excoded as per os.waitpid() (on Linux):
+            "a 16-bit number, whose low byte is the signal number that killed
+            the process, and whose high byte is the exit status (if the
+            signal number is zero); the high bit of the low byte is set if a
+            core file was produced."
+        In the latter case, use the os.W*() methods to interpret the return
         value.
-        
+
         XXX Or should returning the exit value be move out to another
             function as on Win32 process control? If so, then should
             perhaps not make WaitForSingleObject semantic
             transformation.
         """
-        if timeout is None:
-            timeout = win32event.INFINITE
-        else:
-            timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+        if sys.platform.startswith("win"):
+            if timeout is None:
+                timeout = win32event.INFINITE
+            else:
+                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
 
-        rc = win32event.WaitForSingleObject(self._hProcess, timeout)
-        if rc == win32event.WAIT_FAILED:
-            raise ProcessError("'WAIT_FAILED' when waiting for process to "\
-                               "terminate: %r" % self._cmd, rc)
-        elif rc == win32event.WAIT_TIMEOUT:
-            raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
-                               "terminate: %r" % self._cmd, rc)
+            rc = win32event.WaitForSingleObject(self._hProcess, timeout)
+            if rc == win32event.WAIT_FAILED:
+                raise ProcessError("'WAIT_FAILED' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
+            elif rc == win32event.WAIT_TIMEOUT:
+                raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
 
-        retval = win32process.GetExitCodeProcess(self._hProcess)
+            retval = win32process.GetExitCodeProcess(self._hProcess)
+        else:
+            if timeout is None:
+                timeout = 0
+            pid, sts = os.waitpid(self._pid, timeout)
+            if pid == self._pid:
+                retval = sts
+            else:
+                raise ProcessError("Wait for process timed out.",
+                                   self.WAIT_TIMEOUT)
         return retval
 
-    def kill(self, exitCode=0, gracePeriod=1.0):
+    def kill(self, exitCode=0, gracePeriod=1.0, sig=signal.SIGKILL):
         """Kill process.
         
-        "exitCode" is the code the terminated process should exit with.
-        "gracePeriod" is a number of seconds the process is allowed to
-            shutdown with a WM_CLOSE signal before a hard terminate is
-            called.
+        "exitCode" (Windows only) is the code the terminated process should
+            exit with.
+        "gracePeriod" (Windows only) is a number of seconds the process is
+            allowed to shutdown with a WM_CLOSE signal before a hard
+            terminate is called.
+        "sig" (Unix only) is the signal to use to kill the process. Defaults
+            to signal.SIGKILL. See os.kill() for more information.
 
         Windows:
             Try for an orderly shutdown via WM_CLOSE.  If still running
             after gracePeriod (1 sec. default), terminate.
         """
-        # Send WM_CLOSE to windows in this process group.
-        win32gui.EnumWindows(self._close_, 0)
+        if sys.platform.startswith("win"):
+            # Send WM_CLOSE to windows in this process group.
+            win32gui.EnumWindows(self._close_, 0)
 
-        retval = 0
-        try:
-            self.wait(gracePeriod)
-        except ProcessError, ex:
-            log.info("[%s] Process.kill: calling TerminateProcess", id(self))
-            retval = win32process.TerminateProcess(self._hProcess, exitCode)
-            win32api.Sleep(100) # wait for resources to be released
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, exitCode)
+                win32api.Sleep(100) # wait for resources to be released
 
-        # Last resort, send Ctrl-C to all processes attached to this console.
-        # This is done *after* TerminateProcess because the former
-        # allows one to specify the exit code for the top-level process
-        # in the process group. The subsequent CTRL+Break will then (we
-        # hope) terminate any other remaining processes in the group.
-        try:
-            win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
-                                              self._processId)
-        except AttributeError:
-            log.warn("The win32api module does not have "\
-                     "GenerateConsoleCtrlEvent(). This may mean that "\
-                     "parts of this process group have NOT been killed.")
+            # Last resort, send Ctrl-C to all processes attached to this console.
+            # This is done *after* TerminateProcess because the former
+            # allows one to specify the exit code for the top-level process
+            # in the process group. The subsequent CTRL+Break will then (we
+            # hope) terminate any other remaining processes in the group.
+            try:
+                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                                                  self._processId)
+            except AttributeError:
+                log.warn("The win32api module does not have "\
+                         "GenerateConsoleCtrlEvent(). This may mean that "\
+                         "parts of this process group have NOT been killed.")
 
-        _unregisterProcess(self)
-        return retval
+        else:
+            os.kill(self._pid, sig)
 
     def _close_(self, hwnd, dummy):
-        """Callback used by .kill()
-        EnumWindows callback - sends WM_CLOSE to any window
-        owned by this process.
+        """Callback used by .kill() on Windows.
+
+        EnumWindows callback - sends WM_CLOSE to any window owned by this
+        process.
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
@@ -420,7 +493,7 @@
 
 class FileWrapper:
     """Wrap a system file object, hiding some nitpicky details."""
-    def __init__(self, file, descriptor, handle):
+    def __init__(self, file, descriptor, handle=None):
         self._file = file
         self._descriptor = descriptor
         self._handle = handle
@@ -476,16 +549,35 @@
     #
     def __init__(self, cmd, mode='t', cwd=None, env=None, bufsize=-1,
                  stdin=None, stdout=None, stderr=None):
+        """Create a Process with proxy threads for each std handle.
+
+        "cmd" is the command string of argument vector to run.
+        "mode" (Windows only) specifies whether the pipes used to communicate
+            with the child are openned in text, 't', or binary, 'b', mode.
+            This is ignored on platforms other than Windows. Default is 't'.
+        "cwd" optionally specifies the directory in which the child process
+            should be started. Default is None, a.k.a. inherits the cwd from
+            the parent.
+        "env" is optionally a mapping specifying the environment in which to
+            start the child. Default is None, a.k.a. inherits the environment
+            of the parent.
+        "bufsize" is used to specify the bufsize for std handles used to
+            communicate with the child. This is specified via os.fdopen(...,
+            bufsize). See os.fdopen() for more information. Default is -1.
+        "stdin", "stdout", "stderr" can be used to specify an objects with
+            file-like interfaces to handle read (stdout/stderr) and write
+            (stdin) events from the child. By default a process.IOBuffer
+            instance is assigned to each handler. IOBuffer may be
+            sub-classed. See the IOBuffer doc string for more information.
+        """
+        # Keep a reference to ensure it is around for this object's destruction.
+        self.__log = log
         log.info("ProcessProxy.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
                  "bufsize=%r, stdin=%r, stdout=%r, stderr=%r)",
                  cmd, mode, cwd, env, bufsize, stdin, stdout, stderr)
-        if type(cmd) in (types.ListType, types.TupleType):
-            # An arg vector was passed in.
-            self._cmd = _joinArgv(cmd)
-        else:
-            self._cmd = cmd
+        self._cmd = cmd
         if not self._cmd:
-            raise ProcessError("You must specify a command to spawn.")
+            raise ProcessError("You must specify a command.")
         self._mode = mode
         if self._mode not in ('t', 'b'):
             raise ProcessError("'mode' must be 't' or 'b'.")
@@ -504,32 +596,37 @@
             self.stderr = IOBuffer(name='<stderr>')
         else:
             self.stderr = stderr
-        self._start()
+
+        if sys.platform.startswith("win"):
+            self._startOnWindows()
+        else:
+            self._startOnUnix()
+
         _registerProcess(self)
 
     def __del__(self):
-        log.info("[%s] ProcessProxy.__del__()" % id(self))
+        self.__log.info("[%s] ProcessProxy.__del__()" % id(self))
 
         # Ensure that all IOBuffer's are closed. If they are not, these
         # can cause hangs. 
-        log.info("[%s] ProcessProxy: closing stdin (%r)."\
-                 % (id(self), self.stdin))
+        self.__log.info("[%s] ProcessProxy: closing stdin (%r)."\
+                        % (id(self), self.stdin))
         try:
             self.stdin.close()
         except AttributeError:
             # May not have gotten far enough in the __init__ to set
             # self.stdin, etc.
             pass
-        log.info("[%s] ProcessProxy: closing stdout (%r)."\
-                 % (id(self), self.stdout))
+        self.__log.info("[%s] ProcessProxy: closing stdout (%r)."\
+                        % (id(self), self.stdout))
         try:
-                self.stdout.close()
+            self.stdout.close()
         except AttributeError:
             # May not have gotten far enough in the __init__ to set
             # self.stdin, etc.
             pass
-        log.info("[%s] ProcessProxy: closing stderr (%r)."\
-                 % (id(self), self.stderr))
+        self.__log.info("[%s] ProcessProxy: closing stderr (%r)."\
+                        % (id(self), self.stderr))
         try:
             self.stderr.close()
         except AttributeError:
@@ -537,7 +634,69 @@
             # self.stdin, etc.
             pass
 
-    def _start(self):
+        del self.__log # drop reference
+
+    def _startOnUnix(self):
+        # Create pipes for std handles.
+        fdChildStdinRd, fdChildStdinWr = os.pipe()
+        fdChildStdoutRd, fdChildStdoutWr = os.pipe()
+        fdChildStderrRd, fdChildStderrWr = os.pipe()
+
+        if self._cwd:
+            oldDir = os.getcwd()
+            try:
+                os.chdir(self._cwd)
+            except OSError, ex:
+                raise ProcessError(msg=str(ex), errno=ex.errno)
+        self._pid = os.fork()
+        if self._pid == 0: # child
+            os.dup2(fdChildStdinRd, 0)
+            os.dup2(fdChildStdoutWr, 1)
+            os.dup2(fdChildStderrWr, 2)
+            self._runChildOnUnix()
+        # parent
+        if self._cwd:
+            os.chdir(oldDir)
+
+        os.close(fdChildStdinRd)
+        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w', self._bufsize)
+        os.close(fdChildStdoutWr)
+        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r', self._bufsize)
+        os.close(fdChildStderrWr)
+        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r', self._bufsize)
+
+        childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr)
+        logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
+                    id(self), childStdin)
+        childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd)
+        logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
+                    id(self), childStdout)
+        childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd)
+        logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
+                    id(self), childStderr)
+
+        # Create proxy threads for the out pipes.
+        stdinProxy = InFileProxy(self.stdin, childStdin, name='<stdin>')
+        stdinProxy.start()
+        # Clean up the parent's side of <stdin> when it is observed that
+        # the child has closed its side of <stdout>. (This is one way of
+        # determining when it is appropriate to clean up this pipe, with
+        # compromises. See the discussion at the top of this module.)
+        stdoutProxy = OutFileProxy(childStdout, self.stdout, 
+                                   self.stdin, childStdin,
+                                   name='<stdout>')
+        stdoutProxy.start()
+        stderrProxy = OutFileProxy(childStderr, self.stderr,
+                                   name='<stderr>')
+        stderrProxy.start()
+
+    def _startOnWindows(self):
+        if type(self._cmd) in (types.ListType, types.TupleType):
+            # An arg vector was passed in.
+            cmd = _joinArgv(self._cmd)
+        else:
+            cmd = self._cmd
+
         # Create pipes for std handles.
         # (Set the bInheritHandle flag so pipe handles are inherited.)
         saAttr = pywintypes.SECURITY_ATTRIBUTES()
@@ -696,76 +855,105 @@
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
         
-        A 'timeone' floating point number of seconds after which to
-        timeout.  If the wait time's out or there is some other error it
-        will raise a ProcessError. Otherwise it returns the child's exit
+        "timeout" (on Windows) is a floating point number of seconds after
+            which to timeout.
+            Default is win32event.INIFINITE.
+        "timeout" (on Unix) is akin to the os.waitpid() "options" argument
+            (os.WNOHANG may be used to return immediately if the process has
+            not exited). Default is 0, i.e. wait forever.
+
+        If the wait time's out it will raise a ProcessError. Otherwise it
+        will return the child's exit value (on Windows) or the child's exit
+        status excoded as per os.waitpid() (on Linux):
+            "a 16-bit number, whose low byte is the signal number that killed
+            the process, and whose high byte is the exit status (if the
+            signal number is zero); the high bit of the low byte is set if a
+            core file was produced."
+        In the latter case, use the os.W*() methods to interpret the return
         value.
-        
+
         XXX Or should returning the exit value be move out to another
-            function as on Win32 process control?
+            function as on Win32 process control? If so, then should
+            perhaps not make WaitForSingleObject semantic
+            transformation.
         """
-        log.info("[%s] ProcessProxy.wait(timeout=%r)" % (id(self), timeout))
-        if timeout is None:
-            timeout = win32event.INFINITE
-        else:
-            timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+        if sys.platform.startswith("win"):
+            if timeout is None:
+                timeout = win32event.INFINITE
+            else:
+                timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
 
-        rc = win32event.WaitForSingleObject(self._hProcess, timeout)
-        if rc == win32event.WAIT_FAILED:
-            raise ProcessError("'WAIT_FAILED' when waiting for process to "\
-                               "terminate: %r" % self._cmd, rc)
-        elif rc == win32event.WAIT_TIMEOUT:
-            raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
-                               "terminate: %r" % self._cmd, rc)
+            rc = win32event.WaitForSingleObject(self._hProcess, timeout)
+            if rc == win32event.WAIT_FAILED:
+                raise ProcessError("'WAIT_FAILED' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
+            elif rc == win32event.WAIT_TIMEOUT:
+                raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
+                                   "terminate: %r" % self._cmd, rc)
 
-        retval = win32process.GetExitCodeProcess(self._hProcess)
+            retval = win32process.GetExitCodeProcess(self._hProcess)
+        else:
+            if timeout is None:
+                timeout = 0
+            pid, sts = os.waitpid(self._pid, timeout)
+            if pid == self._pid:
+                retval = sts
+            else:
+                raise ProcessError("Wait for process timed out.",
+                                   self.WAIT_TIMEOUT)
         _unregisterProcess(self)
         return retval
 
-    def kill(self, exitCode=0, gracePeriod=1.0):
+    def kill(self, exitCode=0, gracePeriod=1.0, sig=signal.SIGKILL):
         """Kill process.
         
-        "exitCode" is the code the terminated process should exit with.
-        "gracePeriod" is a number of seconds the process is allowed to
-            shutdown with a WM_CLOSE signal before a hard terminate is
-            called.
+        "exitCode" (Windows only) is the code the terminated process should
+            exit with.
+        "gracePeriod" (Windows only) is a number of seconds the process is
+            allowed to shutdown with a WM_CLOSE signal before a hard
+            terminate is called.
+        "sig" (Unix only) is the signal to use to kill the process. Defaults
+            to signal.SIGKILL. See os.kill() for more information.
 
         Windows:
             Try for an orderly shutdown via WM_CLOSE.  If still running
             after gracePeriod (1 sec. default), terminate.
         """
-        # Send WM_CLOSE to windows in this process group.
-        win32gui.EnumWindows(self._close_, 0)
+        if sys.platform.startswith("win"):
+            # Send WM_CLOSE to windows in this process group.
+            win32gui.EnumWindows(self._close_, 0)
+
+            retval = 0
+            try:
+                self.wait(gracePeriod)
+            except ProcessError, ex:
+                log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+                win32process.TerminateProcess(self._hProcess, exitCode)
+                win32api.Sleep(100) # wait for resources to be released
 
-        retval = 0
-        try:
-            self.wait(gracePeriod)
-        except ProcessError, ex:
-            log.info("[%s] ProcessProxy.kill: calling TerminateProcess",
-                     id(self))
-            retval = win32process.TerminateProcess(self._hProcess, exitCode)
-            win32api.Sleep(100) # wait for resources to be released
+            # Last resort, send Ctrl-C to all processes attached to this console.
+            # This is done *after* TerminateProcess because the former
+            # allows one to specify the exit code for the top-level process
+            # in the process group. The subsequent CTRL+Break will then (we
+            # hope) terminate any other remaining processes in the group.
+            try:
+                win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                                                  self._processId)
+            except AttributeError:
+                log.warn("The win32api module does not have "\
+                         "GenerateConsoleCtrlEvent(). This may mean that "\
+                         "parts of this process group have NOT been killed.")
 
-        # Last resort, send Ctrl-C to all processes attached to this console.
-        # This is done *after* TerminateProcess because the former
-        # allows one to specify the exit code for the top-level process
-        # in the process group. The subsequent CTRL+Break will then (we
-        # hope) terminate any other remaining processes in the group.
-        try:
-            win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
-                                              self._processId)
-        except AttributeError:
-            log.warn("The win32api module does not have "\
-                     "GenerateConsoleCtrlEvent(). This may mean that "\
-                     "parts of this process group have NOT been killed.")
+        else:
+            os.kill(self._pid, sig)
 
         _unregisterProcess(self)
-        return retval
 
     def _close_(self, hwnd, dummy):
-        """Callback used by .kill()
-        EnumWindows callback - sends WM_CLOSE to any window
-        owned by this process.
+        """Callback used by .kill() on Windows.
+
+        EnumWindows callback - sends WM_CLOSE to any window owned by this
+        process.
         """
         threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
         if processId == self._processId:
@@ -973,7 +1161,10 @@
         finally:
             log.info("[%s] InFileProxy: closing parent (%r)"\
                      % (self.getName(), self.fParent))
-            self.fParent.close()
+            try:
+                self.fParent.close()
+            except IOError:
+                pass # Ignore: IOError: [Errno 4] Interrupted system call
         log.info("[%s] InFileProxy: done" % self.getName())
 
     def _proxyFromParentToChild(self):
@@ -1018,7 +1209,10 @@
                     logres.info("[%s] InFileProxy: closing child after "\
                                 "observing parent's close: %r", self.getName(),
                                 self.fChild)
-                    self.fChild.close()
+                    try:
+                        self.fChild.close()
+                    except IOError:
+                        pass # Ignore: IOError: [Errno 4] Interrupted system call
                 except IOError, ex:
                     # Ignore: IOError: [Errno 9] Bad file descriptor
                     # XXX Do we *know* we want to do that?
@@ -1071,10 +1265,16 @@
         finally:
             logres.info("[%s] OutFileProxy: terminating, close child (%r)",
                         self.getName(), self.fChild)
-            self.fChild.close()
+            try:
+                self.fChild.close()
+            except IOError:
+                pass # Ignore: IOError: [Errno 4] Interrupted system call
             log.info("[%s] OutFileProxy: closing parent (%r)",
                      self.getName(), self.fParent)
-            self.fParent.close()
+            try:
+                self.fParent.close()
+            except IOError:
+                pass # Ignore: IOError: [Errno 4] Interrupted system call
             #XXX Are these both necessary?
             # XXX *One* of self.fToClean*.write('') and .close()
             #     seems to be necessary for the current test suite.
@@ -1093,12 +1293,19 @@
                 logres.info("[%s] OutFileProxy: closing additional file "\
                             "after closing parent: %r", self.getName(),
                             self.fToCleanRd)
-                self.fToCleanRd.close()
+                try:
+                    self.fToCleanRd.close()
+                except IOError:
+                    pass # Ignore: IOError: [Errno 4] Interrupted system call
+
             if self.fToCleanWr:
                 logres.info("[%s] OutFileProxy: closing additional file "\
                             "after closing parent: %r", self.getName(),
                             self.fToCleanWr)
-                self.fToCleanWr.close()
+                try:
+                    self.fToCleanWr.close()
+                except IOError:
+                    pass # Ignore: IOError: [Errno 4] Interrupted system call
         log.info("[%s] OutFileProxy: done" % self.getName())
 
     def _proxyFromChildToParent(self):

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test.py#3 (text) ====

@@ -89,6 +89,13 @@
     sys.stdout.write("-"*70 + '\n')
 
 
+    # Explicitly put the test dir on the PATH so spawning test programs there
+    # actually get found (both on Unix were '.' is not implicitly on the PATH
+    # and everywhere when testing changing 'cwd').
+    os.environ["PATH"] = os.path.abspath(os.curdir) + os.pathsep\
+                         + os.environ.get("PATH", "")
+
+
 def _tearDown():
     pass
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#6 (text) ====

@@ -5,7 +5,6 @@
 import re
 import pprint
 import unittest
-import win32api
 import testsupport
 
 import process
@@ -26,9 +25,9 @@
                         "%r != %r" % (match.group(1), cwd))
 
     def test_cwd_specified(self):
-        wd = "D:\\trentm"
+        wd = os.path.expanduser('~')
 
-        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -47,7 +46,7 @@
         wd = "mytmprelativedir"
         testsupport.mkdir(wd)
 
-        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -63,7 +62,7 @@
         wd = "my tmp relative dir with spaces"
         testsupport.mkdir(wd)
 
-        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#4 (text) ====

@@ -6,6 +6,9 @@
 import pprint
 import unittest
 
+if not sys.platform.startswith("win"):
+    import signal
+
 import process
 
 
@@ -26,17 +29,36 @@
 class KillTestCase(unittest.TestCase):
     def test_kill(self):
         p = process.ProcessProxy(['hang'])
-        time.sleep(3)
+        time.sleep(2)
         p.kill()
         retval = p.wait()
-        self.failIf(retval)
+        if sys.platform.startswith("win"):
+            self.failIf(retval)
+        else:
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+
+    if sys.platform.startswith("win"):
+        def test_kill_exitcode(self):
+            p = process.ProcessProxy(['hang'])
+            time.sleep(2)
+            p.kill(42)
+            retval = p.wait()
+            self.failUnless(retval == 42)
+
+    if not sys.platform.startswith("win"):
+        def test_kill_SIGKILL(self):
+            p = process.ProcessProxy(['hang'])
+            time.sleep(1)
+            p.kill(sig=signal.SIGKILL)
+            retval = p.wait()
+            self.failUnless(os.WIFSIGNALED(retval))
+            self.failUnless(os.WTERMSIG(retval) == signal.SIGKILL)
+
+        # XXX Could add tests for other signals but would have to launch an
+        #     app that would respond to those signals in a measurable way and
+        #     then terminate.
 
-    def test_kill_exitcode(self):
-        p = process.ProcessProxy(['hang'])
-        time.sleep(3)
-        p.kill(42)
-        retval = p.wait()
-        self.failUnless(retval == 42)
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#3 (text) ====

@@ -10,20 +10,30 @@
 
 
 class RetvalTestCase(unittest.TestCase):
+    def _assertRetvalIs(self, expected, actual):
+        if sys.platform.startswith("win"):
+            self.failUnless(actual == expected)
+        else:
+            self.failUnless(os.WIFEXITED(actual))
+            exitStatus = os.WEXITSTATUS(actual)
+            # convert from 8-bit unsigned to signed
+            if exitStatus >= 2**7: exitStatus -= 2**8
+            self.failUnless(exitStatus == expected)
+
     def test_0(self):
         p = process.ProcessProxy(['quiet'])
         retval = p.wait()
-        self.failUnless(retval == 0)
+        self._assertRetvalIs(0, retval)
 
     def test_42(self):
         p = process.ProcessProxy(['quiet', '42'])
         retval = p.wait()
-        self.failUnless(retval == 42)
+        self._assertRetvalIs(42, retval)
 
     def test_minus_42(self):
         p = process.ProcessProxy(['quiet', '-42'])
         retval = p.wait()
-        self.failUnless(retval == -42)
+        self._assertRetvalIs(-42, retval)
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#7 (text) ====

@@ -137,9 +137,13 @@
     #                    "Unexpected stdout output: %r" % output)
 
     def test_stdin_text_mode(self):
-        # Expecting to get cygwin sort here. (XXX Should drop that dep.,
-        # but am currently using it because it reacts measurably
-        # differently to lines with '\r\n' vs '\n' terminators.)
+        # On Windows:
+        #   Expecting to get cygwin sort here. (XXX Should drop that dep.,
+        #   but am currently using it because it reacts measurably
+        #   differently to lines with '\r\n' vs '\n' terminators.)
+        # On Linux:
+        #   There is no distinction btwn text- and binary-modes. So this
+        #   really is not providing that useful a test.
         p = process.ProcessProxy(['sort'])
         p.stdin.write("2\n")
         p.stdin.write("1\n")
@@ -152,37 +156,38 @@
                         "Pipes are not doing text translation."\
                         % (output, expected))
 
-    def test_stdin_binary_mode(self):
-        # Expecting to get cygwin sort here. (XXX Should drop that dep.)
-        p = process.ProcessProxy(['sort'], mode='b')
-        p.stdin.write("2\n")
-        p.stdin.write("1\n")
-        p.stdin.write("3\n")
-        p.stdin.close()
-        output = p.stdout.read()
-        expected = "???\r\n"
-        self.failUnless(output == expected,
-                        "Unexpected stdout output: %r (expected: %r). "\
-                        "Pipes are not doing text translation."\
-                        % (output, expected))
-    
-        # Note: reusing 'p' here is subtly testing another aspect of the
-        #       ProcessProxy stuff. If self._hChildStdinWr (and the
-        #       stdout/stderr equivs) are not handled in ProcessProxy.__del__
-        #       then a win32api error on CloseHandle is raised when the
-        #       C runtime closes these handles asynchronously.
+    if sys.platform.startswith("win"):
+        def test_stdin_binary_mode(self):
+            # Expecting to get cygwin sort here. (XXX Should drop that dep.)
+            p = process.ProcessProxy(['sort'], mode='b')
+            p.stdin.write("2\n")
+            p.stdin.write("1\n")
+            p.stdin.write("3\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "???\r\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r (expected: %r). "\
+                            "Pipes are not doing text translation."\
+                            % (output, expected))
+        
+            # Note: reusing 'p' here is subtly testing another aspect of the
+            #       ProcessProxy stuff. If self._hChildStdinWr (and the
+            #       stdout/stderr equivs) are not handled in ProcessProxy.__del__
+            #       then a win32api error on CloseHandle is raised when the
+            #       C runtime closes these handles asynchronously.
 
-        p = process.ProcessProxy(['sort'], mode='b')
-        p.stdin.write("2\r\n")
-        p.stdin.write("1\r\n")
-        p.stdin.write("3\r\n")
-        p.stdin.close()
-        output = p.stdout.read()
-        expected = "1\r\n2\r\n3\r\n"
-        self.failUnless(output == expected,
-                        "Unexpected stdout output: %r (expected: %r). "\
-                        "Pipes are not doing text translation."\
-                        % (output, expected))
+            p = process.ProcessProxy(['sort'], mode='b')
+            p.stdin.write("2\r\n")
+            p.stdin.write("1\r\n")
+            p.stdin.write("3\r\n")
+            p.stdin.close()
+            output = p.stdout.read()
+            expected = "1\r\n2\r\n3\r\n"
+            self.failUnless(output == expected,
+                            "Unexpected stdout output: %r (expected: %r). "\
+                            "Pipes are not doing text translation."\
+                            % (output, expected))
 
     def test_stdin_buffering_with_mystdin(self):
         p = process.ProcessProxy(['ask'], stdin=MyInFile("Trent\n"),
Change 42838 by trentm@trentm-razor on 2002/07/09 12:53:06

	Update the .kill() methods to send a CTRL+BREAK to the spawned 
	process group (the CREATE_NEW_PROCESS_GROUP is now being used 
	in CreateProcess). This allows a created process (and its tree
	 of child processes) to be "properly" kill'd. 
	
	This was fairly urgent because Komodo routinely launches all 
	user run command's via "cmd.exe /c <cmd_string>" which results 
	in a process tree under "cmd.exe".
	
	r=davida

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#19 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#19 (text) ====

@@ -272,14 +272,16 @@
     WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
     # creation "flags" constants
     CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
+    CREATE_NEW_PROCESS_GROUP = win32process.CREATE_NEW_PROCESS_GROUP
 
-    def __init__(self, cmd, cwd=None, env=None, flags=0):
+    def __init__(self, cmd, cwd=None, env=None, flags=None):
         """Create a child process.
 
         "cmd" is a command string or argument vector to spawn.
         "cwd" is a working directory in which to start the child process.
         "env" is an environment dictionary for the child.
-        "flags" are system-specific process creation flags.
+        "flags" are system-specific process creation flags. On Windows
+            this default to CREATE_NEW_PROCESS_GROUP.
         """
         log.info("Process.__init__(cmd=%r, cwd=%r, env=%r, flags=%r)",
                  cmd, cwd, env, flags)
@@ -292,7 +294,10 @@
             raise ProcessError("You must specify a command.")
         self._cwd = cwd
         self._env = env
-        self._flags = flags
+        if flags is None:
+            self._flags = self.CREATE_NEW_PROCESS_GROUP
+        else:
+            self._flags = flags
         self._start()
 
     def _start(self):
@@ -376,13 +381,33 @@
             Try for an orderly shutdown via WM_CLOSE.  If still running
             after gracePeriod (1 sec. default), terminate.
         """
+        # Send WM_CLOSE to windows in this process group.
         win32gui.EnumWindows(self._close_, 0)
+
+        retval = 0
         try:
             self.wait(gracePeriod)
         except ProcessError, ex:
-            win32process.TerminateProcess(self._hProcess, 0)
+            log.info("[%s] Process.kill: calling TerminateProcess", id(self))
+            retval = win32process.TerminateProcess(self._hProcess, exitCode)
             win32api.Sleep(100) # wait for resources to be released
 
+        # Last resort, send Ctrl-C to all processes attached to this console.
+        # This is done *after* TerminateProcess because the former
+        # allows one to specify the exit code for the top-level process
+        # in the process group. The subsequent CTRL+Break will then (we
+        # hope) terminate any other remaining processes in the group.
+        try:
+            win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                                              self._processId)
+        except AttributeError:
+            log.warn("The win32api module does not have "\
+                     "GenerateConsoleCtrlEvent(). This may mean that "\
+                     "parts of this process group have NOT been killed.")
+
+        _unregisterProcess(self)
+        return retval
+
     def _close_(self, hwnd, dummy):
         """Callback used by .kill()
         EnumWindows callback - sends WM_CLOSE to any window
@@ -629,6 +654,7 @@
                 cmd = '%s "%s /c %s"' % (w9xpopen, comspec, self._cmd)
             log.debug("cmd = %r", cmd)
 
+            creationFlags = win32process.CREATE_NEW_PROCESS_GROUP
             try:
                 self._hProcess, hThread, self._processId, threadId\
                     = win32process.CreateProcess(
@@ -637,7 +663,7 @@
                         None,           # process security attributes 
                         None,           # primary thread security attributes 
                         1,              # handles are inherited 
-                        0,              # creation flags 
+                        creationFlags,  # creation flags 
                         self._env,      # environment
                         self._cwd,      # current working directory
                         si)             # STARTUPINFO pointer 
@@ -708,7 +734,9 @@
             Try for an orderly shutdown via WM_CLOSE.  If still running
             after gracePeriod (1 sec. default), terminate.
         """
+        # Send WM_CLOSE to windows in this process group.
         win32gui.EnumWindows(self._close_, 0)
+
         retval = 0
         try:
             self.wait(gracePeriod)
@@ -717,6 +745,20 @@
                      id(self))
             retval = win32process.TerminateProcess(self._hProcess, exitCode)
             win32api.Sleep(100) # wait for resources to be released
+
+        # Last resort, send Ctrl-C to all processes attached to this console.
+        # This is done *after* TerminateProcess because the former
+        # allows one to specify the exit code for the top-level process
+        # in the process group. The subsequent CTRL+Break will then (we
+        # hope) terminate any other remaining processes in the group.
+        try:
+            win32api.GenerateConsoleCtrlEvent(win32con.CTRL_BREAK_EVENT,
+                                              self._processId)
+        except AttributeError:
+            log.warn("The win32api module does not have "\
+                     "GenerateConsoleCtrlEvent(). This may mean that "\
+                     "parts of this process group have NOT been killed.")
+
         _unregisterProcess(self)
         return retval
 
Change 42492 by trentm@trentm-razor on 2002/07/02 15:54:05

	Various tweaks:
	   - fix the gracePeriod handling used for Process.kill(), it was multiplying
	     the period by 1000.0 incorrectly
	   - switch ProcessProxy.kill() to Process.kill()'s method of killing (first
	     send WM_CLOSE and give the process a chance to shutdown normal, then
	     TerminateProcess if necessary)
	   - p.std*.close(), where p is a ProcessProxy instance, is called for any
	     object where before it would only be called is p.std* was an IOBuffer
	     instance (hacky).
	   - some doc fixes
	
	   This includes some debugging prints (turned off for now) in the attempt
	   that was made to resolve the hang-on-kill-of-"cmd /c ..."-commands problem.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#18 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#18 (text) ====

@@ -364,7 +364,7 @@
         retval = win32process.GetExitCodeProcess(self._hProcess)
         return retval
 
-    def kill(self, exitCode=0, gracePeriod=0.0):
+    def kill(self, exitCode=0, gracePeriod=1.0):
         """Kill process.
         
         "exitCode" is the code the terminated process should exit with.
@@ -374,9 +374,8 @@
 
         Windows:
             Try for an orderly shutdown via WM_CLOSE.  If still running
-            after gracePeriod (5 sec. default), terminate.
+            after gracePeriod (1 sec. default), terminate.
         """
-        gracePeriod = gracePeriod * 1000.0
         win32gui.EnumWindows(self._close_, 0)
         try:
             self.wait(gracePeriod)
@@ -411,14 +410,20 @@
 
     def close(self):
         """Close the handle when the file is closed."""
+        log.debug("[%s] FileWrapper.close()", id(self))
         if not self._closed:
+            self._closed = 1
+            log.debug("[%s] FileWrapper.close: close file", id(self))
             retval = self._file.close()
+            log.debug("[%s] FileWrapper.close: done closing file", id(self))
             if self._handle is not None:
+                log.debug("[%s] FileWrapper.close: close handle", id(self))
                 try:
                     win32api.CloseHandle(self._handle)
                 except win32api.error:
+                    log.debug("[%s] FileWrapper.close: closing handle raised", id(self))
                     pass
-            self._closed = 1
+                log.debug("[%s] FileWrapper.close: done closing handle", id(self))
             return retval
 
     def __repr__(self):
@@ -482,35 +487,26 @@
 
         # Ensure that all IOBuffer's are closed. If they are not, these
         # can cause hangs. 
+        log.info("[%s] ProcessProxy: closing stdin (%r)."\
+                 % (id(self), self.stdin))
         try:
-            if isinstance(self.stdin, IOBuffer):
-                # Do not close user-specified streams. That is their
-                # responsibility.
-                log.info("[%s] ProcessProxy: closing stdin (%r)."\
-                         % (id(self), self.stdin))
-                self.stdin.close()
+            self.stdin.close()
         except AttributeError:
             # May not have gotten far enough in the __init__ to set
             # self.stdin, etc.
             pass
+        log.info("[%s] ProcessProxy: closing stdout (%r)."\
+                 % (id(self), self.stdout))
         try:
-            if isinstance(self.stdout, IOBuffer):
-                # Do not close user-specified streams. That is their
-                # responsibility.
-                log.info("[%s] ProcessProxy: closing stdout (%r)."\
-                         % (id(self), self.stdout))
                 self.stdout.close()
         except AttributeError:
             # May not have gotten far enough in the __init__ to set
             # self.stdin, etc.
             pass
+        log.info("[%s] ProcessProxy: closing stderr (%r)."\
+                 % (id(self), self.stderr))
         try:
-            if isinstance(self.stderr, IOBuffer):
-                # Do not close user-specified streams. That is their
-                # responsibility.
-                log.info("[%s] ProcessProxy: closing stderr (%r)."\
-                         % (id(self), self.stderr))
-                self.stderr.close()
+            self.stderr.close()
         except AttributeError:
             # May not have gotten far enough in the __init__ to set
             # self.stdin, etc.
@@ -634,7 +630,7 @@
             log.debug("cmd = %r", cmd)
 
             try:
-                self._hProcess, hThread, dwProcessId, dwThreadId\
+                self._hProcess, hThread, self._processId, threadId\
                     = win32process.CreateProcess(
                         None,           # app name
                         cmd,            # command line 
@@ -700,11 +696,38 @@
         _unregisterProcess(self)
         return retval
 
-    def kill(self, exitCode=0):
-        retval = win32process.TerminateProcess(self._hProcess, exitCode)
+    def kill(self, exitCode=0, gracePeriod=1.0):
+        """Kill process.
+        
+        "exitCode" is the code the terminated process should exit with.
+        "gracePeriod" is a number of seconds the process is allowed to
+            shutdown with a WM_CLOSE signal before a hard terminate is
+            called.
+
+        Windows:
+            Try for an orderly shutdown via WM_CLOSE.  If still running
+            after gracePeriod (1 sec. default), terminate.
+        """
+        win32gui.EnumWindows(self._close_, 0)
+        retval = 0
+        try:
+            self.wait(gracePeriod)
+        except ProcessError, ex:
+            log.info("[%s] ProcessProxy.kill: calling TerminateProcess",
+                     id(self))
+            retval = win32process.TerminateProcess(self._hProcess, exitCode)
+            win32api.Sleep(100) # wait for resources to be released
         _unregisterProcess(self)
         return retval
 
+    def _close_(self, hwnd, dummy):
+        """Callback used by .kill()
+        EnumWindows callback - sends WM_CLOSE to any window
+        owned by this process.
+        """
+        threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
+        if processId == self._processId:
+            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
 
 
 class IOBuffer:
@@ -906,12 +929,9 @@
         try:
             self._proxyFromParentToChild()
         finally:
-            if isinstance(self.fParent, IOBuffer):
-                # Do not close user-specified streams. That is their
-                # responsibility.
-                log.info("[%s] InFileProxy: closing parent (%r)"\
-                         % (self.getName(), self.fParent))
-                self.fParent.close()
+            log.info("[%s] InFileProxy: closing parent (%r)"\
+                     % (self.getName(), self.fParent))
+            self.fParent.close()
         log.info("[%s] InFileProxy: done" % self.getName())
 
     def _proxyFromParentToChild(self):
@@ -989,8 +1009,8 @@
         """
         "fChild" is a Win32 handle to the a child process' output pipe.
         "fParent" is a Python file-like object setup for writing.
-        "cleanOnTermination" is a file-like object to clean up on close
-            of this proxy.
+        "fToCleanRd"  and "fToCleanWr" are file-like objects to clean up
+            on close of this proxy.
         "name" can be set for debugging, it will be used in log messages.
         """
         log.info("[%s] OutFileProxy.__init__(fChild=%r, fParent=%r, "\
@@ -1010,12 +1030,9 @@
             logres.info("[%s] OutFileProxy: terminating, close child (%r)",
                         self.getName(), self.fChild)
             self.fChild.close()
-            if isinstance(self.fParent, IOBuffer):
-                # Do not close user-specified streams. That is their
-                # responsibility.
-                log.info("[%s] OutFileProxy: closing parent (%r)"\
-                         % (self.getName(), self.fParent))
-                self.fParent.close()
+            log.info("[%s] OutFileProxy: closing parent (%r)",
+                     self.getName(), self.fParent)
+            self.fParent.close()
             #XXX Are these both necessary?
             # XXX *One* of self.fToClean*.write('') and .close()
             #     seems to be necessary for the current test suite.
@@ -1028,7 +1045,7 @@
             #     the result of this test anymore. That test also
             #     now requires *two* manual EOF's to finish. ???
             if self.fToCleanRd:
-                # Necessary to notify, and possible unwedge, the
+                # Necessary to notify, and possibly unwedge, the
                 # process' stdin object (either an IOBuffer, or a user
                 # supplied object).
                 logres.info("[%s] OutFileProxy: closing additional file "\
Change 42424 by trentm@trentm-razor on 2002/06/28 17:45:30

	Launch commands via COMSPEC or w9xpopen.exe as does popen*() on Windows
	(see posixmodule.c in the Python source). This allows one to launch, say,
	"dir" which is implemented in the shell. As well, it means that quotes make
	is through the CreateProcess correctly. E.g. 'echo hello "there"'
	erroneously returned 'hello there' before this.
	
	Add a test for this and fix test_cwd to test properly with this change.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#17 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cmd.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#5 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#17 (text) ====

@@ -98,13 +98,6 @@
 #   o handling failure to launch, what are the semantics
 #   - make it work for linux too
 #
-#BUGS:
-#   - os.system('dir') and os.popen('dir') run Windows' shell 'dir'
-#     function. ProcessProxy(['dir']).start() runs dir.exe on my PATH. What
-#     is up?
-#     Look at Modules/posixmodule.c::_PyPopenCreateProcessProxy() it launches
-#     stuff via $COMSPEC and/or w9xpopen.exe. Do that too.
-#
 
 import os
 import sys
@@ -457,7 +450,7 @@
                  "bufsize=%r, stdin=%r, stdout=%r, stderr=%r)",
                  cmd, mode, cwd, env, bufsize, stdin, stdout, stderr)
         if type(cmd) in (types.ListType, types.TupleType):
-            # And arg vector was passed in.
+            # An arg vector was passed in.
             self._cmd = _joinArgv(cmd)
         else:
             self._cmd = cmd
@@ -609,11 +602,42 @@
             si.hStdError = hChildStderrWr
             si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
+            # Fixup the command string to spawn.
+            # (Lifted from posixmodule.c::_PyPopenCreateProcess().)
+            comspec = os.environ.get("COMSPEC", None)
+            if comspec is None:
+                raise ProcessError("Cannot locate a COMSPEC environment "\
+                                   "variable to use as the shell")
+            # Explicitly check if we are using COMMAND.COM.  If we
+            # are then use the w9xpopen hack.
+            elif win32api.GetVersion() < 0x80000000L and\
+                 os.path.basename(comspec).lower() != "command.com":
+                # NT/2000 and not using command.com.
+                cmd = comspec + " /c " + self._cmd
+            else:
+                # Oh gag, we're on Win9x or using COMMAND.COM. Use the
+                # workaround listed in KB: Q150956
+                w9xpopen = os.path.join(
+                    os.path.basename(win32api.GetModuleFileName(0)),
+                    'w9xpopen.exe')
+                if not os.path.exists(w9xpopen):
+                    # Eeek - file-not-found - possibly an embedding
+                    # situation - see if we can locate it in sys.exec_prefix
+                    w9xpopen = os.path.join(os.path.basename(sys.exec_prefix),
+                                            'w9xpopen.exe')
+                    if not os.path.exists(w9xpopen):
+                        raise ProcessError(\
+                            "Can not locate 'w9xpopen.exe' which is needed "\
+                            "for ProcessProxy to work with your shell or "\
+                            "platform.")
+                cmd = '%s "%s /c %s"' % (w9xpopen, comspec, self._cmd)
+            log.debug("cmd = %r", cmd)
+
             try:
                 self._hProcess, hThread, dwProcessId, dwThreadId\
                     = win32process.CreateProcess(
                         None,           # app name
-                        self._cmd,      # command line 
+                        cmd,            # command line 
                         None,           # process security attributes 
                         None,           # primary thread security attributes 
                         1,              # handles are inherited 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#5 (text) ====

@@ -28,7 +28,7 @@
     def test_cwd_specified(self):
         wd = "D:\\trentm"
 
-        p = process.ProcessProxy(['printcwd'], cwd=wd)
+        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -47,7 +47,7 @@
         wd = "mytmprelativedir"
         testsupport.mkdir(wd)
 
-        p = process.ProcessProxy(['printcwd'], cwd=wd)
+        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -63,7 +63,7 @@
         wd = "my tmp relative dir with spaces"
         testsupport.mkdir(wd)
 
-        p = process.ProcessProxy(['printcwd'], cwd=wd)
+        p = process.ProcessProxy([os.path.abspath('printcwd.exe')], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
Change 42038 by trentm@trentm-razor on 2002/06/21 12:39:36

	Trap errors when launching processes or with invalidly specified command
	dialog input and present them to the user in alert dialogs.
	r=shanec

Affected files ...

... //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/run/run.js#8 edit
... //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/run/run_functions.js#12 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#16 edit
... //depot/main/Apps/Komodo-devel/src/run/koIRunService.idl#5 edit
... //depot/main/Apps/Komodo-devel/src/run/koRunService.py#10 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/run/run.js#8 (text) ====

@@ -12,10 +12,6 @@
  * the various incarnations of ":!<shell-command>" in Vim.
  *
  * TODO:
- * - Use the InputBuffer stuff from kombo.js, as is used for goto.xul and
- *   find.xul. To do this the InputBuffer stuff should move out of kombo.js.
- *   This will probably happen when the launching of find.xul is moved out of
- *   kombo.js (where it does NOT belong). Wait for that.
  * - HTML documentation.
  * - "help" button in run dialog leading to this documentation
  */
@@ -131,9 +127,19 @@
     var doNotOpenOutputWindow = doNotOpenOutWinWidget.checked;
     var runIn = runInMenulist.value;
 
+    if (cmd == "") {
+        alertDialog("You must specify a command.");
+        return;
+    }
+    
     // Run the command.
-    Run_RunCommand(opener, cmd, cwd, env, insertOutput, operateOnSelection,
-                   doNotOpenOutputWindow, runIn);
+    var launched = Run_RunCommand(opener, cmd, cwd, env, insertOutput,
+                                  operateOnSelection, doNotOpenOutputWindow,
+                                  runIn);
+    if (! launched) {
+        // Don't close the window if there was an error launching.
+        return;
+    }
 
     // Add the command to the toolbox (need a better UI for this).
     if (addToToolboxWidget.checked) {

==== //depot/main/Apps/Komodo-devel/src/chrome/komodo/content/run/run_functions.js#12 (text) ====

@@ -260,11 +260,16 @@
 //      console window, in the command output pane (this is only meaningful if
 //      the ocmmand will be run interactively). See the koIPart_command IDL for
 //      a description of the exact strings to use.
+//
+// Returns true iff the command was launched successfully.
+//
 function Run_RunCommand(editor, command, cwd, env, insertOutput,
                         operateOnSelection, doNotOpenOutputWindow, runIn)
 {
     var runSvc = Components.classes["@activestate.com/koRunService;1"]
                  .getService(Components.interfaces.koIRunService);
+    var lastErrorSvc = Components.classes["@activestate.com/koLastErrorService;1"]
+                       .getService(Components.interfaces.koILastErrorService);
 
     var view = editor.gLastFocusedViewManager.getCurrentView();
     var scimoz = null;
@@ -278,17 +283,17 @@
         if (!view) {
             alertDialog("Cannot 'operate on selection' because there is " +
                         "no current file.");
-            return;
+            return false;
         } else if (scimoz.selText == "") {
             alertDialog("Cannot 'operate on selection' because the current " +
                         "file does not have a selection.");
-            return;
+            return false;
         }
     }
     if (insertOutput && !view) {
         alertDialog("Cannot 'insert output' because there is no current " +
                     "file in which to insert.");
-        return;
+        return false;
     }
 
     // Interpolate the command string.
@@ -323,47 +328,80 @@
     var process = null;
     if (operateOnSelection && view && scimoz.selText != "") {
         if (insertOutput) {
-            retval = runSvc.RunAndCaptureOutput(interpolated, cwd, env,
-                                                scimoz.selText,
-                                                outputObj, errorObj);
+            try {
+                retval = runSvc.RunAndCaptureOutput(interpolated, cwd, env,
+                                                    scimoz.selText,
+                                                    outputObj, errorObj);
+            } catch (ex) {
+                alertDialog(lastErrorSvc.getLastErrorMessage());
+                return false;
+            }
         } else {
             if (runIn == "command-output-window") {
                 editor.RunOutput_StartSession(interpolated);
                 termListener = new _koRunTerminationListener();
                 termListener.init(editor, interpolated);
-                process = runSvc.Run(interpolated, cwd, env,
-                                     editor.RunOutput_GetTerminal(),
-                                     termListener, scimoz.selText);
+                try {
+                    process = runSvc.Run(interpolated, cwd, env,
+                                         editor.RunOutput_GetTerminal(),
+                                         termListener, scimoz.selText);
+                } catch (ex) {
+                    alertDialog(lastErrorSvc.getLastErrorMessage());
+                    return false;
+                }
                 editor.RunOutput_SetProcessHandle(process);
                 if (! doNotOpenOutputWindow) {
                     editor.RunOutput_Show(editor);
                 }
             } else if (runIn == "new-console") {
-                runSvc.RunInConsole(interpolated, cwd, env, scimoz.selText);
+                try {
+                    runSvc.RunInConsole(interpolated, cwd, env,
+                                        scimoz.selText);
+                } catch (ex) {
+                    alertDialog(lastErrorSvc.getLastErrorMessage());
+                    return false;
+                }
             } else {
                 throw("Unexpected 'runIn' value: " + runIn + "\n");
             }
         }
     } else {
         if (insertOutput) {
-            retval = runSvc.RunAndCaptureOutput(interpolated, cwd, env, null,
-                                                outputObj, errorObj);
+            try {
+                retval = runSvc.RunAndCaptureOutput(interpolated, cwd, env,
+                                                    null, outputObj,
+                                                    errorObj);
+            } catch (ex) {
+                alertDialog(lastErrorSvc.getLastErrorMessage());
+                return false;
+            }
         } else {
             if (runIn == "command-output-window") {
                 editor.RunOutput_StartSession(interpolated);
                 termListener = new _koRunTerminationListener();
                 termListener.init(editor, interpolated);
-                process = runSvc.Run(interpolated, cwd, env,
-                                     editor.RunOutput_GetTerminal(),
-                                     termListener, null);
+                try {
+                    process = runSvc.Run(interpolated, cwd, env,
+                                         editor.RunOutput_GetTerminal(),
+                                         termListener, null);
+                } catch (ex) {
+                    alertDialog(lastErrorSvc.getLastErrorMessage());
+                    return false;
+                }
                 editor.RunOutput_SetProcessHandle(process);
                 if (! doNotOpenOutputWindow) {
                     editor.RunOutput_Show(editor);
                 }
             } else if (runIn == "new-console") {
-                runSvc.RunInConsole(interpolated, cwd, env, null);
+                try {
+                    runSvc.RunInConsole(interpolated, cwd, env, null);
+                } catch (ex) {
+                    alertDialog(lastErrorSvc.getLastErrorMessage());
+                    return false;
+                }
             } else {
                 throw("Unexpected 'runIn' value: " + runIn + "\n");
+                return false;
             }
         }
     }
@@ -390,5 +428,6 @@
         alertDialog("The command returned the following error output:\n"
                     + errorObj.value);
     }
+    return true;
 }
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#16 (text) ====

@@ -87,17 +87,15 @@
 #         closes the stdin proxy at all.
 #   o ensure get return value properly
 #   - ensure don't pop up consoles
-#   - proper termination (still have issue with
-#     ProcessProxy(stdout=sys.stdout) or what that for stdin?, but punting on
-#     that)
+#   o proper termination 
 #   - DavidA: if I specify "unbuffered" for my stdin handler (in the
 #     ProcessProxy constructor) then the stdin IOBuffer should do a
 #     fparent.read() rather than a fparent.readline(). TrentM: can I do
 #     that? What happens?
-#   - fit it into current invocation structure
-#   - passing in handlers, or callbacks?
+#   - Passing in handlers, or callbacks? Nah, Komodo side can handle
+#     that.
 #   o ensure can pass things like cwd and the environment to use
-#   - handling failure to launch, what are the semantics
+#   o handling failure to launch, what are the semantics
 #   - make it work for linux too
 #
 #BUGS:
@@ -127,7 +125,7 @@
 #---- exceptions
 
 class ProcessError(Exception):
-    def __init__(self, msg, errno=None):
+    def __init__(self, msg, errno=-1):
         Exception.__init__(self, msg)
         self.errno = errno
 
@@ -298,7 +296,7 @@
         else:
             self._cmd = cmd
         if not self._cmd:
-            raise ProcessError("You must specify a command to spawn.")
+            raise ProcessError("You must specify a command.")
         self._cwd = cwd
         self._env = env
         self._flags = flags
@@ -328,18 +326,21 @@
         #si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
         # Start the child process.
-        self._hProcess, self._hThread, self._processId, self._threadId\
-            = win32process.CreateProcess(
-                None,           # app name
-                self._cmd,      # command line 
-                None,           # process security attributes 
-                None,           # primary thread security attributes 
-                0,              # handles are inherited 
-                self._flags,    # creation flags 
-                self._env,      # environment
-                self._cwd,      # current working directory
-                si)             # STARTUPINFO pointer 
-        win32api.CloseHandle(self._hThread)
+        try:
+            self._hProcess, self._hThread, self._processId, self._threadId\
+                = win32process.CreateProcess(
+                    None,           # app name
+                    self._cmd,      # command line 
+                    None,           # process security attributes 
+                    None,           # primary thread security attributes 
+                    0,              # handles are inherited 
+                    self._flags,    # creation flags 
+                    self._env,      # environment
+                    self._cwd,      # current working directory
+                    si)             # STARTUPINFO pointer 
+            win32api.CloseHandle(self._hThread)
+        except win32api.error, ex:
+            raise ProcessError(msg=ex.args[2], errno=ex.args[0])
 
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
@@ -406,20 +407,26 @@
         self._file = file
         self._descriptor = descriptor
         self._handle = handle
+        self._closed = 0
 
+    def __del__(self):
+        self.close()
+
     def __getattr__(self, name):
         """Forward to the underlying file object."""
         return getattr(self._file, name)
 
     def close(self):
         """Close the handle when the file is closed."""
-        retval = self._file.close()
-        if self._handle is not None:
-            try:
-                win32api.CloseHandle(self._handle)
-            except win32api.error:
-                pass
-        return retval
+        if not self._closed:
+            retval = self._file.close()
+            if self._handle is not None:
+                try:
+                    win32api.CloseHandle(self._handle)
+                except win32api.error:
+                    pass
+            self._closed = 1
+            return retval
 
     def __repr__(self):
         return "<FileWrapper: file:%r fd:%r handle:%r"\
@@ -482,24 +489,39 @@
 
         # Ensure that all IOBuffer's are closed. If they are not, these
         # can cause hangs. 
-        if isinstance(self.stdin, IOBuffer):
-            # Do not close user-specified streams. That is their
-            # responsibility.
-            log.info("[%s] ProcessProxy: closing stdin (%r)."\
-                     % (id(self), self.stdin))
-            self.stdin.close()
-        if isinstance(self.stdout, IOBuffer):
-            # Do not close user-specified streams. That is their
-            # responsibility.
-            log.info("[%s] ProcessProxy: closing stdout (%r)."\
-                     % (id(self), self.stdout))
-            self.stdout.close()
-        if isinstance(self.stderr, IOBuffer):
-            # Do not close user-specified streams. That is their
-            # responsibility.
-            log.info("[%s] ProcessProxy: closing stderr (%r)."\
-                     % (id(self), self.stderr))
-            self.stderr.close()
+        try:
+            if isinstance(self.stdin, IOBuffer):
+                # Do not close user-specified streams. That is their
+                # responsibility.
+                log.info("[%s] ProcessProxy: closing stdin (%r)."\
+                         % (id(self), self.stdin))
+                self.stdin.close()
+        except AttributeError:
+            # May not have gotten far enough in the __init__ to set
+            # self.stdin, etc.
+            pass
+        try:
+            if isinstance(self.stdout, IOBuffer):
+                # Do not close user-specified streams. That is their
+                # responsibility.
+                log.info("[%s] ProcessProxy: closing stdout (%r)."\
+                         % (id(self), self.stdout))
+                self.stdout.close()
+        except AttributeError:
+            # May not have gotten far enough in the __init__ to set
+            # self.stdin, etc.
+            pass
+        try:
+            if isinstance(self.stderr, IOBuffer):
+                # Do not close user-specified streams. That is their
+                # responsibility.
+                log.info("[%s] ProcessProxy: closing stderr (%r)."\
+                         % (id(self), self.stderr))
+                self.stderr.close()
+        except AttributeError:
+            # May not have gotten far enough in the __init__ to set
+            # self.stdin, etc.
+            pass
 
     def _start(self):
         # Create pipes for std handles.
@@ -512,97 +534,103 @@
         hChildStdoutRd, hChildStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
         hChildStderrRd, hChildStderrWr = win32pipe.CreatePipe(saAttr, 0) 
 
-        # Duplicate the parent ends of the pipes so they are not
-        # inherited. 
-        hChildStdinWrDup = win32api.DuplicateHandle(
-            win32api.GetCurrentProcess(),
-            hChildStdinWr,
-            win32api.GetCurrentProcess(),
-            0,
-            0, # not inherited
-            win32con.DUPLICATE_SAME_ACCESS)
-        win32api.CloseHandle(hChildStdinWr)
-        self._hChildStdinWr = hChildStdinWrDup
-        hChildStdoutRdDup = win32api.DuplicateHandle(
-            win32api.GetCurrentProcess(),
-            hChildStdoutRd,
-            win32api.GetCurrentProcess(),
-            0,
-            0, # not inherited
-            win32con.DUPLICATE_SAME_ACCESS)
-        win32api.CloseHandle(hChildStdoutRd)
-        self._hChildStdoutRd = hChildStdoutRdDup
-        hChildStderrRdDup = win32api.DuplicateHandle(
-            win32api.GetCurrentProcess(),
-            hChildStderrRd,
-            win32api.GetCurrentProcess(),
-            0,
-            0, # not inherited
-            win32con.DUPLICATE_SAME_ACCESS)
-        win32api.CloseHandle(hChildStderrRd)
-        self._hChildStderrRd = hChildStderrRdDup
+        try:
+            # Duplicate the parent ends of the pipes so they are not
+            # inherited. 
+            hChildStdinWrDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStdinWr,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStdinWr)
+            self._hChildStdinWr = hChildStdinWrDup
+            hChildStdoutRdDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStdoutRd,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStdoutRd)
+            self._hChildStdoutRd = hChildStdoutRdDup
+            hChildStderrRdDup = win32api.DuplicateHandle(
+                win32api.GetCurrentProcess(),
+                hChildStderrRd,
+                win32api.GetCurrentProcess(),
+                0,
+                0, # not inherited
+                win32con.DUPLICATE_SAME_ACCESS)
+            win32api.CloseHandle(hChildStderrRd)
+            self._hChildStderrRd = hChildStderrRdDup
 
-        # Set the translation mode and buffering.
-        # Note that setting the bufsize of the *read* end of pipes does
-        # not seem to affect buffering for that pipe (and perhaps it
-        # should not). This means that bufsize=0 will *not* cause stdout
-        # and stderr from the child to come in smoothly. Apparently it
-        # is up to the child end to set the handlers to be unbuffered.
-        # XXX Idea, set the current handlers to be unbuffered, then get
-        #     child to inherit *those* handles, then set the parent's
-        #     handlers back. Could that work?
-        if self._mode == 't':
-            flags = os.O_TEXT
-            mode = ''
-        else:
-            flags = 0
-            mode = 'b'
-        fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
-        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
-        fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
-        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
-        fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
-        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
+            # Set the translation mode and buffering.
+            # Note that setting the bufsize of the *read* end of pipes does
+            # not seem to affect buffering for that pipe (and perhaps it
+            # should not). This means that bufsize=0 will *not* cause stdout
+            # and stderr from the child to come in smoothly. Apparently it
+            # is up to the child end to set the handlers to be unbuffered.
+            # XXX Idea, set the current handlers to be unbuffered, then get
+            #     child to inherit *those* handles, then set the parent's
+            #     handlers back. Could that work?
+            if self._mode == 't':
+                flags = os.O_TEXT
+                mode = ''
+            else:
+                flags = 0
+                mode = 'b'
+            fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
+            fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
+            fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
+            fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
+            fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
+            fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
 
-        childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr,
-                                 self._hChildStdinWr)
-        logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
-                    id(self), childStdin)
-        childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd,
-                                  self._hChildStdoutRd)
-        logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
-                    id(self), childStdout)
-        childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd,
-                                  self._hChildStderrRd)
-        logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
-                    id(self), childStderr)
+            childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr,
+                                     self._hChildStdinWr)
+            logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
+                        id(self), childStdin)
+            childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd,
+                                      self._hChildStdoutRd)
+            logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
+                        id(self), childStdout)
+            childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd,
+                                      self._hChildStderrRd)
+            logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
+                        id(self), childStderr)
 
-        # Start the child process.
-        si = win32process.STARTUPINFO() 
-        si.dwFlags = win32process.STARTF_USESHOWWINDOW
-        si.wShowWindow = 0 # SW_HIDE
-        si.hStdInput = hChildStdinRd
-        si.hStdOutput = hChildStdoutWr
-        si.hStdError = hChildStderrWr
-        si.dwFlags |= win32process.STARTF_USESTDHANDLES
+            # Start the child process.
+            si = win32process.STARTUPINFO() 
+            si.dwFlags = win32process.STARTF_USESHOWWINDOW
+            si.wShowWindow = 0 # SW_HIDE
+            si.hStdInput = hChildStdinRd
+            si.hStdOutput = hChildStdoutWr
+            si.hStdError = hChildStderrWr
+            si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-        self._hProcess, hThread, dwProcessId, dwThreadId\
-            = win32process.CreateProcess(
-                None,           # app name
-                self._cmd,      # command line 
-                None,           # process security attributes 
-                None,           # primary thread security attributes 
-                1,              # handles are inherited 
-                0,              # creation flags 
-                self._env,      # environment
-                self._cwd,      # current working directory
-                si)             # STARTUPINFO pointer 
-        win32api.CloseHandle(hThread)
+            try:
+                self._hProcess, hThread, dwProcessId, dwThreadId\
+                    = win32process.CreateProcess(
+                        None,           # app name
+                        self._cmd,      # command line 
+                        None,           # process security attributes 
+                        None,           # primary thread security attributes 
+                        1,              # handles are inherited 
+                        0,              # creation flags 
+                        self._env,      # environment
+                        self._cwd,      # current working directory
+                        si)             # STARTUPINFO pointer 
+            except win32api.error, ex:
+                raise ProcessError(msg=ex.args[2], errno=ex.args[0])
+            win32api.CloseHandle(hThread)
 
-        # Close child ends of pipes on the parent's side.
-        win32file.CloseHandle(hChildStdinRd)
-        win32file.CloseHandle(hChildStdoutWr)
-        win32file.CloseHandle(hChildStderrWr)
+        finally:
+            # Close child ends of pipes on the parent's side (the
+            # parent's ends of the pipe are closed in the FileWrappers.)
+            win32file.CloseHandle(hChildStdinRd)
+            win32file.CloseHandle(hChildStdoutWr)
+            win32file.CloseHandle(hChildStderrWr)
 
         # Create proxy threads for the out pipes.
         stdinProxy = InFileProxy(self.stdin, childStdin, name='<stdin>')

==== //depot/main/Apps/Komodo-devel/src/run/koIRunService.idl#5 (text) ====

@@ -74,6 +74,9 @@
     //  "input" is an optional input string to pass to the child's
     //      stdin. If this is None/null/NULL then no input is sent to
     //      the child.
+    //
+    // If there is an error raised in any of the following the an error
+    // is set in the koILastErrorService.
 
     // Run the given command in the given terminal.
     koIRunProcess Run(in wstring command, in wstring cwd, in wstring env,

==== //depot/main/Apps/Komodo-devel/src/run/koRunService.py#10 (text) ====

@@ -11,9 +11,13 @@
 import threading
 import process
 import types
-from xpcom import components
+from xpcom import components, nsError, ServerException, COMException
 from koLogger import logWarning, logError, logDebug
 
+#---- globals
+
+_gLastErrorSvc = None
+
 
 #---- internal support stuff
 
@@ -228,6 +232,10 @@
     _reg_contractid_ = "@activestate.com/koRunService;1"
 
     def __init__(self):
+        global _gLastErrorSvc
+        _gLastErrorSvc = components.classes["@activestate.com/koLastErrorService;1"]\
+                         .getService(components.interfaces.koILastErrorService)
+
         if sys.platform.startswith("win"):
             if os.environ.has_key("SHELL"):
                 self.shell = os.environ["SHELL"]
@@ -354,18 +362,28 @@
 
         import process
         if input:
-            p = _KoRunProcessProxy(command, cwd=cwd, env=envDict,
-                                   stdout=terminal.stdout,
-                                   stderr=terminal.stderr)
+            try:
+                p = _KoRunProcessProxy(command, cwd=cwd, env=envDict,
+                                       stdout=terminal.stdout,
+                                       stderr=terminal.stderr)
+            except process.ProcessError, ex:
+                global _gLastErrorSvc
+                _gLastErrorSvc.setLastError(ex.errno, str(ex))
+                raise ServerException(nsError.NS_ERROR_FAILURE, str(ex))
             p.stdin.write(input)
             p.stdin.close()
         else:
-            p = _KoRunProcessProxy(command, cwd=cwd, env=envDict,
-                                   mode='b',
-                                   bufsize=0,  # ensure stdin is unbuffered
-                                   stdin=terminal.stdin,
-                                   stdout=terminal.stdout,
-                                   stderr=terminal.stderr)
+            try:
+                p = _KoRunProcessProxy(command, cwd=cwd, env=envDict,
+                                       mode='b',  # XXX need to expose this
+                                       bufsize=0, # ensure stdin is unbuffered
+                                       stdin=terminal.stdin,
+                                       stdout=terminal.stdout,
+                                       stderr=terminal.stderr)
+            except process.ProcessError, ex:
+                global _gLastErrorSvc
+                _gLastErrorSvc.setLastError(ex.errno, str(ex))
+                raise ServerException(nsError.NS_ERROR_FAILURE, str(ex))
 
         # If the user provides a termination listener (interface
         # koIRunTerminationListener), then setup a thread to notify of
@@ -395,9 +413,16 @@
         #    print line,
         #fin.close()
         #print "RUN: ----------------------------------------"
-        child = process.Process(cmdLine, cwd=cwd, env=env,
-                                flags=process.Process.CREATE_NEW_CONSOLE)
+        try:
+            child = process.Process(cmdLine, cwd=cwd, env=env,
+                                    flags=process.Process.CREATE_NEW_CONSOLE)
+        except process.ProcessError, ex:
+            global _gLastErrorSvc
+            _gLastErrorSvc.setLastError(ex.errno, str(ex))
+            raise ServerException(nsError.NS_ERROR_FAILURE, str(ex))
+
         retval = child.wait()
+
         try:
             os.unlink(scriptFileName)
         except OSError, ex:
@@ -532,7 +557,13 @@
         else:
             envDict = None
 
-        child = process.ProcessProxy(command, cwd=cwd, env=envDict)
+        try:
+            child = process.ProcessProxy(command, cwd=cwd, env=envDict)
+        except process.ProcessError, ex:
+            global _gLastErrorSvc
+            _gLastErrorSvc.setLastError(ex.errno, str(ex))
+            raise ServerException(nsError.NS_ERROR_FAILURE, str(ex))
+
         if input:
             child.stdin.write(input)
             child.stdin.close()
Change 41853 by trentm@trentm-razor on 2002/06/19 16:12:38

	   Refactor IOBuffer so it is easy to subclass and get the synchronization
	   logic for free (the upcoming run command output window terminal will use
	   this).
	
	   Also, correct some of the documentation and improve log messages.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#15 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#15 (text) ====

@@ -11,7 +11,6 @@
         # can specify a cwd, environment dictionary, stdout/stdin/stderr
         # file-like objects to communicate with the spawned process.
         p = ProcessProxy(cmd='...', ...)
-        p.start()
         #... use the various methods and attributes
 
     When your specifed process is spawned, ProcessProxy creates three proxy
@@ -27,7 +26,7 @@
     Examples:
       A simple 'hello world':
         >>> from process import ProcessProxy
-        >>> p = ProcessProxy(['echo', 'hello']).start()
+        >>> p = ProcessProxy(['echo', 'hello'])
         >>> p.stdout.read()
         'hello\r\n'
         >>> p.wait()   # .wait() returns the child's exit status
@@ -35,11 +34,11 @@
 
       Redirecting the stdout handler:
         >>> import sys
-        >>> p = ProcessProxy(['echo', 'hello'], stdout=sys.stdout).start()
+        >>> p = ProcessProxy(['echo', 'hello'], stdout=sys.stdout)
         hello
 
       Using stdin:
-        >>> p = ProcessProxy(['sort']).start()
+        >>> p = ProcessProxy(['sort'])
         >>> p.stdin.write('5\n')
         >>> p.stdin.write('2\n')
         >>> p.stdin.write('7\n')
@@ -48,7 +47,7 @@
         '2\n5\n7\n'
 
       Specifying environment variables:
-        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}']).start()
+        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}'])
         >>> p.stdout.read()
         ''
         >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}'],
@@ -57,7 +56,7 @@
         'bar'
 
       Killing a long running process:
-        >>> p = ProcessProxy(['perl', '-e', 'while (1) {}']).start()
+        >>> p = ProcessProxy(['perl', '-e', 'while (1) {}'])
         >>> try:
         ...     p.wait(0)  # poll to see if is process still running
         ... except ProcessError, ex:
@@ -68,6 +67,9 @@
         >>> p.kill(42)
         >>> p.wait()
         42
+
+      Providing objects for stdin/stdout/stderr:
+        XXX write this, mention IOBuffer subclassing.
 """
 #TODO:
 #   o the above (stdout good, stderr good, stdin good)
@@ -461,15 +463,15 @@
         self._env = env
         self._bufsize = bufsize
         if stdin is None:
-            self.stdin = IOBuffer('<stdin>')
+            self.stdin = IOBuffer(name='<stdin>')
         else:
             self.stdin = stdin
         if stdout is None:
-            self.stdout = IOBuffer('<stdout>')
+            self.stdout = IOBuffer(name='<stdout>')
         else:
             self.stdout = stdout
         if stderr is None:
-            self.stderr = IOBuffer('<stderr>')
+            self.stderr = IOBuffer(name='<stderr>')
         else:
             self.stderr = stderr
         self._start()
@@ -655,9 +657,15 @@
 
 class IOBuffer:
     """Want to be able to both read and write to this buffer from
-    difference threads and have the same read/write semantic as for a
+    difference threads and have the same read/write semantics as for a
     std handler.
 
+    This class is subclass-able. _doRead(), _doWrite(), _doReadline(),
+    _doClose(), _haveLine(), and _haveNumBytes() can be overridden for
+    specific functionality. The synchronization issues (block on read
+    until write provides the needed data, termination) are handled for
+    free.
+
     Would be nice to support:
         .readlines(sizehint=0)
 
@@ -670,20 +678,30 @@
     #   - Is performance a problem? This will likely be slower that
     #     StringIO.StringIO().
     #
-    def __init__(self, name=None):
+    def __init__(self, mutex=None, stateChange=None, name=None):
         """'name' can be set for debugging, it will be used in log messages."""
         if name is not None:
             self._name = name
         else:
             self._name = id(self)
         log.info("[%s] IOBuffer.__init__()" % self._name)
-        self._buf = ''
+
+        self.__buf = ''
         # A state change is defined as the buffer being closed or a
         # write occuring.
-        self._stateChange = threading.Condition()
-        self._mutex = threading.Lock()
+        if mutex is not None:
+            self._mutex = mutex
+        else:
+            self._mutex = threading.Lock()
+        if stateChange is not None:
+            self._stateChange = stateChange
+        else:
+            self._stateChange = threading.Condition()
         self._closed = 0
 
+    def _doWrite(self, s):
+        self.__buf += s  # Append to buffer.
+
     def write(self, s):
         log.info("[%s] IOBuffer.write(s=%r)" % (self._name, s))
         # Silently drop writes after the buffer has been close()'d.
@@ -696,7 +714,7 @@
             return
 
         self._mutex.acquire()
-        self._buf += s                  # Append to buffer.
+        self._doWrite(s)
         self._stateChange.acquire()
         self._stateChange.notifyAll()   # Notify of the write().
         self._stateChange.release()
@@ -705,6 +723,15 @@
     def writelines(self, list):
         self.write(''.join(list))
 
+    def _doRead(self, n):
+        """Pop 'n' bytes from the internal buffer and return them."""
+        if n < 0:
+            idx = len(self.__buf)
+        else:
+            idx = min(n, len(self.__buf))
+        retval, self.__buf = self.__buf[:idx], self.__buf[idx:]
+        return retval
+
     def read(self, n=-1):
         log.info("[%s] IOBuffer.read(n=%r)" % (self._name, n))
         log.info("[%s] IOBuffer.read(): wait for data" % self._name)
@@ -729,10 +756,11 @@
             #     hang. *Sometime* test_stdin::test_stdin_buffer() will
             #     hang. This was *before* I moved the
             #     _stateChange.acquire() and .release() calls out side
-            #     of the 'while 1:' here.
+            #     of the 'while 1:' here. ...and now they are back
+            #     inside.
             while 1:
                 if self._closed: break
-                if len(self._buf) >= n: break
+                if self._haveNumBytes(n): break
                 #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
                 #          % self._name)
                 self._stateChange.acquire()
@@ -743,25 +771,41 @@
         log.info("[%s] IOBuffer.read(): done waiting for data" % self._name)
 
         self._mutex.acquire()
-        if n < 0:
-            idx = len(self._buf)
+        retval = self._doRead(n)
+        self._mutex.release()
+        return retval
+
+    def _doReadline(self, n):
+        """Pop the front line (or n bytes of it, whichever is less) from
+        the internal buffer and return it.
+        """
+        idx = self.__buf.find('\n')
+        if idx == -1:
+            idx = len(self.__buf)
         else:
-            idx = min(n, len(self._buf))
-        retval, self._buf = self._buf[:idx], self._buf[idx:]
-        self._mutex.release()
+            idx += 1 # include the '\n'
+        if n is not None:
+            idx = min(idx, n) 
+        retval, self.__buf = self.__buf[:idx], self.__buf[idx:]
         return retval
 
-    def readline(self, length=None):
-        # Wait until there is a full line (or at least 'length' bytes)
+    def _haveLine(self):
+        return self.__buf.find('\n') != -1
+
+    def _haveNumBytes(self, n=None):
+        return len(self.__buf) >= n
+
+    def readline(self, n=None):
+        # Wait until there is a full line (or at least 'n' bytes)
         # in the buffer or until the buffer is closed, i.e. no more
         # writes will come.
-        log.info("[%s] IOBuffer.readline(length=%r)" % (self._name, length))
+        log.info("[%s] IOBuffer.readline(n=%r)" % (self._name, n))
 
         log.info("[%s] IOBuffer.readline(): wait for data" % self._name)
         while 1:
             if self._closed: break
-            if self._buf.find('\n') != -1: break
-            if length is not None and len(self._buf) >= length: break
+            if self._haveLine(): break
+            if n is not None and self._haveNumBytes(n): break
             self._stateChange.acquire()
             self._stateChange.wait()
             self._stateChange.release()
@@ -769,20 +813,17 @@
                  % self._name)
 
         self._mutex.acquire()
-        idx = self._buf.find('\n')
-        if idx == -1:
-            idx = len(self._buf)
-        else:
-            idx += 1 # include the '\n'
-        if length is not None:
-            idx = min(idx, length)
-        retval, self._buf = self._buf[:idx], self._buf[idx:]
+        retval = self._doReadline(n)
         self._mutex.release()
         return retval
 
+    def _doClose(self):
+        pass
+
     def close(self):
         if not self._closed:
             log.info("[%s] IOBuffer.close()" % self._name)
+            self._doClose()
             self._closed = 1
             self._stateChange.acquire()
             self._stateChange.notifyAll()   # Notify of the close().
@@ -802,12 +843,14 @@
         "fChild" is a Win32 handle to the a child process' output pipe.
         "name" can be set for debugging, it will be used in log messages.
         """
+        log.info("[%s, %s] InFileProxy.__init__(fChild=%r, fParent=%r)",
+                 name, id(self), fChild, fParent)
         threading.Thread.__init__(self, name=name)
         self.fChild = fChild
         self.fParent = fParent
 
     def run(self):
-        log.info("[%s] InFileProxy.run()" % self.getName())
+        log.info("[%s] InFileProxy: start" % self.getName())
         try:
             self._proxyFromParentToChild()
         finally:
@@ -817,6 +860,7 @@
                 log.info("[%s] InFileProxy: closing parent (%r)"\
                          % (self.getName(), self.fParent))
                 self.fParent.close()
+        log.info("[%s] InFileProxy: done" % self.getName())
 
     def _proxyFromParentToChild(self):
         # This is a reasonable buffer size, on Windows at least.
@@ -870,16 +914,13 @@
                 log.info("[%s] InFileProxy: read %d bytes from parent: %r"\
                          % (self.getName(), len(text), text))
 
+            log.info("[%s, %s] InFileProxy: writing %r to child (%r)",
+                     self.getName(), id(self), text, self.fChild)
             try:
-                log.debug("writing %r to child (%r)" % (text, self.fChild))
                 self.fChild.write(text)
-            except pywintypes.error, ex:
-                # Ignore errors for now, like "The pipe is being closed.",
-                # etc. XXX There *may* be errors we don't want to avoid.
-                # XXX Presuming that not being able to write any bytes
-                #     is indicated by raising an exception, whereas
-                #     win32file.WriteFile (previously used) would raise
-                #     *or* return nBytesWritten==0.
+            except IOError, ex:
+                # Ignore errors for now.
+                # XXX There *may* be errors we don't want to avoid.
                 log.info("[%s] InFileProxy: error writing to child (%r), "\
                          "closing: %s" % (self.getName(), self.fParent, ex))
                 break
@@ -900,6 +941,9 @@
             of this proxy.
         "name" can be set for debugging, it will be used in log messages.
         """
+        log.info("[%s] OutFileProxy.__init__(fChild=%r, fParent=%r, "\
+                 "fToCleanRd=%r, fToCleanWr=%r)", name, fChild, fParent,
+                 fToCleanRd, fToCleanWr)
         threading.Thread.__init__(self, name=name)
         self.fChild = fChild
         self.fParent = fParent
@@ -907,7 +951,7 @@
         self.fToCleanWr = fToCleanWr
 
     def run(self):
-        log.info("[%s] OutFileProxy.run()" % self.getName())
+        log.info("[%s] OutFileProxy: start" % self.getName())
         try:
             self._proxyFromChildToParent()
         finally:
@@ -921,7 +965,7 @@
                          % (self.getName(), self.fParent))
                 self.fParent.close()
             #XXX Are these both necessary?
-            # XXX *One* of cleanOnTermination.write('') and .close()
+            # XXX *One* of self.fToClean*.write('') and .close()
             #     seems to be necessary for the current test suite.
             #     Which one is appropriate? The latter seems more
             #     so, but that is just a shallow guess.
@@ -932,6 +976,9 @@
             #     the result of this test anymore. That test also
             #     now requires *two* manual EOF's to finish. ???
             if self.fToCleanRd:
+                # Necessary to notify, and possible unwedge, the
+                # process' stdin object (either an IOBuffer, or a user
+                # supplied object).
                 logres.info("[%s] OutFileProxy: closing additional file "\
                             "after closing parent: %r", self.getName(),
                             self.fToCleanRd)
@@ -941,6 +988,7 @@
                             "after closing parent: %r", self.getName(),
                             self.fToCleanWr)
                 self.fToCleanWr.close()
+        log.info("[%s] OutFileProxy: done" % self.getName())
 
     def _proxyFromChildToParent(self):
         # A larger read chunk size results in undesired buffering of
Change 41810 by trentm@trentm-razor on 2002/06/19 11:04:44

	   Now that the FileWrappers are properly managing the lifetime of the child
	   file handles these do not need to be persisted as attributes on the
	   ProcessProxy object.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#14 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#14 (text) ====

@@ -555,20 +555,23 @@
         else:
             flags = 0
             mode = 'b'
-        self._fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
-        self._fChildStdinWr = os.fdopen(self._fdChildStdinWr, 'w'+mode, self._bufsize)
-        self._fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
-        self._fChildStdoutRd = os.fdopen(self._fdChildStdoutRd, 'r'+mode, self._bufsize)
-        self._fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
-        self._fChildStderrRd = os.fdopen(self._fdChildStderrRd, 'r'+mode, self._bufsize)
+        fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
+        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
+        fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
+        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
+        fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
+        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
 
-        childStdin = FileWrapper(self._fChildStdinWr, self._fdChildStdinWr, self._hChildStdinWr)
+        childStdin = FileWrapper(fChildStdinWr, fdChildStdinWr,
+                                 self._hChildStdinWr)
         logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
                     id(self), childStdin)
-        childStdout = FileWrapper(self._fChildStdoutRd, self._fdChildStdoutRd, self._hChildStdoutRd)
+        childStdout = FileWrapper(fChildStdoutRd, fdChildStdoutRd,
+                                  self._hChildStdoutRd)
         logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
                     id(self), childStdout)
-        childStderr = FileWrapper(self._fChildStderrRd, self._fdChildStderrRd, self._hChildStderrRd)
+        childStderr = FileWrapper(fChildStderrRd, fdChildStderrRd,
+                                  self._hChildStderrRd)
         logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
                     id(self), childStderr)
 
Change 41807 by trentm@trentm-razor on 2002/06/19 10:51:34

	   Explicitly close the child stdout/stderr handler on OutFileProxy
	   termination. This obviates the need to do so in ProcessProxy.__del__.
	
	   Also, find and unregister zombie processes when a new ProcessProxy is
	   registered. Over long heavy usage this helps to clean up unused memory (and
	   possibly resources) that would otherwise stick around until Python
	   terminates. (Note: it is possible that the current _(un)registerProcess()
	   scheme is no longer necesary with the recent resource usage cleanup. Not
	   sure.)

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#13 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#13 (text) ====

@@ -222,33 +222,33 @@
     return cmdstr
 
 
-# Maintain references to all spawned processes to avoid hangs.
-# If the user lets the a ProcessProxy object go out of scope before the
-# process has terminated, it is possible to get a hang (at least on the
-# win32api.CloseHandle(<stdin handle>) in the __del__() method). A
-# reference is removed from this list when the process's .wait or .kill
-# method is called.
+# Maintain references to all spawned ProcessProxy objects to avoid hangs.
+#   Otherwise, if the user lets the a ProcessProxy object go out of
+#   scope before the process has terminated, it is possible to get a
+#   hang (at least it *used* to be so when we had the
+#   win32api.CloseHandle(<stdin handle>) call in the __del__() method).
+# A reference is removed from this list when the process's .wait or
+# .kill method is called.
 # XXX Should an atexit() handler be registered to kill all curently
 #     running processes? Else *could* get hangs, n'est ce pas?
 def _registerProcess(process):
     global _processes
     log.info("_registerprocess(process=%r)", process)
 
-    # XXX This *does* help to clean up the stdout/stderr handles
-    #     earlier for some common use cases. Investigate having this
-    #     cleanup be done in the proxy threads instead before turning
-    #     this on.
-##    # Clean up finished processes.
-##    for p in _processes[:]: # use copy of _process, because we may modifiy it
-##        try:
-##            p.wait(0.1)  # poll to see if is process still running
-##            _unregisterProcess(p)
-##            del p
-##        except ProcessError, ex:
-##            if ex.errno == ProcessProxy.WAIT_TIMEOUT:
-##                pass
-##            else:
-##                raise
+    # Clean up zombie processes.
+    #   If the user does not call .wait() or .kill() on processes then
+    #   the ProcessProxy object will not get cleaned up until Python
+    #   exits and _processes goes out of scope. Under heavy usage that
+    #   is a big memory waste. Cleaning up here alleviates that.
+    for p in _processes[:]: # use copy of _process, because we may modifiy it
+        try:
+            p.wait(0)  # poll to see if is process still running
+            _unregisterProcess(p)
+        except ProcessError, ex:
+            if ex.errno == ProcessProxy.WAIT_TIMEOUT:
+                pass
+            else:
+                raise
         
     _processes.append(process)
 
@@ -499,33 +499,6 @@
                      % (id(self), self.stderr))
             self.stderr.close()
 
-        # Explicitly close saved pipe handles. These *would* normally be
-        # closed explicitly by the C runtime when their refcounts drop
-        # to zero. However (XXX for a reason I don't understand) these
-        # CloseHandle calls raise:
-        #   pywintypes.api_error: (6, 'CloseHandle', 'The handle is invalid.')
-        # *asynchronously*, i.e. in mainline code *following* where the
-        # ProcessProxy() object goes out of scope. Explicitly handling the
-        # closing (and catching) here avoids that. There may be a better
-        # way to handle this given the XXX above.
-        #XXX Should be able to close the 'childStdout', or is the other
-        #    .close() that comes with that undesireable? Likewise
-        #    'childStderr'.
-        # <stdin> is handled directly via the childStdin.close() calls
-        # in one or both of the <stdin> and <stdout> proxy threads.
-        logres.info("[%s] ProcessProxy: closing stdout handle (%r)."\
-                    % (id(self), self._hChildStdoutRd))
-        try:
-            win32api.CloseHandle(self._hChildStdoutRd)
-        except win32api.error:
-            pass
-        logres.info("[%s] ProcessProxy: closing stderr handle (%r)."\
-                    % (id(self), self._hChildStderrRd))
-        try:
-            win32api.CloseHandle(self._hChildStderrRd)
-        except win32api.error:
-            pass
-
     def _start(self):
         # Create pipes for std handles.
         # (Set the bInheritHandle flag so pipe handles are inherited.)
@@ -935,6 +908,9 @@
         try:
             self._proxyFromChildToParent()
         finally:
+            logres.info("[%s] OutFileProxy: terminating, close child (%r)",
+                        self.getName(), self.fChild)
+            self.fChild.close()
             if isinstance(self.fParent, IOBuffer):
                 # Do not close user-specified streams. That is their
                 # responsibility.
@@ -981,7 +957,7 @@
                 # Ignore: IOError: [Errno 9] Bad file descriptor
                 # XXX Do we *know* we want to do that?
                 log.info("[%s] OutFileProxy: error reading from child (%r), "\
-                         "closing: %s" % (self.getName(), self.fChild, ex))
+                         "shutting down: %s", self.getName(), self.fChild, ex)
                 break
             if not text:
                 # Empty text signifies that the pipe has been closed on
Change 41803 by trentm@trentm-razor on 2002/06/19 10:25:47

	Forgot to turn off debugging-level logging.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#12 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#12 (text) ====

@@ -183,7 +183,7 @@
     log = Logger("process", Logger.WARN)
 else:   # development/debugging usage
     log = Logger("process", Logger.DEBUG, sys.stdout)
-if 0:   # normal/production usage
+if 1:   # normal/production usage
     logres = Logger("process.res", Logger.WARN)
 else:   # development/debugging usage
     logres = Logger("process.res", Logger.DEBUG, sys.stdout)
Change 41802 by trentm@trentm-razor on 2002/06/19 10:23:46

	   Properly hold and cleanup system resources. In particular, ensure that file
	   handles are kept around for as long as needed to avoid system file
	   descriptors being reused before the associated file has been closed. Also
	   close the child stdin handler when the child file is closed, rather than
	   deferring to the ProcessProxy.__del__. (Closing of stdout/stderr handles is
	   still done in the ProcessProxy.__del__. A more suitable place will be
	   sought in a subsequent checkin.)
	
	   Specifics:
	   - Improve the internal logging, use a separate logging stream to track
	     system resource lifetimes.
	   - Add a FileWrapper class which encapsulates all the system handles for a
	     file and controls proper closing.
	   - Safer usage (I think) of IOBuffer _stateChange condition variable.
	   - Reduce chunk size when reading from a child's stdout/stderr to 1 byte to
	     avoid artificial buffering.
	   - Add new talk.cpp-generated .exe's to the test suite that have the child
	     directly call setvbuf to make std handlers unbuffered.
	   - New tests for (1) system resource lifetime handling (these hang without
	     the changes applied in this checkin) and (2) unbuffered comminucation
	     with a child process.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#11 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#5 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#11 (text) ====

@@ -60,7 +60,7 @@
         >>> p = ProcessProxy(['perl', '-e', 'while (1) {}']).start()
         >>> try:
         ...     p.wait(0)  # poll to see if is process still running
-        ... except ProcessProxyError, ex:
+        ... except ProcessError, ex:
         ...     if ex.errno == ProcessProxy.WAIT_TIMEOUT:
         ...             print "process is still running"
         ...
@@ -134,11 +134,12 @@
 
 class Logger:
     DEBUG, INFO, WARN, ERROR, FATAL = range(5)
-    def __init__(self, threshold=None, streamOrFileName=sys.stderr):
-        if threshold is None:
-            self.threshold = self.WARN
+    def __init__(self, name, level=None, streamOrFileName=sys.stderr):
+        self.name = name
+        if level is None:
+            self.level = self.WARN
         else:
-            self.threshold = threshold
+            self.level = level
         if type(streamOrFileName) == types.StringType:
             self.stream = open(streamOrFileName, 'w')
             self._opennedStream = 1
@@ -158,9 +159,9 @@
         }
         return levelNameMap[level]
     def log(self, level, msg, *args):
-        if level < self.threshold:
+        if level < self.level:
             return
-        message = "%s: " % self._getLevelName(level).lower()
+        message = "%s: %s:" % (self.name, self._getLevelName(level).lower())
         message = message + (msg % args) + "\n"
         self.stream.write(message)
         self.stream.flush()
@@ -175,10 +176,17 @@
     def fatal(self, msg, *args):
         self.log(self.FATAL, msg, *args)
 
+# Loggers:
+#   - 'log' to log normal process handling
+#   - 'logres' to track system resource life
 if 1:   # normal/production usage
-    log = Logger(Logger.WARN)
+    log = Logger("process", Logger.WARN)
+else:   # development/debugging usage
+    log = Logger("process", Logger.DEBUG, sys.stdout)
+if 0:   # normal/production usage
+    logres = Logger("process.res", Logger.WARN)
 else:   # development/debugging usage
-    log = Logger(Logger.DEBUG)
+    logres = Logger("process.res", Logger.DEBUG, sys.stdout)
 
 
 #---- globals
@@ -220,14 +228,36 @@
 # win32api.CloseHandle(<stdin handle>) in the __del__() method). A
 # reference is removed from this list when the process's .wait or .kill
 # method is called.
+# XXX Should an atexit() handler be registered to kill all curently
+#     running processes? Else *could* get hangs, n'est ce pas?
 def _registerProcess(process):
     global _processes
+    log.info("_registerprocess(process=%r)", process)
+
+    # XXX This *does* help to clean up the stdout/stderr handles
+    #     earlier for some common use cases. Investigate having this
+    #     cleanup be done in the proxy threads instead before turning
+    #     this on.
+##    # Clean up finished processes.
+##    for p in _processes[:]: # use copy of _process, because we may modifiy it
+##        try:
+##            p.wait(0.1)  # poll to see if is process still running
+##            _unregisterProcess(p)
+##            del p
+##        except ProcessError, ex:
+##            if ex.errno == ProcessProxy.WAIT_TIMEOUT:
+##                pass
+##            else:
+##                raise
+        
     _processes.append(process)
 
 def _unregisterProcess(process):
     global _processes
+    log.info("_unregisterProcess(process=%r)", process)
     try:
         _processes.remove(process)
+        del process
     except ValueError:
         pass
 
@@ -258,8 +288,8 @@
         "env" is an environment dictionary for the child.
         "flags" are system-specific process creation flags.
         """
-        log.info("Process.__init__(cmd=%r, cwd=%r, env=%r, flags=%r)"\
-                 % (cmd, cwd, env, flags))
+        log.info("Process.__init__(cmd=%r, cwd=%r, env=%r, flags=%r)",
+                 cmd, cwd, env, flags)
         if type(cmd) in (types.ListType, types.TupleType):
             # And arg vector was passed in.
             self._cmd = _joinArgv(cmd)
@@ -368,6 +398,32 @@
             win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
 
 
+class FileWrapper:
+    """Wrap a system file object, hiding some nitpicky details."""
+    def __init__(self, file, descriptor, handle):
+        self._file = file
+        self._descriptor = descriptor
+        self._handle = handle
+
+    def __getattr__(self, name):
+        """Forward to the underlying file object."""
+        return getattr(self._file, name)
+
+    def close(self):
+        """Close the handle when the file is closed."""
+        retval = self._file.close()
+        if self._handle is not None:
+            try:
+                win32api.CloseHandle(self._handle)
+            except win32api.error:
+                pass
+        return retval
+
+    def __repr__(self):
+        return "<FileWrapper: file:%r fd:%r handle:%r"\
+               % (self._file, self._descriptor, self._handle)
+
+
 class ProcessProxy(Process):
     """Create a process and proxy communication via the standard handles.
     """
@@ -389,8 +445,8 @@
     def __init__(self, cmd, mode='t', cwd=None, env=None, bufsize=-1,
                  stdin=None, stdout=None, stderr=None):
         log.info("ProcessProxy.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
-                 "stdin=%r, stdout=%r, stderr=%r)"\
-                 % (cmd, mode, cwd, env, stdin, stdout, stderr))
+                 "bufsize=%r, stdin=%r, stdout=%r, stderr=%r)",
+                 cmd, mode, cwd, env, bufsize, stdin, stdout, stderr)
         if type(cmd) in (types.ListType, types.TupleType):
             # And arg vector was passed in.
             self._cmd = _joinArgv(cmd)
@@ -452,14 +508,19 @@
         # ProcessProxy() object goes out of scope. Explicitly handling the
         # closing (and catching) here avoids that. There may be a better
         # way to handle this given the XXX above.
-        try:
-            win32api.CloseHandle(self._hChildStdinWr)
-        except win32api.error:
-            pass
+        #XXX Should be able to close the 'childStdout', or is the other
+        #    .close() that comes with that undesireable? Likewise
+        #    'childStderr'.
+        # <stdin> is handled directly via the childStdin.close() calls
+        # in one or both of the <stdin> and <stdout> proxy threads.
+        logres.info("[%s] ProcessProxy: closing stdout handle (%r)."\
+                    % (id(self), self._hChildStdoutRd))
         try:
             win32api.CloseHandle(self._hChildStdoutRd)
         except win32api.error:
             pass
+        logres.info("[%s] ProcessProxy: closing stderr handle (%r)."\
+                    % (id(self), self._hChildStderrRd))
         try:
             win32api.CloseHandle(self._hChildStderrRd)
         except win32api.error:
@@ -521,12 +582,22 @@
         else:
             flags = 0
             mode = 'b'
-        fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
-        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
-        fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
-        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
-        fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
-        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
+        self._fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
+        self._fChildStdinWr = os.fdopen(self._fdChildStdinWr, 'w'+mode, self._bufsize)
+        self._fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
+        self._fChildStdoutRd = os.fdopen(self._fdChildStdoutRd, 'r'+mode, self._bufsize)
+        self._fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
+        self._fChildStderrRd = os.fdopen(self._fdChildStderrRd, 'r'+mode, self._bufsize)
+
+        childStdin = FileWrapper(self._fChildStdinWr, self._fdChildStdinWr, self._hChildStdinWr)
+        logres.info("[%s] ProcessProxy._start(): create child stdin: %r",
+                    id(self), childStdin)
+        childStdout = FileWrapper(self._fChildStdoutRd, self._fdChildStdoutRd, self._hChildStdoutRd)
+        logres.info("[%s] ProcessProxy._start(): create child stdout: %r",
+                    id(self), childStdout)
+        childStderr = FileWrapper(self._fChildStderrRd, self._fdChildStderrRd, self._hChildStderrRd)
+        logres.info("[%s] ProcessProxy._start(): create child stderr: %r",
+                    id(self), childStderr)
 
         # Start the child process.
         si = win32process.STARTUPINFO() 
@@ -537,7 +608,6 @@
         si.hStdError = hChildStderrWr
         si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-        log.info("ProcessProxy.start(): call CreateProcess(cmd=%r)" % self._cmd)
         self._hProcess, hThread, dwProcessId, dwThreadId\
             = win32process.CreateProcess(
                 None,           # app name
@@ -557,16 +627,17 @@
         win32file.CloseHandle(hChildStderrWr)
 
         # Create proxy threads for the out pipes.
-        stdinProxy = InFileProxy(self.stdin, fChildStdinWr, name='<stdin>')
+        stdinProxy = InFileProxy(self.stdin, childStdin, name='<stdin>')
         stdinProxy.start()
         # Clean up the parent's side of <stdin> when it is observed that
         # the child has closed its side of <stdout>. (This is one way of
         # determining when it is appropriate to clean up this pipe, with
         # compromises. See the discussion at the top of this module.)
-        stdoutProxy = OutFileProxy(fChildStdoutRd, self.stdout,
-                                   self.stdin, name='<stdout>')
+        stdoutProxy = OutFileProxy(childStdout, self.stdout, 
+                                   self.stdin, childStdin,
+                                   name='<stdout>')
         stdoutProxy.start()
-        stderrProxy = OutFileProxy(fChildStderrRd, self.stderr,
+        stderrProxy = OutFileProxy(childStderr, self.stderr,
                                    name='<stderr>')
         stderrProxy.start()
 
@@ -611,14 +682,6 @@
     difference threads and have the same read/write semantic as for a
     std handler.
 
-    Supported methods:
-        .write(s)
-        .writelines(lines)
-        .read(n=-1)
-        .readline(length=None)
-        .flush()   # No-op
-        .close()
-
     Would be nice to support:
         .readlines(sizehint=0)
 
@@ -672,15 +735,15 @@
         if n < 0:
             # Wait until the buffer is closed, i.e. no more writes will
             # come.
-            self._stateChange.acquire()
             while 1:
                 if self._closed: break
                 #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
                 #          % self._name)
+                self._stateChange.acquire()
                 self._stateChange.wait()
+                self._stateChange.release()
                 #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
                 #          % self._name)
-            self._stateChange.release()
         else:
             # Wait until there are the requested number of bytes to read
             # (or until the buffer is closed, i.e. no more writes will
@@ -691,16 +754,16 @@
             #     hang. This was *before* I moved the
             #     _stateChange.acquire() and .release() calls out side
             #     of the 'while 1:' here.
-            self._stateChange.acquire()
             while 1:
                 if self._closed: break
                 if len(self._buf) >= n: break
                 #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
                 #          % self._name)
+                self._stateChange.acquire()
                 self._stateChange.wait()
+                self._stateChange.release()
                 #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
                 #          % self._name)
-            self._stateChange.release()
         log.info("[%s] IOBuffer.read(): done waiting for data" % self._name)
 
         self._mutex.acquire()
@@ -719,13 +782,13 @@
         log.info("[%s] IOBuffer.readline(length=%r)" % (self._name, length))
 
         log.info("[%s] IOBuffer.readline(): wait for data" % self._name)
-        self._stateChange.acquire()
         while 1:
             if self._closed: break
             if self._buf.find('\n') != -1: break
             if length is not None and len(self._buf) >= length: break
+            self._stateChange.acquire()
             self._stateChange.wait()
-        self._stateChange.release()
+            self._stateChange.release()
         log.info("[%s] IOBuffer.readline(): done waiting for data"\
                  % self._name)
 
@@ -744,51 +807,54 @@
     def close(self):
         if not self._closed:
             log.info("[%s] IOBuffer.close()" % self._name)
+            self._closed = 1
             self._stateChange.acquire()
-            self._closed = 1
             self._stateChange.notifyAll()   # Notify of the close().
             self._stateChange.release()
 
     def flush(self):
         log.info("[%s] IOBuffer.flush()" % self._name)
+        #XXX Perhaps flush() should unwedged possible waiting .read()
+        #    and .readline() calls that are waiting for more data???
 
 
 class InFileProxy(threading.Thread):
     """A thread to proxy stdin.write()'s from the parent to the child."""
-    def __init__(self, fparent, fchild, name):
+    def __init__(self, fParent, fChild, name=None):
         """
-        "fparent" is a Python file-like object setup for writing.
-        "fchild" is a Win32 handle to the a child process' output pipe.
+        "fParent" is a Python file-like object setup for writing.
+        "fChild" is a Win32 handle to the a child process' output pipe.
         "name" can be set for debugging, it will be used in log messages.
         """
         threading.Thread.__init__(self, name=name)
-        self.fchild = fchild
-        self.fparent = fparent
+        self.fChild = fChild
+        self.fParent = fParent
 
     def run(self):
         log.info("[%s] InFileProxy.run()" % self.getName())
         try:
             self._proxyFromParentToChild()
         finally:
-            if isinstance(self.fparent, IOBuffer):
+            if isinstance(self.fParent, IOBuffer):
                 # Do not close user-specified streams. That is their
                 # responsibility.
                 log.info("[%s] InFileProxy: closing parent (%r)"\
-                         % (self.getName(), self.fparent))
-                self.fparent.close()
+                         % (self.getName(), self.fParent))
+                self.fParent.close()
 
     def _proxyFromParentToChild(self):
         # This is a reasonable buffer size, on Windows at least.
         # Reducing this number will result in more 'ReadFile' calls.
         # Reducing it will NOT help to get output more smoothly from the
         # other end of the pipe (this is true for buffered and
-        # unbuffered I/O situations).
+        # unbuffered I/O situations). (Look at the BUFSIZE comments in
+        # OutFileProxy. Those may apply here at sometime.)
         BUFSIZE = 4096
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
             log.info("[%s] InFileProxy: waiting for read on parent (%r)"\
-                     % (self.getName(), self.fparent))
+                     % (self.getName(), self.fParent))
             # XXX Get hangs here (!) even with
             #     self.stdin.close() in ProcessProxy' __del__() under this
             #     cond:
@@ -797,25 +863,28 @@
             #     via <Ctrl-Z> to unlock this. How to get around that?
             #     See cleanOnTermination note in OutFileProxy.run()
             #     below.
-            #log.debug("XXX          -> start read on %r" % self.fparent)
+            #log.debug("XXX          -> start read on %r" % self.fParent)
             try:
                 # XXX Used to do .readline() here. Would that make
                 #     better sense in certain circumstances? Should
                 #     BUFSIZE be reduced now for smoother throughput?
-                text = self.fparent.read(BUFSIZE)
+                text = self.fParent.read(BUFSIZE)
             except ValueError, ex:
                 # ValueError is raised with trying to write to a closed
                 # file/pipe.
                 text = None
-            #log.debug("XXX          <- done read on %r" % self.fparent)
+            #log.debug("XXX          <- done read on %r" % self.fParent)
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the parent's end.
                 log.info("[%s] InFileProxy: observed close of parent (%r)"\
-                         % (self.getName(), self.fparent))
+                         % (self.getName(), self.fParent))
                 # Signal the child so it knows to stop listening.
                 try:
-                    self.fchild.close()
+                    logres.info("[%s] InFileProxy: closing child after "\
+                                "observing parent's close: %r", self.getName(),
+                                self.fChild)
+                    self.fChild.close()
                 except IOError, ex:
                     # Ignore: IOError: [Errno 9] Bad file descriptor
                     # XXX Do we *know* we want to do that?
@@ -826,8 +895,8 @@
                          % (self.getName(), len(text), text))
 
             try:
-                #log.debug("writing %r to child" % text)
-                self.fchild.write(text)
+                log.debug("writing %r to child (%r)" % (text, self.fChild))
+                self.fChild.write(text)
             except pywintypes.error, ex:
                 # Ignore errors for now, like "The pipe is being closed.",
                 # etc. XXX There *may* be errors we don't want to avoid.
@@ -836,83 +905,93 @@
                 #     win32file.WriteFile (previously used) would raise
                 #     *or* return nBytesWritten==0.
                 log.info("[%s] InFileProxy: error writing to child (%r), "\
-                         "closing: %s" % (self.getName(), self.fparent, ex))
+                         "closing: %s" % (self.getName(), self.fParent, ex))
                 break
             log.info("[%s] InFileProxy: wrote %d bytes to child: %r"\
                      % (self.getName(), len(text), text))
 
+
 class OutFileProxy(threading.Thread):
     """A thread to watch an "out" file from the spawned child process
     and pass on write's to the parent.
     """
-    def __init__(self, fchild, fparent, cleanOnTermination=None,
+    def __init__(self, fChild, fParent, fToCleanRd=None, fToCleanWr=None,
                  name=None):
         """
-        "fchild" is a Win32 handle to the a child process' output pipe.
-        "fparent" is a Python file-like object setup for writing.
+        "fChild" is a Win32 handle to the a child process' output pipe.
+        "fParent" is a Python file-like object setup for writing.
         "cleanOnTermination" is a file-like object to clean up on close
             of this proxy.
         "name" can be set for debugging, it will be used in log messages.
         """
         threading.Thread.__init__(self, name=name)
-        self.fchild = fchild
-        self.fparent = fparent
-        self.cleanOnTermination = cleanOnTermination
+        self.fChild = fChild
+        self.fParent = fParent
+        self.fToCleanRd = fToCleanRd
+        self.fToCleanWr = fToCleanWr
 
     def run(self):
         log.info("[%s] OutFileProxy.run()" % self.getName())
         try:
             self._proxyFromChildToParent()
         finally:
-            if isinstance(self.fparent, IOBuffer):
+            if isinstance(self.fParent, IOBuffer):
                 # Do not close user-specified streams. That is their
                 # responsibility.
                 log.info("[%s] OutFileProxy: closing parent (%r)"\
-                         % (self.getName(), self.fparent))
-                self.fparent.close()
-            if self.cleanOnTermination:
-                # XXX *One* of cleanOnTermination.write('') and .close()
-                #     seems to be necessary for the current test suite.
-                #     Which one is appropriate? The latter seems more
-                #     so, but that is just a shallow guess.
-                #self.cleanOnTermination.write('')
-                # XXX Doing this relieves the
-                #     must-<Enter>-to-term-test_stdin_sysstdin problem
-                #     but I don't think it is the right thing to do.
-                #     Over my head. Update: This does not seem to effect
-                #     the result of this test anymore. That test also
-                #     now requires *two* manual EOF's to finish. ???
-                self.cleanOnTermination.close()
+                         % (self.getName(), self.fParent))
+                self.fParent.close()
+            #XXX Are these both necessary?
+            # XXX *One* of cleanOnTermination.write('') and .close()
+            #     seems to be necessary for the current test suite.
+            #     Which one is appropriate? The latter seems more
+            #     so, but that is just a shallow guess.
+            # XXX Doing this relieves the
+            #     must-<Enter>-to-term-test_stdin_sysstdin problem
+            #     but I don't think it is the right thing to do.
+            #     Over my head. Update: This does not seem to effect
+            #     the result of this test anymore. That test also
+            #     now requires *two* manual EOF's to finish. ???
+            if self.fToCleanRd:
+                logres.info("[%s] OutFileProxy: closing additional file "\
+                            "after closing parent: %r", self.getName(),
+                            self.fToCleanRd)
+                self.fToCleanRd.close()
+            if self.fToCleanWr:
+                logres.info("[%s] OutFileProxy: closing additional file "\
+                            "after closing parent: %r", self.getName(),
+                            self.fToCleanWr)
+                self.fToCleanWr.close()
 
     def _proxyFromChildToParent(self):
-        # This is a reasonable buffer size, on Windows at least.
-        # Reducing this number will result in more 'ReadFile' calls.
-        # Reducing it will NOT help to get output more smoothly from the
-        # other end of the pipe (this is true for buffered and
-        # unbuffered I/O situations).
-        BUFSIZE = 4096
+        # A larger read chunk size results in undesired buffering of
+        # data for interaction with child. This may be a performance
+        # hit. XXX Perhaps there should be an option to specify the
+        # chunk size here?
+        BUFSIZE = 1
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
+            text = None
             try:
                 log.info("[%s] OutFileProxy: waiting for read on child (%r)"\
-                         % (self.getName(), self.fchild))
-                text = self.fchild.read(BUFSIZE)
+                         % (self.getName(), self.fChild))
+                text = self.fChild.read(BUFSIZE)
             except IOError, ex:
                 # Ignore: IOError: [Errno 9] Bad file descriptor
                 # XXX Do we *know* we want to do that?
                 log.info("[%s] OutFileProxy: error reading from child (%r), "\
-                         "closing: %s" % (self.getName(), self.fchild, ex))
+                         "closing: %s" % (self.getName(), self.fChild, ex))
                 break
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the child's end.
                 log.info("[%s] OutFileProxy: observed close of child (%r)"\
-                         % (self.getName(), self.fchild))
+                         % (self.getName(), self.fChild))
                 break
 
             log.info("[%s] OutFileProxy: text(len=%d): %r"\
                      % (self.getName(), len(text), text))
-            self.fparent.write(text)
+            self.fParent.write(text)
 
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#3 (text) ====

@@ -9,86 +9,138 @@
 LDFLAGS=kernel32.lib user32.lib gdi32.lib advapi32.lib shlwapi.lib
 RM=del
 
-talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe
+talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe ask_setvbuf.exe askw_setvbuf.exe ask_then_talk_setvbuf.exe ask_then_talklots_setvbuf.exe ask_then_talk_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.exe talk_setvbuf.exe talklots_setvbuf.exe talk_flushing_setvbuf.exe talklots_flushing_setvbuf.exe ask_then_talkw_setvbuf.exe ask_then_talklotsw_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe talkw_setvbuf.exe talklotsw_setvbuf.exe talk_flushingw_setvbuf.exe talklots_flushingw_setvbuf.exe quiet_setvbuf.exe quietw_setvbuf.exe hang_setvbuf.exe hangw_setvbuf.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe printenv_setvbuf.exe printenvw_setvbuf.exe
 
 
-ask.exe askw.exe: talk.cpp
+ask.exe askw.exe ask_setvbuf.exe askw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK  /Foask.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:ask.exe ask.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DASK  /Foaskw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:askw.exe askw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DASK  /Foask_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_setvbuf.exe ask_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DASK  /Foaskw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:askw_setvbuf.exe askw_setvbuf.obj
 
-ask_then_talk.exe ask_then_talkw.exe: talk.cpp
+ask_then_talk.exe ask_then_talkw.exe ask_then_talk_setvbuf.exe ask_then_talkw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK /DTALK  /Foask_then_talk.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talk.exe ask_then_talk.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DASK /DTALK  /Foask_then_talkw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talkw.exe ask_then_talkw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DASK /DTALK  /Foask_then_talk_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talk_setvbuf.exe ask_then_talk_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DASK /DTALK  /Foask_then_talkw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talkw_setvbuf.exe ask_then_talkw_setvbuf.obj
 
-ask_then_talklots.exe ask_then_talklotsw.exe: talk.cpp
+ask_then_talklots.exe ask_then_talklotsw.exe ask_then_talklots_setvbuf.exe ask_then_talklotsw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK /DTALKLOTS  /Foask_then_talklots.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talklots.exe ask_then_talklots.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DASK /DTALKLOTS  /Foask_then_talklotsw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talklotsw.exe ask_then_talklotsw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DASK /DTALKLOTS  /Foask_then_talklots_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talklots_setvbuf.exe ask_then_talklots_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DASK /DTALKLOTS  /Foask_then_talklotsw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talklotsw_setvbuf.exe ask_then_talklotsw_setvbuf.obj
 
-ask_then_talk_flushing.exe ask_then_talk_flushingw.exe: talk.cpp
+ask_then_talk_flushing.exe ask_then_talk_flushingw.exe ask_then_talk_flushing_setvbuf.exe ask_then_talk_flushingw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK /DTALK /DFLUSH  /Foask_then_talk_flushing.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talk_flushing.exe ask_then_talk_flushing.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DASK /DTALK /DFLUSH  /Foask_then_talk_flushingw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talk_flushingw.exe ask_then_talk_flushingw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DASK /DTALK /DFLUSH  /Foask_then_talk_flushing_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talk_flushing_setvbuf.exe ask_then_talk_flushing_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DASK /DTALK /DFLUSH  /Foask_then_talk_flushingw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talk_flushingw_setvbuf.exe ask_then_talk_flushingw_setvbuf.obj
 
-ask_then_talklots_flushing.exe ask_then_talklots_flushingw.exe: talk.cpp
+ask_then_talklots_flushing.exe ask_then_talklots_flushingw.exe ask_then_talklots_flushing_setvbuf.exe ask_then_talklots_flushingw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DASK /DTALKLOTS /DFLUSH  /Foask_then_talklots_flushing.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talklots_flushing.exe ask_then_talklots_flushing.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DASK /DTALKLOTS /DFLUSH  /Foask_then_talklots_flushingw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talklots_flushingw.exe ask_then_talklots_flushingw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DASK /DTALKLOTS /DFLUSH  /Foask_then_talklots_flushing_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:ask_then_talklots_flushing_setvbuf.exe ask_then_talklots_flushing_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DASK /DTALKLOTS /DFLUSH  /Foask_then_talklots_flushingw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:ask_then_talklots_flushingw_setvbuf.exe ask_then_talklots_flushingw_setvbuf.obj
 
-talk.exe talkw.exe: talk.cpp
+talk.exe talkw.exe talk_setvbuf.exe talkw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DTALK  /Fotalk.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:talk.exe talk.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DTALK  /Fotalkw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:talkw.exe talkw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DTALK  /Fotalk_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:talk_setvbuf.exe talk_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DTALK  /Fotalkw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:talkw_setvbuf.exe talkw_setvbuf.obj
 
-talklots.exe talklotsw.exe: talk.cpp
+talklots.exe talklotsw.exe talklots_setvbuf.exe talklotsw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DTALKLOTS  /Fotalklots.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:talklots.exe talklots.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DTALKLOTS  /Fotalklotsw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:talklotsw.exe talklotsw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DTALKLOTS  /Fotalklots_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:talklots_setvbuf.exe talklots_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DTALKLOTS  /Fotalklotsw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:talklotsw_setvbuf.exe talklotsw_setvbuf.obj
 
-talk_flushing.exe talk_flushingw.exe: talk.cpp
+talk_flushing.exe talk_flushingw.exe talk_flushing_setvbuf.exe talk_flushingw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DTALK /DFLUSH  /Fotalk_flushing.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:talk_flushing.exe talk_flushing.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DTALK /DFLUSH  /Fotalk_flushingw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:talk_flushingw.exe talk_flushingw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DTALK /DFLUSH  /Fotalk_flushing_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:talk_flushing_setvbuf.exe talk_flushing_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DTALK /DFLUSH  /Fotalk_flushingw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:talk_flushingw_setvbuf.exe talk_flushingw_setvbuf.obj
 
-talklots_flushing.exe talklots_flushingw.exe: talk.cpp
+talklots_flushing.exe talklots_flushingw.exe talklots_flushing_setvbuf.exe talklots_flushingw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DTALKLOTS /DFLUSH  /Fotalklots_flushing.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:talklots_flushing.exe talklots_flushing.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DTALKLOTS /DFLUSH  /Fotalklots_flushingw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:talklots_flushingw.exe talklots_flushingw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DTALKLOTS /DFLUSH  /Fotalklots_flushing_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:talklots_flushing_setvbuf.exe talklots_flushing_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DTALKLOTS /DFLUSH  /Fotalklots_flushingw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:talklots_flushingw_setvbuf.exe talklots_flushingw_setvbuf.obj
 
-quiet.exe quietw.exe: talk.cpp
+quiet.exe quietw.exe quiet_setvbuf.exe quietw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS    /Foquiet.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:quiet.exe quiet.obj
     $(CL) $(CFLAGS)    /D_WINDOWS            /Foquietw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:quietw.exe quietw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF   /Foquiet_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:quiet_setvbuf.exe quiet_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF   /Foquietw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:quietw_setvbuf.exe quietw_setvbuf.obj
 
-hang.exe hangw.exe: talk.cpp
+hang.exe hangw.exe hang_setvbuf.exe hangw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DHANG  /Fohang.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:hang.exe hang.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DHANG  /Fohangw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:hangw.exe hangw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DHANG  /Fohang_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:hang_setvbuf.exe hang_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DHANG  /Fohangw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:hangw_setvbuf.exe hangw_setvbuf.obj
 
-printcwd.exe printcwdw.exe: talk.cpp
+printcwd.exe printcwdw.exe printcwd_setvbuf.exe printcwdw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DCWD  /Foprintcwd.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:printcwd.exe printcwd.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DCWD  /Foprintcwdw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:printcwdw.exe printcwdw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DCWD  /Foprintcwd_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:printcwd_setvbuf.exe printcwd_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DCWD  /Foprintcwdw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:printcwdw_setvbuf.exe printcwdw_setvbuf.obj
 
-printenv.exe printenvw.exe: talk.cpp
+printenv.exe printenvw.exe printenv_setvbuf.exe printenvw_setvbuf.exe: talk.cpp
     $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DENV  /Foprintenv.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:console  /out:printenv.exe printenv.obj
     $(CL) $(CFLAGS)    /D_WINDOWS          /DENV  /Foprintenvw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:printenvw.exe printenvw.obj
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DSETVBUF /DENV  /Foprintenv_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:printenv_setvbuf.exe printenv_setvbuf.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DSETVBUF /DENV  /Foprintenvw_setvbuf.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:printenvw_setvbuf.exe printenvw_setvbuf.obj
 
 
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#3 (text) ====

@@ -32,6 +32,18 @@
 {
     logInfo("start\n");
 
+#ifdef SETVBUF
+    if ( setvbuf(stdin, NULL, _IONBF, 0) != 0 ) {
+        logInfo("setvbuf on stdin failed\n");
+    }
+    if ( setvbuf(stdout, NULL, _IONBF, 0) != 0 ) {
+        logInfo("setvbuf on stdout failed\n");
+    }
+    if ( setvbuf(stderr, NULL, _IONBF, 0) != 0 ) {
+        logInfo("setvbuf on stderr failed\n");
+    }
+#endif
+
 #ifdef ASK
     char name[1000];
     fprintf(stdout, "What is your name?\n");

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#6 (text) ====

@@ -46,6 +46,47 @@
         return output
 
 class StdinTestCase(unittest.TestCase):
+    def test_stdin_handle_cleanup_1(self):
+        p1 = process.ProcessProxy(['ask'])
+        p2 = process.ProcessProxy(['ask'])
+        p1.stdin.write("Trent\n")
+        p2.stdin.write("Andrew\n")
+        p1.stdin.close()
+        p2.stdin.close()
+
+        p1.wait()
+        del p1
+        p2.wait()
+
+        p1 = process.ProcessProxy(['ask'])
+        p2 = process.ProcessProxy(['ask'])
+        p1.stdin.write("Mick\n")
+        p1.stdin.close()
+
+        output = p1.stdout.read()
+        expected = "What is your name?\nYour name is 'Mick'.\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r" % output)
+        p2.kill()
+
+    def test_stdin_handle_cleanup_2(self):
+        p1 = process.ProcessProxy(['ask'])
+        p2 = process.ProcessProxy(['ask'])
+        p1.stdin.write("Trent\n")
+        p2.stdin.write("Andrew\n")
+        p1.stdin.close()
+        p2.stdin.close()
+
+        p1.wait()
+        p2.wait()
+
+        p1 = process.ProcessProxy(['ask'])
+        p2 = process.ProcessProxy(['ask'])
+        p1.stdin.write("Mick\n")
+        p1.stdin.close()
+
+        p2.kill()
+
     def test_stdin_buffer(self):
         p = process.ProcessProxy(['ask'])
         p.stdin.write("Trent\n")
@@ -77,11 +118,14 @@
         # not send it.
         time.sleep(6)
         # There should be no output, other that
-        self.failIf(len(p.stdout.log) > 1,
-                    "Stdout has unexpectedly received more writes than the "\
-                    "single 'What is your name?' write. The process should "\
-                    "be hung. log=%r" % p.stdout.log)
-        p.kill()
+        output = ''.join([item[2] for item in p.stdout.log])
+        try:
+            self.failUnless(output == "What is your name?\n",
+                "Stdout has unexpectedly received other than one "\
+                "'What is your name?' write. The process should "\
+                "be hung. log=%r" % p.stdout.log)
+        finally:
+            p.kill()
 
     ## This is left commented out because the use of 'sys.stdin' requires
     ## user interaction -- not really an automated test suite then.

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#5 (text) ====

@@ -31,9 +31,9 @@
         error = p.stderr.read()
         self.failUnless(error == 'e0e1e2e3e4')
 
-    def test_my_stdout(self):
+    def test_my_stdout_with_buffered_child(self):
         p = process.ProcessProxy(['talk'], stdout=MyOutFile(),
-                            stderr=MyOutFile())
+                                 stderr=MyOutFile())
         p.wait()
         self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
         self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
@@ -51,6 +51,21 @@
         #    possibly at all. How does Cygwin's bash do it? or 4DOS?
         ## Ensure that the writes came in one about every second.
 
+    def test_my_stdout_with_unbuffered_child(self):
+        p = process.ProcessProxy(['talk_setvbuf'], stdout=MyOutFile(),
+                                 stderr=MyOutFile())
+        p.wait()
+        self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
+        self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
+
+        # Ensure that the writes are spread over about 5 seconds.
+        writeEvents = [e for e in p.stdout.log if e[1] == 'write']
+        timespan = writeEvents[-1][0] - writeEvents[0][0]
+        epsilon = 1.0
+        self.failUnless(timespan > epsilon,
+                        "Write events were not spread over a few seconds."\
+                        "timespan=%r" % timespan)
+
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
     return unittest.makeSuite(StdoutTestCase)
Change 41663 by trentm@trentm-razor on 2002/06/17 13:44:04

	Add a bufsize option to control the pipe buffering between parent and
	child. Add a test case to ensure this is working for stdin. Add notes to
	explain why this can only be used to affect the stdin pipe.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#10 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#5 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#4 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#10 (text) ====

@@ -386,7 +386,7 @@
     #TODO:
     #   - .suspend() and .resume()? See Win32::Process Perl module.
     #
-    def __init__(self, cmd, mode='t', cwd=None, env=None,
+    def __init__(self, cmd, mode='t', cwd=None, env=None, bufsize=-1,
                  stdin=None, stdout=None, stderr=None):
         log.info("ProcessProxy.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
                  "stdin=%r, stdout=%r, stderr=%r)"\
@@ -403,6 +403,7 @@
             raise ProcessError("'mode' must be 't' or 'b'.")
         self._cwd = cwd
         self._env = env
+        self._bufsize = bufsize
         if stdin is None:
             self.stdin = IOBuffer('<stdin>')
         else:
@@ -469,7 +470,7 @@
         # (Set the bInheritHandle flag so pipe handles are inherited.)
         saAttr = pywintypes.SECURITY_ATTRIBUTES()
         saAttr.bInheritHandle = 1
-        #XXX Should try with os.pipe. Dunno what that does for
+        #XXX Should maybe try with os.pipe. Dunno what that does for
         #    inheritability though.
         hChildStdinRd, hChildStdinWr = win32pipe.CreatePipe(saAttr, 0) 
         hChildStdoutRd, hChildStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
@@ -505,7 +506,15 @@
         win32api.CloseHandle(hChildStderrRd)
         self._hChildStderrRd = hChildStderrRdDup
 
-        # Set the translation mode.
+        # Set the translation mode and buffering.
+        # Note that setting the bufsize of the *read* end of pipes does
+        # not seem to affect buffering for that pipe (and perhaps it
+        # should not). This means that bufsize=0 will *not* cause stdout
+        # and stderr from the child to come in smoothly. Apparently it
+        # is up to the child end to set the handlers to be unbuffered.
+        # XXX Idea, set the current handlers to be unbuffered, then get
+        #     child to inherit *those* handles, then set the parent's
+        #     handlers back. Could that work?
         if self._mode == 't':
             flags = os.O_TEXT
             mode = ''
@@ -513,17 +522,12 @@
             flags = 0
             mode = 'b'
         fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
-        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode)
+        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode, self._bufsize)
         fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
-        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode)
+        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode, self._bufsize)
         fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
-        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode)
+        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode, self._bufsize)
 
-        #XXX Look into setvbuf() to optionally make the pipe streams
-        #    unbuffered. Note that I don't know of a Python-level iface to
-        #    this so would have to write a small extension for this.
-        #    c.f. PyFile_SetBufSize()
-
         # Start the child process.
         si = win32process.STARTUPINFO() 
         si.dwFlags = win32process.STARTF_USESHOWWINDOW
@@ -555,6 +559,10 @@
         # Create proxy threads for the out pipes.
         stdinProxy = InFileProxy(self.stdin, fChildStdinWr, name='<stdin>')
         stdinProxy.start()
+        # Clean up the parent's side of <stdin> when it is observed that
+        # the child has closed its side of <stdout>. (This is one way of
+        # determining when it is appropriate to clean up this pipe, with
+        # compromises. See the discussion at the top of this module.)
         stdoutProxy = OutFileProxy(fChildStdoutRd, self.stdout,
                                    self.stdin, name='<stdout>')
         stdoutProxy.start()
@@ -863,12 +871,18 @@
                          % (self.getName(), self.fparent))
                 self.fparent.close()
             if self.cleanOnTermination:
-                self.cleanOnTermination.write('')
+                # XXX *One* of cleanOnTermination.write('') and .close()
+                #     seems to be necessary for the current test suite.
+                #     Which one is appropriate? The latter seems more
+                #     so, but that is just a shallow guess.
+                #self.cleanOnTermination.write('')
                 # XXX Doing this relieves the
                 #     must-<Enter>-to-term-test_stdin_sysstdin problem
                 #     but I don't think it is the right thing to do.
-                #     Over my head.
-                #self.cleanOnTermination.close()
+                #     Over my head. Update: This does not seem to effect
+                #     the result of this test anymore. That test also
+                #     now requires *two* manual EOF's to finish. ???
+                self.cleanOnTermination.close()
 
     def _proxyFromChildToParent(self):
         # This is a reasonable buffer size, on Windows at least.

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#5 (text) ====

@@ -4,11 +4,33 @@
 import sys
 import time
 import pprint
+import threading
 import unittest
 
 import process
 
 
+class MyInFile:
+    def __init__(self, buf):
+        self._inBuffer = buf
+        self._stateChange = threading.Condition()
+        self._closed = 0
+    def read(self, size):
+        #XXX Should this be a 'while' to wait until 'size' bytes and in
+        #    the _inBuffer before returning (unless _closed, of course).
+        if not self._closed and not self._inBuffer:
+            self._stateChange.acquire()
+            self._stateChange.wait()
+            self._stateChange.release()
+
+        text, self._inBuffer = self._inBuffer[:size], self._inBuffer[size:]
+        return text
+    def close(self):
+        self._stateChange.acquire()
+        self._closed = 1
+        self._stateChange.notifyAll()
+        self._stateChange.release()
+
 class MyOutFile:
     def __init__(self):
         self.log = []
@@ -118,6 +140,15 @@
                         "Pipes are not doing text translation."\
                         % (output, expected))
 
+    def test_stdin_buffering_with_mystdin(self):
+        p = process.ProcessProxy(['ask'], stdin=MyInFile("Trent\n"),
+                                 bufsize=0)
+        output = p.stdout.read()
+        expected = "What is your name?\nYour name is 'Trent'.\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r" % output)
+
+
 
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#4 (text) ====

@@ -39,7 +39,16 @@
         self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
 
         #XXX Cannot test this part until the setvbuf work is done to
-        #    make the child pipes unbuffered.
+        #    make the child pipes unbuffered. Update: even with the
+        #    setvbuf calls (done via os.fdopen(..., bufsize=0)) stdout
+        #    and stderr do *not* seem to be unbuffered. It *does* make a
+        #    difference for stdin though. Perhaps setvbuf can only be
+        #    used to affect *write* end of pipe, i.e. we cannot affect
+        #    what the child side of stdout/stderr will do. I suspect
+        #    that the only way to get this to work is to get the parent
+        #    side of stdout (and possibly stderr) to look like a tty.
+        #    This might require platform-specific hack, if it is indeed
+        #    possibly at all. How does Cygwin's bash do it? or 4DOS?
         ## Ensure that the writes came in one about every second.
 
 def suite():
Change 41311 by trentm@trentm-razor on 2002/06/11 14:43:27

	- s/Process/ProcessProxy/ to make room for a Process class that does not do
	  any of the std handler redirection and proxying.
	- Drop the .start() method used to initiate the actual process creation.
	  That is just done on __init__() now.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#9 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/ReadMe.txt#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#3 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#9 (text) ====

@@ -2,32 +2,32 @@
 """
     Python interface for process control.
 
-    This module defines a Process class that can be used to spawn,
+    This module defines a Process classes that can be used to spawn,
     communicate with, and control a process.
 
     Usage:
-        from process import Process
+        from process import ProcessProxy
         # You must specify at minimum a 'cmd' to spawn. Optionally you
         # can specify a cwd, environment dictionary, stdout/stdin/stderr
         # file-like objects to communicate with the spawned process.
-        p = Process(cmd='...', ...)
+        p = ProcessProxy(cmd='...', ...)
         p.start()
         #... use the various methods and attributes
 
-    When your specifed process is spawned, Process creates three proxy
+    When your specifed process is spawned, ProcessProxy creates three proxy
     threads (classes InFileProxy and OutFileProxy), one for each
     standard handle, which pump information between the calling Python
     code and the spawned child process. You can optionally pass in
-    file-like objects to Process.__init__ to be responsible for handling
+    file-like objects to ProcessProxy.__init__ to be responsible for handling
     incoming writes on stdout and stderr and for outgoing write on
-    stdin. If you do not specify such handlers, Process adds an IOBuffer
+    stdin. If you do not specify such handlers, ProcessProxy adds an IOBuffer
     object for each handle, on which you can read or write, as
     appropriate.
     
     Examples:
       A simple 'hello world':
-        >>> from process import Process
-        >>> p = Process(['echo', 'hello']).start()
+        >>> from process import ProcessProxy
+        >>> p = ProcessProxy(['echo', 'hello']).start()
         >>> p.stdout.read()
         'hello\r\n'
         >>> p.wait()   # .wait() returns the child's exit status
@@ -35,11 +35,11 @@
 
       Redirecting the stdout handler:
         >>> import sys
-        >>> p = Process(['echo', 'hello'], stdout=sys.stdout).start()
+        >>> p = ProcessProxy(['echo', 'hello'], stdout=sys.stdout).start()
         hello
 
       Using stdin:
-        >>> p = Process(['sort']).start()
+        >>> p = ProcessProxy(['sort']).start()
         >>> p.stdin.write('5\n')
         >>> p.stdin.write('2\n')
         >>> p.stdin.write('7\n')
@@ -48,20 +48,20 @@
         '2\n5\n7\n'
 
       Specifying environment variables:
-        >>> p = Process(['perl', '-e', 'print $ENV{FOO}']).start()
+        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}']).start()
         >>> p.stdout.read()
         ''
-        >>> p = Process(['perl', '-e', 'print $ENV{FOO}'],
+        >>> p = ProcessProxy(['perl', '-e', 'print $ENV{FOO}'],
         ...             env={'FOO':'bar'}).start()
         >>> p.stdout.read()
         'bar'
 
       Killing a long running process:
-        >>> p = Process(['perl', '-e', 'while (1) {}']).start()
+        >>> p = ProcessProxy(['perl', '-e', 'while (1) {}']).start()
         >>> try:
         ...     p.wait(0)  # poll to see if is process still running
-        ... except ProcessError, ex:
-        ...     if ex.errno == Process.WAIT_TIMEOUT:
+        ... except ProcessProxyError, ex:
+        ...     if ex.errno == ProcessProxy.WAIT_TIMEOUT:
         ...             print "process is still running"
         ...
         process is still running
@@ -86,10 +86,10 @@
 #   o ensure get return value properly
 #   - ensure don't pop up consoles
 #   - proper termination (still have issue with
-#     Process(stdout=sys.stdout) or what that for stdin?, but punting on
+#     ProcessProxy(stdout=sys.stdout) or what that for stdin?, but punting on
 #     that)
 #   - DavidA: if I specify "unbuffered" for my stdin handler (in the
-#     Process constructor) then the stdin IOBuffer should do a
+#     ProcessProxy constructor) then the stdin IOBuffer should do a
 #     fparent.read() rather than a fparent.readline(). TrentM: can I do
 #     that? What happens?
 #   - fit it into current invocation structure
@@ -99,15 +99,10 @@
 #   - make it work for linux too
 #
 #BUGS:
-#   - The following should not hang Python:
-#       p = Process(['dir'])
-#       output = p.stdout.read()
-#     Currently it hangs because the user forgot:
-#       p.start()
 #   - os.system('dir') and os.popen('dir') run Windows' shell 'dir'
-#     function. Process(['dir']).start() runs dir.exe on my PATH. What
+#     function. ProcessProxy(['dir']).start() runs dir.exe on my PATH. What
 #     is up?
-#     Look at Modules/posixmodule.c::_PyPopenCreateProcess() it launches
+#     Look at Modules/posixmodule.c::_PyPopenCreateProcessProxy() it launches
 #     stuff via $COMSPEC and/or w9xpopen.exe. Do that too.
 #
 
@@ -123,6 +118,8 @@
 import pywintypes
 import win32process
 import win32event
+import win32con
+import win32gui
 
 
 #---- exceptions
@@ -184,6 +181,12 @@
     log = Logger(Logger.DEBUG)
 
 
+#---- globals
+
+# List of registered processes (see _(un)registerProcess).
+_processes = []
+
+
 
 #---- internal support routines
 
@@ -211,21 +214,164 @@
     return cmdstr
 
 
+# Maintain references to all spawned processes to avoid hangs.
+# If the user lets the a ProcessProxy object go out of scope before the
+# process has terminated, it is possible to get a hang (at least on the
+# win32api.CloseHandle(<stdin handle>) in the __del__() method). A
+# reference is removed from this list when the process's .wait or .kill
+# method is called.
+def _registerProcess(process):
+    global _processes
+    _processes.append(process)
+
+def _unregisterProcess(process):
+    global _processes
+    try:
+        _processes.remove(process)
+    except ValueError:
+        pass
+
+
 #---- public routines
 
-##def run(cmd, mode='t', cwd=None, env=None, flags=None):
-##    """Run the given command in a child process.
-##
-##    "cmd"
-##    "mode"
-##    "cwd"
-##    "env"
-##    "flags" are platform-specific creation flags.
-##    Returns ... handles? retval?
-##    """
+class Process:
+    """Create a process.
+
+    One can optionally specify the starting working directory, the
+    process environment, and std handles to have the child process
+    inherit (all defaults are the parent's current settings). 'wait' and
+    'kill' method allow for control of the child's termination.
+    """
+    # .wait() argument constants
+    INFINITE = win32event.INFINITE
+    # .wait() return error codes
+    WAIT_FAILED = win32event.WAIT_FAILED
+    WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
+    # creation "flags" constants
+    CREATE_NEW_CONSOLE = win32process.CREATE_NEW_CONSOLE
+
+    def __init__(self, cmd, cwd=None, env=None, flags=0):
+        """Create a child process.
+
+        "cmd" is a command string or argument vector to spawn.
+        "cwd" is a working directory in which to start the child process.
+        "env" is an environment dictionary for the child.
+        "flags" are system-specific process creation flags.
+        """
+        log.info("Process.__init__(cmd=%r, cwd=%r, env=%r, flags=%r)"\
+                 % (cmd, cwd, env, flags))
+        if type(cmd) in (types.ListType, types.TupleType):
+            # And arg vector was passed in.
+            self._cmd = _joinArgv(cmd)
+        else:
+            self._cmd = cmd
+        if not self._cmd:
+            raise ProcessError("You must specify a command to spawn.")
+        self._cwd = cwd
+        self._env = env
+        self._flags = flags
+        self._start()
+
+    def _start(self):
+        si = win32process.STARTUPINFO() 
+        si.dwFlags = win32process.STARTF_USESHOWWINDOW
+        si.wShowWindow = win32con.SW_SHOWDEFAULT
+
+        #XXX May later want to allow hooking up of std handles but will
+        #    need some way to NOT do this because that is what Komodo
+        #    requires.
+        ## Get the std handles to pass to the child
+        #if self._stdin is None:
+        #    si.hStdInput = win32api.GetStdHandle(win32api.STD_INPUT_HANDLE)
+        #else:
+        #    si.hStdInput = msvcrt.get_osfhandle(stdin.fileno())
+        #if self._stdout is None:
+        #    si.hStdOutput = win32api.GetStdHandle(win32api.STD_OUTPUT_HANDLE)
+        #else:
+        #    si.hStdOutput = msvcrt.get_osfhandle(stdout.fileno())
+        #if self._stderr is None:
+        #    si.hStdError = win32api.GetStdHandle(win32api.STD_ERROR_HANDLE)
+        #else:
+        #    si.hStdError = msvcrt.get_osfhandle(stderr.fileno())
+        #si.dwFlags |= win32process.STARTF_USESTDHANDLES
+
+        # Start the child process.
+        self._hProcess, self._hThread, self._processId, self._threadId\
+            = win32process.CreateProcess(
+                None,           # app name
+                self._cmd,      # command line 
+                None,           # process security attributes 
+                None,           # primary thread security attributes 
+                0,              # handles are inherited 
+                self._flags,    # creation flags 
+                self._env,      # environment
+                self._cwd,      # current working directory
+                si)             # STARTUPINFO pointer 
+        win32api.CloseHandle(self._hThread)
+
+    def wait(self, timeout=None): 
+        """Wait for the started process to complete.
+        
+        A 'timeout' floating point number of seconds after which to
+        timeout.  If the wait time's out or there is some other error it
+        will raise a ProcessError. Otherwise it returns the child's exit
+        value.
+        
+        XXX Or should returning the exit value be move out to another
+            function as on Win32 process control? If so, then should
+            perhaps not make WaitForSingleObject semantic
+            transformation.
+        """
+        if timeout is None:
+            timeout = win32event.INFINITE
+        else:
+            timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+
+        rc = win32event.WaitForSingleObject(self._hProcess, timeout)
+        if rc == win32event.WAIT_FAILED:
+            raise ProcessError("'WAIT_FAILED' when waiting for process to "\
+                               "terminate: %r" % self._cmd, rc)
+        elif rc == win32event.WAIT_TIMEOUT:
+            raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
+                               "terminate: %r" % self._cmd, rc)
+
+        retval = win32process.GetExitCodeProcess(self._hProcess)
+        return retval
+
+    def kill(self, exitCode=0, gracePeriod=0.0):
+        """Kill process.
+        
+        "exitCode" is the code the terminated process should exit with.
+        "gracePeriod" is a number of seconds the process is allowed to
+            shutdown with a WM_CLOSE signal before a hard terminate is
+            called.
+
+        Windows:
+            Try for an orderly shutdown via WM_CLOSE.  If still running
+            after gracePeriod (5 sec. default), terminate.
+        """
+        gracePeriod = gracePeriod * 1000.0
+        win32gui.EnumWindows(self._close_, 0)
+        try:
+            self.wait(gracePeriod)
+        except ProcessError, ex:
+            win32process.TerminateProcess(self._hProcess, 0)
+            win32api.Sleep(100) # wait for resources to be released
+
+    def _close_(self, hwnd, dummy):
+        """Callback used by .kill()
+        EnumWindows callback - sends WM_CLOSE to any window
+        owned by this process.
+        """
+        threadId, processId = win32process.GetWindowThreadProcessId(hwnd)
+        if processId == self._processId:
+            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
+
 
-class Process:
-    #XXX Need docstring here
+class ProcessProxy(Process):
+    """Create a process and proxy communication via the standard handles.
+    """
+    #XXX To add to docstring:
     #   - stdout/stderr proxy handling
     #   - stdin proxy handling
     #   - termination
@@ -240,13 +386,9 @@
     #TODO:
     #   - .suspend() and .resume()? See Win32::Process Perl module.
     #
-    INFINITE = win32event.INFINITE
-    WAIT_FAILED = win32event.WAIT_FAILED
-    WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
-
     def __init__(self, cmd, mode='t', cwd=None, env=None,
                  stdin=None, stdout=None, stderr=None):
-        log.info("Process.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
+        log.info("ProcessProxy.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
                  "stdin=%r, stdout=%r, stderr=%r)"\
                  % (cmd, mode, cwd, env, stdin, stdout, stderr))
         if type(cmd) in (types.ListType, types.TupleType):
@@ -273,27 +415,30 @@
             self.stderr = IOBuffer('<stderr>')
         else:
             self.stderr = stderr
+        self._start()
+        _registerProcess(self)
 
     def __del__(self):
-        log.info("[%s] Process.__del__()" % id(self))
+        log.info("[%s] ProcessProxy.__del__()" % id(self))
+
         # Ensure that all IOBuffer's are closed. If they are not, these
         # can cause hangs. 
         if isinstance(self.stdin, IOBuffer):
             # Do not close user-specified streams. That is their
             # responsibility.
-            log.info("[%s] Process: closing stdin (%r)."\
+            log.info("[%s] ProcessProxy: closing stdin (%r)."\
                      % (id(self), self.stdin))
             self.stdin.close()
         if isinstance(self.stdout, IOBuffer):
             # Do not close user-specified streams. That is their
             # responsibility.
-            log.info("[%s] Process: closing stdout (%r)."\
+            log.info("[%s] ProcessProxy: closing stdout (%r)."\
                      % (id(self), self.stdout))
             self.stdout.close()
         if isinstance(self.stderr, IOBuffer):
             # Do not close user-specified streams. That is their
             # responsibility.
-            log.info("[%s] Process: closing stderr (%r)."\
+            log.info("[%s] ProcessProxy: closing stderr (%r)."\
                      % (id(self), self.stderr))
             self.stderr.close()
 
@@ -303,7 +448,7 @@
         # CloseHandle calls raise:
         #   pywintypes.api_error: (6, 'CloseHandle', 'The handle is invalid.')
         # *asynchronously*, i.e. in mainline code *following* where the
-        # Process() object goes out of scope. Explicitly handling the
+        # ProcessProxy() object goes out of scope. Explicitly handling the
         # closing (and catching) here avoids that. There may be a better
         # way to handle this given the XXX above.
         try:
@@ -319,7 +464,7 @@
         except win32api.error:
             pass
 
-    def start(self):
+    def _start(self):
         # Create pipes for std handles.
         # (Set the bInheritHandle flag so pipe handles are inherited.)
         saAttr = pywintypes.SECURITY_ATTRIBUTES()
@@ -338,7 +483,7 @@
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
-            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+            win32con.DUPLICATE_SAME_ACCESS)
         win32api.CloseHandle(hChildStdinWr)
         self._hChildStdinWr = hChildStdinWrDup
         hChildStdoutRdDup = win32api.DuplicateHandle(
@@ -347,7 +492,7 @@
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
-            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+            win32con.DUPLICATE_SAME_ACCESS)
         win32api.CloseHandle(hChildStdoutRd)
         self._hChildStdoutRd = hChildStdoutRdDup
         hChildStderrRdDup = win32api.DuplicateHandle(
@@ -356,7 +501,7 @@
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
-            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+            win32con.DUPLICATE_SAME_ACCESS)
         win32api.CloseHandle(hChildStderrRd)
         self._hChildStderrRd = hChildStderrRdDup
 
@@ -380,15 +525,15 @@
         #    c.f. PyFile_SetBufSize()
 
         # Start the child process.
-        startupInfo = win32process.STARTUPINFO() 
-        startupInfo.dwFlags = win32process.STARTF_USESHOWWINDOW
-        startupInfo.wShowWindow = 0 # SW_HIDE
-        startupInfo.hStdInput = hChildStdinRd
-        startupInfo.hStdOutput = hChildStdoutWr
-        startupInfo.hStdError = hChildStderrWr
-        startupInfo.dwFlags |= win32process.STARTF_USESTDHANDLES
+        si = win32process.STARTUPINFO() 
+        si.dwFlags = win32process.STARTF_USESHOWWINDOW
+        si.wShowWindow = 0 # SW_HIDE
+        si.hStdInput = hChildStdinRd
+        si.hStdOutput = hChildStdoutWr
+        si.hStdError = hChildStderrWr
+        si.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-        log.info("Process.start(): call CreateProcess(cmd=%r)" % self._cmd)
+        log.info("ProcessProxy.start(): call CreateProcess(cmd=%r)" % self._cmd)
         self._hProcess, hThread, dwProcessId, dwThreadId\
             = win32process.CreateProcess(
                 None,           # app name
@@ -399,8 +544,8 @@
                 0,              # creation flags 
                 self._env,      # environment
                 self._cwd,      # current working directory
-                startupInfo)    # STARTUPINFO pointer 
-        win32api.CloseHandle(hThread) #XXX copying koprocess.cpp here
+                si)             # STARTUPINFO pointer 
+        win32api.CloseHandle(hThread)
 
         # Close child ends of pipes on the parent's side.
         win32file.CloseHandle(hChildStdinRd)
@@ -417,10 +562,6 @@
                                    name='<stderr>')
         stderrProxy.start()
 
-        #log.debug("[%s] returning from .start()"\
-        #          % threading.currentThread().getName())
-        return self     # allow: p = Process(...).start()
-
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
         
@@ -432,7 +573,7 @@
         XXX Or should returning the exit value be move out to another
             function as on Win32 process control?
         """
-        log.info("[%s] Process.wait(timeout=%r)" % (id(self), timeout))
+        log.info("[%s] ProcessProxy.wait(timeout=%r)" % (id(self), timeout))
         if timeout is None:
             timeout = win32event.INFINITE
         else:
@@ -446,10 +587,14 @@
             raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
                                "terminate: %r" % self._cmd, rc)
 
-        return win32process.GetExitCodeProcess(self._hProcess)
+        retval = win32process.GetExitCodeProcess(self._hProcess)
+        _unregisterProcess(self)
+        return retval
 
     def kill(self, exitCode=0):
-        return win32process.TerminateProcess(self._hProcess, exitCode)
+        retval = win32process.TerminateProcess(self._hProcess, exitCode)
+        _unregisterProcess(self)
+        return retval
 
 
 
@@ -519,14 +664,15 @@
         if n < 0:
             # Wait until the buffer is closed, i.e. no more writes will
             # come.
-            while not self._closed:
-                self._stateChange.acquire()
+            self._stateChange.acquire()
+            while 1:
+                if self._closed: break
                 #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
                 #          % self._name)
                 self._stateChange.wait()
                 #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
                 #          % self._name)
-                self._stateChange.release()
+            self._stateChange.release()
         else:
             # Wait until there are the requested number of bytes to read
             # (or until the buffer is closed, i.e. no more writes will
@@ -636,9 +782,9 @@
             log.info("[%s] InFileProxy: waiting for read on parent (%r)"\
                      % (self.getName(), self.fparent))
             # XXX Get hangs here (!) even with
-            #     self.stdin.close() in Process' __del__() under this
+            #     self.stdin.close() in ProcessProxy' __del__() under this
             #     cond:
-            #           p = Process([...], stdin=sys.stdin)
+            #           p = ProcessProxy([...], stdin=sys.stdin)
             #     The user must manually send '\n' via <Enter> or EOF
             #     via <Ctrl-Z> to unlock this. How to get around that?
             #     See cleanOnTermination note in OutFileProxy.run()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/ReadMe.txt#2 (text) ====

@@ -5,3 +5,7 @@
     - Run the test suite:
         > python test.py
 
+TODO:
+    - add tests for process.Process(), currently only test
+      process.ProcessProxy()
+

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#3 (text) ====

@@ -15,8 +15,7 @@
     def test_cwd_notspecified(self):
         cwd = os.getcwd()
 
-        p = process.Process(['printcwd'])
-        p.start()
+        p = process.ProcessProxy(['printcwd'])
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -29,8 +28,7 @@
     def test_cwd_specified(self):
         wd = "D:\\trentm"
 
-        p = process.Process(['printcwd'], cwd=wd)
-        p.start()
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -42,15 +40,14 @@
 
     def test_cwd_specified_doesnotexist(self):
         wd = "foobar"
-        p = process.Process(['printcwd'], cwd=wd)
-        self.failUnlessRaises(win32api.error, p.start)
+        self.failUnlessRaises(win32api.error, process.ProcessProxy,
+                              cmd=['printcwd'], cwd=wd)
 
     def test_cwd_specified_relative(self):
         wd = "mytmprelativedir"
         testsupport.mkdir(wd)
 
-        p = process.Process(['printcwd'], cwd=wd)
-        p.start()
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")
@@ -66,8 +63,7 @@
         wd = "my tmp relative dir with spaces"
         testsupport.mkdir(wd)
 
-        p = process.Process(['printcwd'], cwd=wd)
-        p.start()
+        p = process.ProcessProxy(['printcwd'], cwd=wd)
         output = p.stdout.read()
 
         pattern = re.compile("CWD is '(.*?)'")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#3 (text) ====

@@ -14,8 +14,7 @@
     def test_env_unspecified(self):
         talkenv = ''
 
-        p = process.Process(['printenv'])
-        p.start()
+        p = process.ProcessProxy(['printenv'])
         output = p.stdout.read()
 
         pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -29,8 +28,7 @@
         talkenv = 'foo'
         os.environ['TALK_ENV'] = 'foo'
 
-        p = process.Process(['printenv'])
-        p.start()
+        p = process.ProcessProxy(['printenv'])
         output = p.stdout.read()
 
         pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -46,8 +44,7 @@
         talkenv = 'bar'
         env = {'TALK_ENV': talkenv}
 
-        p = process.Process(['printenv'], env=env)
-        p.start()
+        p = process.ProcessProxy(['printenv'], env=env)
         output = p.stdout.read()
 
         pattern = re.compile("TALK_ENV is '(.*?)'")
@@ -62,8 +59,7 @@
         talkenv = 'eggs'
         env = {'TALK_ENV': talkenv}
 
-        p = process.Process(['printenv'], env=env)
-        p.start()
+        p = process.ProcessProxy(['printenv'], env=env)
         output = p.stdout.read()
 
         pattern = re.compile("TALK_ENV is '(.*?)'")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#3 (text) ====

@@ -25,16 +25,14 @@
 
 class KillTestCase(unittest.TestCase):
     def test_kill(self):
-        p = process.Process(['hang'])
-        p.start()
+        p = process.ProcessProxy(['hang'])
         time.sleep(3)
         p.kill()
         retval = p.wait()
         self.failIf(retval)
 
     def test_kill_exitcode(self):
-        p = process.Process(['hang'])
-        p.start()
+        p = process.ProcessProxy(['hang'])
         time.sleep(3)
         p.kill(42)
         retval = p.wait()

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#2 (text) ====

@@ -11,20 +11,17 @@
 
 class RetvalTestCase(unittest.TestCase):
     def test_0(self):
-        p = process.Process(['quiet'])
-        p.start()
+        p = process.ProcessProxy(['quiet'])
         retval = p.wait()
         self.failUnless(retval == 0)
 
     def test_42(self):
-        p = process.Process(['quiet', '42'])
-        p.start()
+        p = process.ProcessProxy(['quiet', '42'])
         retval = p.wait()
         self.failUnless(retval == 42)
 
     def test_minus_42(self):
-        p = process.Process(['quiet', '-42'])
-        p.start()
+        p = process.ProcessProxy(['quiet', '-42'])
         retval = p.wait()
         self.failUnless(retval == -42)
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#4 (text) ====

@@ -25,8 +25,7 @@
 
 class StdinTestCase(unittest.TestCase):
     def test_stdin_buffer(self):
-        p = process.Process(['ask'])
-        p.start()
+        p = process.ProcessProxy(['ask'])
         p.stdin.write("Trent\n")
         p.stdin.close()
         output = p.stdout.read()
@@ -35,8 +34,7 @@
                         "Unexpected stdout output: %r" % output)
 
     def test_stdin_buffer_nonewline(self):
-        p = process.Process(['ask'])
-        p.start()
+        p = process.ProcessProxy(['ask'])
         p.stdin.write("Tre")
         # Note that we have not sent a newline, so the scanf() (or
         # fread() or whatever) in ask.exe is still waiting for input.
@@ -51,9 +49,8 @@
                         "Unexpected stdout output: %r" % output)
 
     def test_stdin_donotrespond(self):
-        p = process.Process(['ask_then_talk'],
+        p = process.ProcessProxy(['ask_then_talk'],
                             stdout=MyOutFile(), stderr=MyOutFile())
-        p.start()
         # Expect this to hang, as the child waits for input that we do
         # not send it.
         time.sleep(6)
@@ -67,8 +64,7 @@
     ## This is left commented out because the use of 'sys.stdin' requires
     ## user interaction -- not really an automated test suite then.
     #def test_stdin_sysstdin(self):
-    #    p = process.Process(['ask'], stdin=sys.stdin)
-    #    p.start()
+    #    p = process.ProcessProxy(['ask'], stdin=sys.stdin)
     #    output = p.stdout.read()
     #    expected = "What is your name?\nYour name is"
     #    self.failUnless(output.find(expected) != -1,
@@ -78,8 +74,7 @@
         # Expecting to get cygwin sort here. (XXX Should drop that dep.,
         # but am currently using it because it reacts measurably
         # differently to lines with '\r\n' vs '\n' terminators.)
-        p = process.Process(['sort'])
-        p.start()
+        p = process.ProcessProxy(['sort'])
         p.stdin.write("2\n")
         p.stdin.write("1\n")
         p.stdin.write("3\n")
@@ -93,8 +88,7 @@
 
     def test_stdin_binary_mode(self):
         # Expecting to get cygwin sort here. (XXX Should drop that dep.)
-        p = process.Process(['sort'], mode='b')
-        p.start()
+        p = process.ProcessProxy(['sort'], mode='b')
         p.stdin.write("2\n")
         p.stdin.write("1\n")
         p.stdin.write("3\n")
@@ -107,13 +101,12 @@
                         % (output, expected))
     
         # Note: reusing 'p' here is subtly testing another aspect of the
-        #       Process stuff. If self._hChildStdinWr (and the
-        #       stdout/stderr equivs) are not handled in Process.__del__
+        #       ProcessProxy stuff. If self._hChildStdinWr (and the
+        #       stdout/stderr equivs) are not handled in ProcessProxy.__del__
         #       then a win32api error on CloseHandle is raised when the
         #       C runtime closes these handles asynchronously.
 
-        p = process.Process(['sort'], mode='b')
-        p.start()
+        p = process.ProcessProxy(['sort'], mode='b')
         p.stdin.write("2\r\n")
         p.stdin.write("1\r\n")
         p.stdin.write("3\r\n")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#3 (text) ====

@@ -25,17 +25,15 @@
 
 class StdoutTestCase(unittest.TestCase):
     def test_stdout_buffer(self):
-        p = process.Process(['talk'])
-        p.start()
+        p = process.ProcessProxy(['talk'])
         output = p.stdout.read()
         self.failUnless(output == 'o0o1o2o3o4')
         error = p.stderr.read()
         self.failUnless(error == 'e0e1e2e3e4')
 
     def test_my_stdout(self):
-        p = process.Process(['talk'], stdout=MyOutFile(),
+        p = process.ProcessProxy(['talk'], stdout=MyOutFile(),
                             stderr=MyOutFile())
-        p.start()
         p.wait()
         self.failUnless(p.stdout.getOutput() == 'o0o1o2o3o4')
         self.failUnless(p.stderr.getOutput() == 'e0e1e2e3e4')
Change 41291 by trentm@trentm-razor on 2002/06/11 10:36:08

	   Catch to correct type of error (after having changed from using Win32 file
	   handles to posix file descriptors). Fix typo.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#8 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#8 (text) ====

@@ -213,6 +213,17 @@
 
 #---- public routines
 
+##def run(cmd, mode='t', cwd=None, env=None, flags=None):
+##    """Run the given command in a child process.
+##
+##    "cmd"
+##    "mode"
+##    "cwd"
+##    "env"
+##    "flags" are platform-specific creation flags.
+##    Returns ... handles? retval?
+##    """
+
 class Process:
     #XXX Need docstring here
     #   - stdout/stderr proxy handling
@@ -244,7 +255,7 @@
         else:
             self._cmd = cmd
         if not self._cmd:
-            raise ProcessError("You must specify an command to spawn.")
+            raise ProcessError("You must specify a command to spawn.")
         self._mode = mode
         if self._mode not in ('t', 'b'):
             raise ProcessError("'mode' must be 't' or 'b'.")
@@ -727,9 +738,9 @@
                 log.info("[%s] OutFileProxy: waiting for read on child (%r)"\
                          % (self.getName(), self.fchild))
                 text = self.fchild.read(BUFSIZE)
-            except pywintypes.error, ex:
-                # Ignore errors for now, like "The pipe is being closed.",
-                # etc. XXX There *may* be errors we don't want to avoid.
+            except IOError, ex:
+                # Ignore: IOError: [Errno 9] Bad file descriptor
+                # XXX Do we *know* we want to do that?
                 log.info("[%s] OutFileProxy: error reading from child (%r), "\
                          "closing: %s" % (self.getName(), self.fchild, ex))
                 break
Change 41108 by trentm@trentm-razor on 2002/06/06 16:59:41

	   - Allow Process('echo hi') in addition to the old (stull supported)
	     Process(['echo', 'hi']).
	   - Add some module documentation.
	   - Fix a logic bug IOBuffer.read() which could cause hangs.
	     Also restructure the state change loop a little bit to avoid a suspected
	     race condition.
	   - Hook process.py into the build system.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/Conscript#17 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#7 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_retval.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#2 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/Conscript#17 (text) ====

@@ -31,6 +31,7 @@
 $cons->InstallPythonUtility('autoinsert.py');
 $cons->InstallPythonUtility('koLogInstances.py');
 $cons->InstallPythonUtility('koXMLPrefs.py');
+$cons->InstallPythonUtility('process.py');
 
 %consLocal = $cons->copy();
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#7 (text) ====

@@ -2,15 +2,28 @@
 """
     Python interface for process control.
 
+    This module defines a Process class that can be used to spawn,
+    communicate with, and control a process.
+
     Usage:
         from process import Process
-        # You must specify at minimum an 'argv' to spawn. Optionally you
+        # You must specify at minimum a 'cmd' to spawn. Optionally you
         # can specify a cwd, environment dictionary, stdout/stdin/stderr
         # file-like objects to communicate with the spawned process.
-        p = Process(argv=[...], ...)
+        p = Process(cmd='...', ...)
         p.start()
         #... use the various methods and attributes
 
+    When your specifed process is spawned, Process creates three proxy
+    threads (classes InFileProxy and OutFileProxy), one for each
+    standard handle, which pump information between the calling Python
+    code and the spawned child process. You can optionally pass in
+    file-like objects to Process.__init__ to be responsible for handling
+    incoming writes on stdout and stderr and for outgoing write on
+    stdin. If you do not specify such handlers, Process adds an IOBuffer
+    object for each handle, on which you can read or write, as
+    appropriate.
+    
     Examples:
       A simple 'hello world':
         >>> from process import Process
@@ -73,7 +86,8 @@
 #   o ensure get return value properly
 #   - ensure don't pop up consoles
 #   - proper termination (still have issue with
-#     Process(stdout=sys.stdout), but punting on that)
+#     Process(stdout=sys.stdout) or what that for stdin?, but punting on
+#     that)
 #   - DavidA: if I specify "unbuffered" for my stdin handler (in the
 #     Process constructor) then the stdin IOBuffer should do a
 #     fparent.read() rather than a fparent.readline(). TrentM: can I do
@@ -210,6 +224,7 @@
     #     implement at least .write (is .write correct for stdin)?
     #   - if you pass in stdin, stdout, and/or stderr streams it is the
     #     user's responsibility to close them afterwards.
+    #   - 'cmd' arg can be a command string or an arg vector
     #   - etc.
     #TODO:
     #   - .suspend() and .resume()? See Win32::Process Perl module.
@@ -218,14 +233,18 @@
     WAIT_FAILED = win32event.WAIT_FAILED
     WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
 
-    def __init__(self, argv, mode='t', cwd=None, env=None,
+    def __init__(self, cmd, mode='t', cwd=None, env=None,
                  stdin=None, stdout=None, stderr=None):
-        log.info("Process.__init__(argv=%r, mode=%r, cwd=%r, env=%r, "\
+        log.info("Process.__init__(cmd=%r, mode=%r, cwd=%r, env=%r, "\
                  "stdin=%r, stdout=%r, stderr=%r)"\
-                 % (argv, mode, cwd, env, stdin, stdout, stderr))
-        self._argv = argv
-        if not self._argv:
-            raise ProcessError("You must specify an argv to spawn.")
+                 % (cmd, mode, cwd, env, stdin, stdout, stderr))
+        if type(cmd) in (types.ListType, types.TupleType):
+            # And arg vector was passed in.
+            self._cmd = _joinArgv(cmd)
+        else:
+            self._cmd = cmd
+        if not self._cmd:
+            raise ProcessError("You must specify an command to spawn.")
         self._mode = mode
         if self._mode not in ('t', 'b'):
             raise ProcessError("'mode' must be 't' or 'b'.")
@@ -350,8 +369,6 @@
         #    c.f. PyFile_SetBufSize()
 
         # Start the child process.
-        cmdLine = _joinArgv(self._argv)
-
         startupInfo = win32process.STARTUPINFO() 
         startupInfo.dwFlags = win32process.STARTF_USESHOWWINDOW
         startupInfo.wShowWindow = 0 # SW_HIDE
@@ -360,11 +377,11 @@
         startupInfo.hStdError = hChildStderrWr
         startupInfo.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-        log.info("Process.start(): call CreateProcess(cmdLine=%r)" % cmdLine)
+        log.info("Process.start(): call CreateProcess(cmd=%r)" % self._cmd)
         self._hProcess, hThread, dwProcessId, dwThreadId\
             = win32process.CreateProcess(
                 None,           # app name
-                cmdLine,        # command line 
+                self._cmd,      # command line 
                 None,           # process security attributes 
                 None,           # primary thread security attributes 
                 1,              # handles are inherited 
@@ -413,10 +430,10 @@
         rc = win32event.WaitForSingleObject(self._hProcess, timeout)
         if rc == win32event.WAIT_FAILED:
             raise ProcessError("'WAIT_FAILED' when waiting for process to "\
-                               "terminate: %r" % self._argv, rc)
+                               "terminate: %r" % self._cmd, rc)
         elif rc == win32event.WAIT_TIMEOUT:
             raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
-                               "terminate: %r" % self._argv, rc)
+                               "terminate: %r" % self._cmd, rc)
 
         return win32process.GetExitCodeProcess(self._hProcess)
 
@@ -503,14 +520,22 @@
             # Wait until there are the requested number of bytes to read
             # (or until the buffer is closed, i.e. no more writes will
             # come).
-            while not self._closed or len(self._buf) < n:
-                self._stateChange.acquire()
+            # XXX WARNING: I *think* there is a race condition around
+            #     here whereby self.fparent.read() in InFileProxy can
+            #     hang. *Sometime* test_stdin::test_stdin_buffer() will
+            #     hang. This was *before* I moved the
+            #     _stateChange.acquire() and .release() calls out side
+            #     of the 'while 1:' here.
+            self._stateChange.acquire()
+            while 1:
+                if self._closed: break
+                if len(self._buf) >= n: break
                 #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
                 #          % self._name)
                 self._stateChange.wait()
                 #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
                 #          % self._name)
-                self._stateChange.release()
+            self._stateChange.release()
         log.info("[%s] IOBuffer.read(): done waiting for data" % self._name)
 
         self._mutex.acquire()
@@ -607,14 +632,17 @@
             #     via <Ctrl-Z> to unlock this. How to get around that?
             #     See cleanOnTermination note in OutFileProxy.run()
             #     below.
-            #log.debug("XXX          -> start readline() on %r" % self.fparent)
+            #log.debug("XXX          -> start read on %r" % self.fparent)
             try:
-                text = self.fparent.readline(BUFSIZE)
+                # XXX Used to do .readline() here. Would that make
+                #     better sense in certain circumstances? Should
+                #     BUFSIZE be reduced now for smoother throughput?
+                text = self.fparent.read(BUFSIZE)
             except ValueError, ex:
                 # ValueError is raised with trying to write to a closed
                 # file/pipe.
                 text = None
-            #log.debug("XXX          <- done readline() on %r" % self.fparent)
+            #log.debug("XXX          <- done read on %r" % self.fparent)
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the parent's end.

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#2 (text) ====

@@ -15,7 +15,7 @@
     def test_cwd_notspecified(self):
         cwd = os.getcwd()
 
-        p = process.Process(argv=['printcwd'])
+        p = process.Process(['printcwd'])
         p.start()
         output = p.stdout.read()
 
@@ -29,7 +29,7 @@
     def test_cwd_specified(self):
         wd = "D:\\trentm"
 
-        p = process.Process(argv=['printcwd'], cwd=wd)
+        p = process.Process(['printcwd'], cwd=wd)
         p.start()
         output = p.stdout.read()
 
@@ -42,14 +42,14 @@
 
     def test_cwd_specified_doesnotexist(self):
         wd = "foobar"
-        p = process.Process(argv=['printcwd'], cwd=wd)
+        p = process.Process(['printcwd'], cwd=wd)
         self.failUnlessRaises(win32api.error, p.start)
 
     def test_cwd_specified_relative(self):
         wd = "mytmprelativedir"
         testsupport.mkdir(wd)
 
-        p = process.Process(argv=['printcwd'], cwd=wd)
+        p = process.Process(['printcwd'], cwd=wd)
         p.start()
         output = p.stdout.read()
 
@@ -66,7 +66,7 @@
         wd = "my tmp relative dir with spaces"
         testsupport.mkdir(wd)
 
-        p = process.Process(argv=['printcwd'], cwd=wd)
+        p = process.Process(['printcwd'], cwd=wd)
         p.start()
         output = p.stdout.read()
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#2 (text) ====

@@ -14,7 +14,7 @@
     def test_env_unspecified(self):
         talkenv = ''
 
-        p = process.Process(argv=['printenv'])
+        p = process.Process(['printenv'])
         p.start()
         output = p.stdout.read()
 
@@ -29,7 +29,7 @@
         talkenv = 'foo'
         os.environ['TALK_ENV'] = 'foo'
 
-        p = process.Process(argv=['printenv'])
+        p = process.Process(['printenv'])
         p.start()
         output = p.stdout.read()
 
@@ -46,7 +46,7 @@
         talkenv = 'bar'
         env = {'TALK_ENV': talkenv}
 
-        p = process.Process(argv=['printenv'], env=env)
+        p = process.Process(['printenv'], env=env)
         p.start()
         output = p.stdout.read()
 
@@ -62,7 +62,7 @@
         talkenv = 'eggs'
         env = {'TALK_ENV': talkenv}
 
-        p = process.Process(argv=['printenv'], env=env)
+        p = process.Process(['printenv'], env=env)
         p.start()
         output = p.stdout.read()
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#2 (text) ====

@@ -25,7 +25,7 @@
 
 class KillTestCase(unittest.TestCase):
     def test_kill(self):
-        p = process.Process(argv=['hang'])
+        p = process.Process(['hang'])
         p.start()
         time.sleep(3)
         p.kill()
@@ -33,7 +33,7 @@
         self.failIf(retval)
 
     def test_kill_exitcode(self):
-        p = process.Process(argv=['hang'])
+        p = process.Process(['hang'])
         p.start()
         time.sleep(3)
         p.kill(42)

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#3 (text) ====

@@ -25,7 +25,7 @@
 
 class StdinTestCase(unittest.TestCase):
     def test_stdin_buffer(self):
-        p = process.Process(argv=['ask'])
+        p = process.Process(['ask'])
         p.start()
         p.stdin.write("Trent\n")
         p.stdin.close()
@@ -35,7 +35,7 @@
                         "Unexpected stdout output: %r" % output)
 
     def test_stdin_buffer_nonewline(self):
-        p = process.Process(argv=['ask'])
+        p = process.Process(['ask'])
         p.start()
         p.stdin.write("Tre")
         # Note that we have not sent a newline, so the scanf() (or
@@ -51,7 +51,7 @@
                         "Unexpected stdout output: %r" % output)
 
     def test_stdin_donotrespond(self):
-        p = process.Process(argv=['ask_then_talk'],
+        p = process.Process(['ask_then_talk'],
                             stdout=MyOutFile(), stderr=MyOutFile())
         p.start()
         # Expect this to hang, as the child waits for input that we do
@@ -67,7 +67,7 @@
     ## This is left commented out because the use of 'sys.stdin' requires
     ## user interaction -- not really an automated test suite then.
     #def test_stdin_sysstdin(self):
-    #    p = process.Process(argv=['ask'], stdin=sys.stdin)
+    #    p = process.Process(['ask'], stdin=sys.stdin)
     #    p.start()
     #    output = p.stdout.read()
     #    expected = "What is your name?\nYour name is"
@@ -78,7 +78,7 @@
         # Expecting to get cygwin sort here. (XXX Should drop that dep.,
         # but am currently using it because it reacts measurably
         # differently to lines with '\r\n' vs '\n' terminators.)
-        p = process.Process(argv=['sort'])
+        p = process.Process(['sort'])
         p.start()
         p.stdin.write("2\n")
         p.stdin.write("1\n")
@@ -93,7 +93,7 @@
 
     def test_stdin_binary_mode(self):
         # Expecting to get cygwin sort here. (XXX Should drop that dep.)
-        p = process.Process(argv=['sort'], mode='b')
+        p = process.Process(['sort'], mode='b')
         p.start()
         p.stdin.write("2\n")
         p.stdin.write("1\n")
@@ -112,7 +112,7 @@
         #       then a win32api error on CloseHandle is raised when the
         #       C runtime closes these handles asynchronously.
 
-        p = process.Process(argv=['sort'], mode='b')
+        p = process.Process(['sort'], mode='b')
         p.start()
         p.stdin.write("2\r\n")
         p.stdin.write("1\r\n")

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#2 (text) ====

@@ -25,7 +25,7 @@
 
 class StdoutTestCase(unittest.TestCase):
     def test_stdout_buffer(self):
-        p = process.Process(argv=['talk'])
+        p = process.Process(['talk'])
         p.start()
         output = p.stdout.read()
         self.failUnless(output == 'o0o1o2o3o4')
@@ -33,7 +33,7 @@
         self.failUnless(error == 'e0e1e2e3e4')
 
     def test_my_stdout(self):
-        p = process.Process(argv=['talk'], stdout=MyOutFile(),
+        p = process.Process(['talk'], stdout=MyOutFile(),
                             stderr=MyOutFile())
         p.start()
         p.wait()
Change 40922 by trentm@trentm-razor on 2002/06/04 15:03:06

	   Add mode='t'|'b' option to Process creation to set the mode of text
	   translation for communication bwtn parent and child processes. 't' is the
	   default (as it is for Python's popen*() functions).
	
	   Also add some usage examples in the module documentation.
	
	   Fix a stupid bug in the ProcessError constructor.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#6 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#2 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#6 (text) ====

@@ -11,8 +11,50 @@
         p.start()
         #... use the various methods and attributes
 
-    Example:
-        
+    Examples:
+      A simple 'hello world':
+        >>> from process import Process
+        >>> p = Process(['echo', 'hello']).start()
+        >>> p.stdout.read()
+        'hello\r\n'
+        >>> p.wait()   # .wait() returns the child's exit status
+        0
+
+      Redirecting the stdout handler:
+        >>> import sys
+        >>> p = Process(['echo', 'hello'], stdout=sys.stdout).start()
+        hello
+
+      Using stdin:
+        >>> p = Process(['sort']).start()
+        >>> p.stdin.write('5\n')
+        >>> p.stdin.write('2\n')
+        >>> p.stdin.write('7\n')
+        >>> p.stdin.close()
+        >>> p.stdout.read()
+        '2\n5\n7\n'
+
+      Specifying environment variables:
+        >>> p = Process(['perl', '-e', 'print $ENV{FOO}']).start()
+        >>> p.stdout.read()
+        ''
+        >>> p = Process(['perl', '-e', 'print $ENV{FOO}'],
+        ...             env={'FOO':'bar'}).start()
+        >>> p.stdout.read()
+        'bar'
+
+      Killing a long running process:
+        >>> p = Process(['perl', '-e', 'while (1) {}']).start()
+        >>> try:
+        ...     p.wait(0)  # poll to see if is process still running
+        ... except ProcessError, ex:
+        ...     if ex.errno == Process.WAIT_TIMEOUT:
+        ...             print "process is still running"
+        ...
+        process is still running
+        >>> p.kill(42)
+        >>> p.wait()
+        42
 """
 #TODO:
 #   o the above (stdout good, stderr good, stdin good)
@@ -51,6 +93,8 @@
 #   - os.system('dir') and os.popen('dir') run Windows' shell 'dir'
 #     function. Process(['dir']).start() runs dir.exe on my PATH. What
 #     is up?
+#     Look at Modules/posixmodule.c::_PyPopenCreateProcess() it launches
+#     stuff via $COMSPEC and/or w9xpopen.exe. Do that too.
 #
 
 import os
@@ -58,6 +102,7 @@
 import threading
 import types
 import pprint 
+import msvcrt
 import win32api
 import win32file
 import win32pipe
@@ -70,11 +115,10 @@
 
 class ProcessError(Exception):
     def __init__(self, msg, errno=None):
-        Exception.__init__(msg)
+        Exception.__init__(self, msg)
         self.errno = errno
 
 
-
 #---- internal logging facility
 
 class Logger:
@@ -174,14 +218,17 @@
     WAIT_FAILED = win32event.WAIT_FAILED
     WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
 
-    def __init__(self, argv, cwd=None, env=None,
+    def __init__(self, argv, mode='t', cwd=None, env=None,
                  stdin=None, stdout=None, stderr=None):
-        log.info("Process.__init__(argv=%r, cwd=%r, env=%r, stdin=%r, "\
-                 "stdout=%r, stderr=%r)"\
-                 % (argv, cwd, env, stdin, stdout, stderr))
+        log.info("Process.__init__(argv=%r, mode=%r, cwd=%r, env=%r, "\
+                 "stdin=%r, stdout=%r, stderr=%r)"\
+                 % (argv, mode, cwd, env, stdin, stdout, stderr))
         self._argv = argv
         if not self._argv:
-            raise ProcessError("You must specify an argv to drive.")
+            raise ProcessError("You must specify an argv to spawn.")
+        self._mode = mode
+        if self._mode not in ('t', 'b'):
+            raise ProcessError("'mode' must be 't' or 'b'.")
         self._cwd = cwd
         self._env = env
         if stdin is None:
@@ -220,6 +267,28 @@
                      % (id(self), self.stderr))
             self.stderr.close()
 
+        # Explicitly close saved pipe handles. These *would* normally be
+        # closed explicitly by the C runtime when their refcounts drop
+        # to zero. However (XXX for a reason I don't understand) these
+        # CloseHandle calls raise:
+        #   pywintypes.api_error: (6, 'CloseHandle', 'The handle is invalid.')
+        # *asynchronously*, i.e. in mainline code *following* where the
+        # Process() object goes out of scope. Explicitly handling the
+        # closing (and catching) here avoids that. There may be a better
+        # way to handle this given the XXX above.
+        try:
+            win32api.CloseHandle(self._hChildStdinWr)
+        except win32api.error:
+            pass
+        try:
+            win32api.CloseHandle(self._hChildStdoutRd)
+        except win32api.error:
+            pass
+        try:
+            win32api.CloseHandle(self._hChildStderrRd)
+        except win32api.error:
+            pass
+
     def start(self):
         # Create pipes for std handles.
         # (Set the bInheritHandle flag so pipe handles are inherited.)
@@ -227,56 +296,68 @@
         saAttr.bInheritHandle = 1
         #XXX Should try with os.pipe. Dunno what that does for
         #    inheritability though.
-        childStdinRd, childStdinWr = win32pipe.CreatePipe(saAttr, 0) 
-        childStdoutRd, childStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
-        childStderrRd, childStderrWr = win32pipe.CreatePipe(saAttr, 0) 
+        hChildStdinRd, hChildStdinWr = win32pipe.CreatePipe(saAttr, 0) 
+        hChildStdoutRd, hChildStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
+        hChildStderrRd, hChildStderrWr = win32pipe.CreatePipe(saAttr, 0) 
 
         # Duplicate the parent ends of the pipes so they are not
         # inherited. 
-        childStdinWrDup = win32api.DuplicateHandle(
+        hChildStdinWrDup = win32api.DuplicateHandle(
             win32api.GetCurrentProcess(),
-            childStdinWr,
+            hChildStdinWr,
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
             2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
-        win32api.CloseHandle(childStdinWr)
-        childStdinWr = childStdinWrDup
-        childStdoutRdDup = win32api.DuplicateHandle(
+        win32api.CloseHandle(hChildStdinWr)
+        self._hChildStdinWr = hChildStdinWrDup
+        hChildStdoutRdDup = win32api.DuplicateHandle(
             win32api.GetCurrentProcess(),
-            childStdoutRd,
+            hChildStdoutRd,
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
             2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
-        win32api.CloseHandle(childStdoutRd)
-        childStdoutRd = childStdoutRdDup
-        childStderrRdDup = win32api.DuplicateHandle(
+        win32api.CloseHandle(hChildStdoutRd)
+        self._hChildStdoutRd = hChildStdoutRdDup
+        hChildStderrRdDup = win32api.DuplicateHandle(
             win32api.GetCurrentProcess(),
-            childStderrRd,
+            hChildStderrRd,
             win32api.GetCurrentProcess(),
             0,
             0, # not inherited
             2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
-        win32api.CloseHandle(childStderrRd)
-        childStderrRd = childStderrRdDup
+        win32api.CloseHandle(hChildStderrRd)
+        self._hChildStderrRd = hChildStderrRdDup
+
+        # Set the translation mode.
+        if self._mode == 't':
+            flags = os.O_TEXT
+            mode = ''
+        else:
+            flags = 0
+            mode = 'b'
+        fdChildStdinWr = msvcrt.open_osfhandle(self._hChildStdinWr, flags)
+        fChildStdinWr = os.fdopen(fdChildStdinWr, 'w'+mode)
+        fdChildStdoutRd = msvcrt.open_osfhandle(self._hChildStdoutRd, flags)
+        fChildStdoutRd = os.fdopen(fdChildStdoutRd, 'r'+mode)
+        fdChildStderrRd = msvcrt.open_osfhandle(self._hChildStderrRd, flags)
+        fChildStderrRd = os.fdopen(fdChildStderrRd, 'r'+mode)
 
         #XXX Look into setvbuf() to optionally make the pipe streams
         #    unbuffered. Note that I don't know of a Python-level iface to
         #    this so would have to write a small extension for this.
         #    c.f. PyFile_SetBufSize()
 
-        #XXX cwd and env setup.
-
         # Start the child process.
         cmdLine = _joinArgv(self._argv)
 
         startupInfo = win32process.STARTUPINFO() 
         startupInfo.dwFlags = win32process.STARTF_USESHOWWINDOW
         startupInfo.wShowWindow = 0 # SW_HIDE
-        startupInfo.hStdInput = childStdinRd
-        startupInfo.hStdOutput = childStdoutWr
-        startupInfo.hStdError = childStderrWr
+        startupInfo.hStdInput = hChildStdinRd
+        startupInfo.hStdOutput = hChildStdoutWr
+        startupInfo.hStdError = hChildStderrWr
         startupInfo.dwFlags |= win32process.STARTF_USESTDHANDLES
 
         log.info("Process.start(): call CreateProcess(cmdLine=%r)" % cmdLine)
@@ -293,20 +374,24 @@
                 startupInfo)    # STARTUPINFO pointer 
         win32api.CloseHandle(hThread) #XXX copying koprocess.cpp here
 
+        # Close child ends of pipes on the parent's side.
+        win32file.CloseHandle(hChildStdinRd)
+        win32file.CloseHandle(hChildStdoutWr)
+        win32file.CloseHandle(hChildStderrWr)
+
         # Create proxy threads for the out pipes.
-        win32file.CloseHandle(childStdinRd)
-        stdinProxy = InFileProxy(self.stdin, childStdinWr, name='<stdin>')
+        stdinProxy = InFileProxy(self.stdin, fChildStdinWr, name='<stdin>')
         stdinProxy.start()
-        win32file.CloseHandle(childStdoutWr)
-        stdoutProxy = OutFileProxy(childStdoutRd, self.stdout,
+        stdoutProxy = OutFileProxy(fChildStdoutRd, self.stdout,
                                    self.stdin, name='<stdout>')
         stdoutProxy.start()
-        win32file.CloseHandle(childStderrWr)
-        stderrProxy = OutFileProxy(childStderrRd, self.stderr,
+        stderrProxy = OutFileProxy(fChildStderrRd, self.stderr,
                                    name='<stderr>')
         stderrProxy.start()
 
-        #XXX Cleanup?
+        #log.debug("[%s] returning from .start()"\
+        #          % threading.currentThread().getName())
+        return self     # allow: p = Process(...).start()
 
     def wait(self, timeout=None): 
         """Wait for the started process to complete.
@@ -408,9 +493,11 @@
             # come.
             while not self._closed:
                 self._stateChange.acquire()
-                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()" % self._name)
+                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
+                #          % self._name)
                 self._stateChange.wait()
-                #log.debug("[%s]     >>> IOBuffer.read: done state change .wait()" % self._name)
+                #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
+                #          % self._name)
                 self._stateChange.release()
         else:
             # Wait until there are the requested number of bytes to read
@@ -418,9 +505,11 @@
             # come).
             while not self._closed or len(self._buf) < n:
                 self._stateChange.acquire()
-                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()" % self._name)
+                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()"\
+                #          % self._name)
                 self._stateChange.wait()
-                #log.debug("[%s]     >>> IOBuffer.read: done state change .wait()" % self._name)
+                #log.debug("[%s]     >>> IOBuffer.read: done change .wait()"\
+                #          % self._name)
                 self._stateChange.release()
         log.info("[%s] IOBuffer.read(): done waiting for data" % self._name)
 
@@ -532,33 +621,32 @@
                 log.info("[%s] InFileProxy: observed close of parent (%r)"\
                          % (self.getName(), self.fparent))
                 # Signal the child so it knows to stop listening.
-                win32file.CloseHandle(self.fchild)
+                try:
+                    self.fchild.close()
+                except IOError, ex:
+                    # Ignore: IOError: [Errno 9] Bad file descriptor
+                    # XXX Do we *know* we want to do that?
+                    pass
                 break
             else:
                 log.info("[%s] InFileProxy: read %d bytes from parent: %r"\
                          % (self.getName(), len(text), text))
 
             try:
-                log.debug("writing %r to child" % text)
-                errCode, nBytesWritten = win32file.WriteFile(self.fchild,
-                                                             text)
+                #log.debug("writing %r to child" % text)
+                self.fchild.write(text)
             except pywintypes.error, ex:
                 # Ignore errors for now, like "The pipe is being closed.",
                 # etc. XXX There *may* be errors we don't want to avoid.
+                # XXX Presuming that not being able to write any bytes
+                #     is indicated by raising an exception, whereas
+                #     win32file.WriteFile (previously used) would raise
+                #     *or* return nBytesWritten==0.
                 log.info("[%s] InFileProxy: error writing to child (%r), "\
                          "closing: %s" % (self.getName(), self.fparent, ex))
                 break
-            assert errCode == 0,\
-                   "Why is 'errCode' from WriteFile non-zero? %r" % errCode
-            if not nBytesWritten:
-                # No bytes written signifies that the pipe has been
-                # closed on the child's end.
-                log.info("[%s] InFileProxy: observed close of child (%r)"\
-                         % (self.getName(), self.fchild))
-                break
-            else:
-                log.info("[%s] InFileProxy: wrote %d bytes to child: %r"\
-                         % (self.getName(), len(text), text))
+            log.info("[%s] InFileProxy: wrote %d bytes to child: %r"\
+                     % (self.getName(), len(text), text))
 
 class OutFileProxy(threading.Thread):
     """A thread to watch an "out" file from the spawned child process
@@ -610,14 +698,13 @@
             try:
                 log.info("[%s] OutFileProxy: waiting for read on child (%r)"\
                          % (self.getName(), self.fchild))
-                hr, text = win32file.ReadFile(self.fchild, BUFSIZE)
+                text = self.fchild.read(BUFSIZE)
             except pywintypes.error, ex:
                 # Ignore errors for now, like "The pipe is being closed.",
                 # etc. XXX There *may* be errors we don't want to avoid.
                 log.info("[%s] OutFileProxy: error reading from child (%r), "\
                          "closing: %s" % (self.getName(), self.fchild, ex))
                 break
-            assert hr == 0, "Why is 'hr' from ReadFile non-zero? %r" % hr
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the child's end.

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#2 (text) ====

@@ -23,11 +23,6 @@
                 output += data
         return output
 
-if sys.platform.startswith("win"):
-    newl = '\r\n'
-else:
-    newl = '\n'
-
 class StdinTestCase(unittest.TestCase):
     def test_stdin_buffer(self):
         p = process.Process(argv=['ask'])
@@ -35,8 +30,7 @@
         p.stdin.write("Trent\n")
         p.stdin.close()
         output = p.stdout.read()
-        expected = "What is your name?%sYour name is 'Trent'.%s"\
-                   % (newl, newl)
+        expected = "What is your name?\nYour name is 'Trent'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
@@ -52,7 +46,7 @@
         # inheritability having been properly set.)
         p.stdin.close()
         output = p.stdout.read()
-        expected = "What is your name?%sYour name is 'Tre'.%s" % (newl, newl)
+        expected = "What is your name?\nYour name is 'Tre'.\n"
         self.failUnless(output == expected,
                         "Unexpected stdout output: %r" % output)
 
@@ -76,10 +70,62 @@
     #    p = process.Process(argv=['ask'], stdin=sys.stdin)
     #    p.start()
     #    output = p.stdout.read()
-    #    expected = "What is your name?%sYour name is" % newl
+    #    expected = "What is your name?\nYour name is"
     #    self.failUnless(output.find(expected) != -1,
     #                    "Unexpected stdout output: %r" % output)
 
+    def test_stdin_text_mode(self):
+        # Expecting to get cygwin sort here. (XXX Should drop that dep.,
+        # but am currently using it because it reacts measurably
+        # differently to lines with '\r\n' vs '\n' terminators.)
+        p = process.Process(argv=['sort'])
+        p.start()
+        p.stdin.write("2\n")
+        p.stdin.write("1\n")
+        p.stdin.write("3\n")
+        p.stdin.close()
+        output = p.stdout.read()
+        expected = "1\n2\n3\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r (expected: %r). "\
+                        "Pipes are not doing text translation."\
+                        % (output, expected))
+
+    def test_stdin_binary_mode(self):
+        # Expecting to get cygwin sort here. (XXX Should drop that dep.)
+        p = process.Process(argv=['sort'], mode='b')
+        p.start()
+        p.stdin.write("2\n")
+        p.stdin.write("1\n")
+        p.stdin.write("3\n")
+        p.stdin.close()
+        output = p.stdout.read()
+        expected = "???\r\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r (expected: %r). "\
+                        "Pipes are not doing text translation."\
+                        % (output, expected))
+    
+        # Note: reusing 'p' here is subtly testing another aspect of the
+        #       Process stuff. If self._hChildStdinWr (and the
+        #       stdout/stderr equivs) are not handled in Process.__del__
+        #       then a win32api error on CloseHandle is raised when the
+        #       C runtime closes these handles asynchronously.
+
+        p = process.Process(argv=['sort'], mode='b')
+        p.start()
+        p.stdin.write("2\r\n")
+        p.stdin.write("1\r\n")
+        p.stdin.write("3\r\n")
+        p.stdin.close()
+        output = p.stdout.read()
+        expected = "1\r\n2\r\n3\r\n"
+        self.failUnless(output == expected,
+                        "Unexpected stdout output: %r (expected: %r). "\
+                        "Pipes are not doing text translation."\
+                        % (output, expected))
+
+
 def suite():
     """Return a unittest.TestSuite to be used by test.py."""
     return unittest.makeSuite(StdinTestCase)
Change 40843 by trentm@trentm-razor on 2002/06/03 15:56:10

	Fix a bug whereby the following in the Python interactive shell would hang:
	      >>> from process import Process
	      >>> p = Process(['dir'])
	      >>> p.start()
	      >>> ^Z
	   Adding 'del p' before the <Ctrl-Z> makes it not hang.
	
	   The problem was the the <stdin> IOBuffer was not closing with the
	   .write('') termination signal that was being sent to it from the <stdout>
	   IOBuffer when *it* terminated and thus the stdin Proxy's stdin.read() was
	   hung.
	
	   Also note a couple of bugs and start some module documentation.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#5 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#5 (text) ====

@@ -1,6 +1,19 @@
 
-# Python interface for OO process control.
-#
+"""
+    Python interface for process control.
+
+    Usage:
+        from process import Process
+        # You must specify at minimum an 'argv' to spawn. Optionally you
+        # can specify a cwd, environment dictionary, stdout/stdin/stderr
+        # file-like objects to communicate with the spawned process.
+        p = Process(argv=[...], ...)
+        p.start()
+        #... use the various methods and attributes
+
+    Example:
+        
+"""
 #TODO:
 #   o the above (stdout good, stderr good, stdin good)
 #   o define a nice API
@@ -28,6 +41,17 @@
 #   o ensure can pass things like cwd and the environment to use
 #   - handling failure to launch, what are the semantics
 #   - make it work for linux too
+#
+#BUGS:
+#   - The following should not hang Python:
+#       p = Process(['dir'])
+#       output = p.stdout.read()
+#     Currently it hangs because the user forgot:
+#       p.start()
+#   - os.system('dir') and os.popen('dir') run Windows' shell 'dir'
+#     function. Process(['dir']).start() runs dir.exe on my PATH. What
+#     is up?
+#
 
 import os
 import sys
@@ -360,6 +384,11 @@
         # Silently drop writes after the buffer has been close()'d.
         if self._closed:
             return
+        # If empty write, close buffer (mimicking behaviour from
+        # koprocess.cpp.)
+        if not s:
+            self.close()
+            return
 
         self._mutex.acquire()
         self._buf += s                  # Append to buffer.
Change 40839 by trentm@trentm-razor on 2002/06/03 15:21:55

	Can now specify the cwd and environment changes for spawned processes.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#4 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#2 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_cwd.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_env.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/testsupport.py#1 add

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#4 (text) ====

@@ -1,7 +1,5 @@
 
-# Drive the given application.
-# where "drive" means to hook up to its stdin/stdout/stderr properly and
-# present results *as* we go.
+# Python interface for OO process control.
 #
 #TODO:
 #   o the above (stdout good, stderr good, stdin good)
@@ -27,7 +25,7 @@
 #     that? What happens?
 #   - fit it into current invocation structure
 #   - passing in handlers, or callbacks?
-#   - ensure can pass things like cwd and the environment to use
+#   o ensure can pass things like cwd and the environment to use
 #   - handling failure to launch, what are the semantics
 #   - make it work for linux too
 
@@ -146,7 +144,6 @@
     #     user's responsibility to close them afterwards.
     #   - etc.
     #TODO:
-    #   - should protect some attributes, e.g. env, cwd, argv
     #   - .suspend() and .resume()? See Win32::Process Perl module.
     #
     INFINITE = win32event.INFINITE
@@ -158,11 +155,11 @@
         log.info("Process.__init__(argv=%r, cwd=%r, env=%r, stdin=%r, "\
                  "stdout=%r, stderr=%r)"\
                  % (argv, cwd, env, stdin, stdout, stderr))
-        self.argv = argv
-        if not self.argv:
+        self._argv = argv
+        if not self._argv:
             raise ProcessError("You must specify an argv to drive.")
-        self.cwd = cwd
-        self.env = env
+        self._cwd = cwd
+        self._env = env
         if stdin is None:
             self.stdin = IOBuffer('<stdin>')
         else:
@@ -175,8 +172,6 @@
             self.stderr = IOBuffer('<stderr>')
         else:
             self.stderr = stderr
-        if self.cwd or self.env:
-            raise NotImplementedError("Cannot handle some of these args yet.")
 
     def __del__(self):
         log.info("[%s] Process.__del__()" % id(self))
@@ -250,7 +245,7 @@
         #XXX cwd and env setup.
 
         # Start the child process.
-        cmdLine = _joinArgv(self.argv)
+        cmdLine = _joinArgv(self._argv)
 
         startupInfo = win32process.STARTUPINFO() 
         startupInfo.dwFlags = win32process.STARTF_USESHOWWINDOW
@@ -269,8 +264,8 @@
                 None,           # primary thread security attributes 
                 1,              # handles are inherited 
                 0,              # creation flags 
-                None,           # use parent's environment 
-                None,           # use parent's current directory 
+                self._env,      # environment
+                self._cwd,      # current working directory
                 startupInfo)    # STARTUPINFO pointer 
         win32api.CloseHandle(hThread) #XXX copying koprocess.cpp here
 
@@ -306,15 +301,13 @@
         else:
             timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
 
-        log.debug("[%s] Process.wait(): call WaitForSingleObject(timeout=%r)" % (id(self), timeout))
         rc = win32event.WaitForSingleObject(self._hProcess, timeout)
-        log.debug("[%s] Process.wait(): rc from WaitForSingleObject is %r" % (id(self), rc))
         if rc == win32event.WAIT_FAILED:
             raise ProcessError("'WAIT_FAILED' when waiting for process to "\
-                               "terminate: %r" % self.argv, rc)
+                               "terminate: %r" % self._argv, rc)
         elif rc == win32event.WAIT_TIMEOUT:
             raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
-                               "terminate: %r" % self.argv, rc)
+                               "terminate: %r" % self._argv, rc)
 
         return win32process.GetExitCodeProcess(self._hProcess)
 

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#2 (text) ====

@@ -9,7 +9,7 @@
 LDFLAGS=kernel32.lib user32.lib gdi32.lib advapi32.lib shlwapi.lib
 RM=del
 
-talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe
+talkers: ask.exe askw.exe ask_then_talk.exe ask_then_talklots.exe ask_then_talk_flushing.exe ask_then_talklots_flushing.exe talk.exe talklots.exe talk_flushing.exe talklots_flushing.exe ask_then_talkw.exe ask_then_talklotsw.exe ask_then_talk_flushingw.exe ask_then_talklots_flushingw.exe talkw.exe talklotsw.exe talk_flushingw.exe talklots_flushingw.exe quiet.exe quietw.exe hang.exe hangw.exe printcwd.exe printcwdw.exe printenv.exe printenvw.exe
 
 
 ask.exe askw.exe: talk.cpp
@@ -78,6 +78,18 @@
     $(CL) $(CFLAGS)    /D_WINDOWS          /DHANG  /Fohangw.obj /c talk.cpp
     $(LINK) $(LDFLAGS) /subsystem:windows  /out:hangw.exe hangw.obj
 
+printcwd.exe printcwdw.exe: talk.cpp
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DCWD  /Foprintcwd.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:printcwd.exe printcwd.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DCWD  /Foprintcwdw.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:printcwdw.exe printcwdw.obj
+
+printenv.exe printenvw.exe: talk.cpp
+    $(CL) $(CFLAGS)    /D_CONSOLE /D_MBCS  /DENV  /Foprintenv.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:console  /out:printenv.exe printenv.obj
+    $(CL) $(CFLAGS)    /D_WINDOWS          /DENV  /Foprintenvw.obj /c talk.cpp
+    $(LINK) $(LDFLAGS) /subsystem:windows  /out:printenvw.exe printenvw.obj
+
 
 
 clean:

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#2 (text) ====

@@ -1,5 +1,15 @@
 #include <stdio.h>
-#include <windows.h>
+
+#ifdef WIN32
+#	include <windows.h>
+#	include <direct.h>
+#endif
+
+
+#ifdef WIN32
+    #define getcwd _getcwd
+#endif
+
 
 void logInfo(const char* format ...)
 {
@@ -57,6 +67,19 @@
     }
 #endif
 
+#ifdef CWD
+    char cwd[1024];
+    getcwd(cwd, 1024);
+    fprintf(stdout, "CWD is '%s'\n", cwd);
+#endif
+
+#ifdef ENV
+    // Print the value of the TALK_ENV environment variable.
+    char talkenv[1024];
+    GetEnvironmentVariable("TALK_ENV", talkenv, 1024);
+    fprintf(stdout, "TALK_ENV is '%s'\n", talkenv);
+#endif
+
 #ifdef HANG
     while (1) {
 	Sleep(100);
Change 40831 by trentm@trentm-razor on 2002/06/03 14:32:49

	   - add internal logging for the process module
	   - move internal test code out to a unittest-based test suite
	   - can now hook up stdin
	   - assign an IOBuffer to stdin, stdout, and/or stderr if the user does not
	     specify these optional parameters, the user can then write to p.stdin and
	     read from p.stdout & p.stderr using normal Python file-like object
	     semantics
	   - make parent ends of shared pipes with the child process non-inheritable
	     (otherwise fread/fscanf/etc. calls in the child do not terminate properly
	     when the pipes are closed)
	   - add .wait() method to wait for the process to terminate and return to
	     exit code
	   - add .kill() method

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#3 edit
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/Makefile#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/ReadMe.txt#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/_test_template.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/talk.cpp#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_kill.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdin.py#1 add
... //depot/main/Apps/Komodo-devel/src/python-sitelib/test/test_stdout.py#1 add

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#3 (text) ====

@@ -5,32 +5,103 @@
 #
 #TODO:
 #   o the above (stdout good, stderr good, stdin good)
-#   - define a nice API
-#   - ensure get return value properly
+#   o define a nice API
+#       o still need to add .wait() and .kill() and perhaps more tests
+#   - Discuss the decision to NOT have the stdout OutFileProxy wait for
+#     process termination before closing stdin. It will just close stdin
+#     when stdout is seen to have been closed. That is considered Good
+#     Enough (tm). Theoretically it would be nice to only abort the
+#     stdin proxying when the process terminates, but watching for
+#     process termination in any of the parent's thread adds the
+#     undesired condition that the parent cannot exit with the child
+#     still running. That sucks.
+#     XXX Note that I don't even know if the current stdout proxy even
+#         closes the stdin proxy at all.
+#   o ensure get return value properly
 #   - ensure don't pop up consoles
-#   - proper termination
+#   - proper termination (still have issue with
+#     Process(stdout=sys.stdout), but punting on that)
+#   - DavidA: if I specify "unbuffered" for my stdin handler (in the
+#     Process constructor) then the stdin IOBuffer should do a
+#     fparent.read() rather than a fparent.readline(). TrentM: can I do
+#     that? What happens?
 #   - fit it into current invocation structure
 #   - passing in handlers, or callbacks?
 #   - ensure can pass things like cwd and the environment to use
+#   - handling failure to launch, what are the semantics
 #   - make it work for linux too
 
 import os
 import sys
 import threading
-from cStringIO import StringIO
+import types
 import pprint 
 import win32api
 import win32file
 import win32pipe
 import pywintypes
 import win32process
+import win32event
+
+
+#---- exceptions
 
 class ProcessError(Exception):
-    pass
+    def __init__(self, msg, errno=None):
+        Exception.__init__(msg)
+        self.errno = errno
+
+
 
+#---- internal logging facility
 
-#---- globals and constants
+class Logger:
+    DEBUG, INFO, WARN, ERROR, FATAL = range(5)
+    def __init__(self, threshold=None, streamOrFileName=sys.stderr):
+        if threshold is None:
+            self.threshold = self.WARN
+        else:
+            self.threshold = threshold
+        if type(streamOrFileName) == types.StringType:
+            self.stream = open(streamOrFileName, 'w')
+            self._opennedStream = 1
+        else:
+            self.stream = streamOrFileName
+            self._opennedStream = 0
+    def __del__(self):
+        if self._opennedStream:
+            self.stream.close()
+    def _getLevelName(self, level):
+        levelNameMap = {
+            self.DEBUG: "DEBUG",
+            self.INFO: "INFO",
+            self.WARN: "WARN",
+            self.ERROR: "ERROR",
+            self.FATAL: "FATAL",
+        }
+        return levelNameMap[level]
+    def log(self, level, msg, *args):
+        if level < self.threshold:
+            return
+        message = "%s: " % self._getLevelName(level).lower()
+        message = message + (msg % args) + "\n"
+        self.stream.write(message)
+        self.stream.flush()
+    def debug(self, msg, *args):
+        self.log(self.DEBUG, msg, *args)
+    def info(self, msg, *args):
+        self.log(self.INFO, msg, *args)
+    def warn(self, msg, *args):
+        self.log(self.WARN, msg, *args)
+    def error(self, msg, *args):
+        self.log(self.ERROR, msg, *args)
+    def fatal(self, msg, *args):
+        self.log(self.FATAL, msg, *args)
 
+if 1:   # normal/production usage
+    log = Logger(Logger.WARN)
+else:   # development/debugging usage
+    log = Logger(Logger.DEBUG)
 
 
 
@@ -62,7 +133,6 @@
 
 #---- public routines
 
-
 class Process:
     #XXX Need docstring here
     #   - stdout/stderr proxy handling
@@ -70,40 +140,68 @@
     #   - termination
     #   - special methods (e.g. .kill())
     #   - how to .start(), i.e. basic usage rules
+    #   - mention that pased in stdin/stdout/stderr objects have to
+    #     implement at least .write (is .write correct for stdin)?
+    #   - if you pass in stdin, stdout, and/or stderr streams it is the
+    #     user's responsibility to close them afterwards.
     #   - etc.
     #TODO:
     #   - should protect some attributes, e.g. env, cwd, argv
+    #   - .suspend() and .resume()? See Win32::Process Perl module.
     #
+    INFINITE = win32event.INFINITE
+    WAIT_FAILED = win32event.WAIT_FAILED
+    WAIT_TIMEOUT = win32event.WAIT_TIMEOUT
+
     def __init__(self, argv, cwd=None, env=None,
                  stdin=None, stdout=None, stderr=None):
-        print "XXX Process.__init__(argv=%r, cwd=%r, env=%r, stdin=%r, "\
-              "stdout=%r, stderr=%r)"\
-              % (argv, cwd, env, stdin, stdout, stderr)
+        log.info("Process.__init__(argv=%r, cwd=%r, env=%r, stdin=%r, "\
+                 "stdout=%r, stderr=%r)"\
+                 % (argv, cwd, env, stdin, stdout, stderr))
         self.argv = argv
         if not self.argv:
             raise ProcessError("You must specify an argv to drive.")
         self.cwd = cwd
         self.env = env
-##        if stdin is None:
-##            # XXX StringIO is no good here. The user's p.stdin.write()
-##            #     should go through to the child process.
-##            self.stdin = StringIO()
-##            self.stdin = InFileProxy()
-##        else:
-        self.stdin = stdin
+        if stdin is None:
+            self.stdin = IOBuffer('<stdin>')
+        else:
+            self.stdin = stdin
         if stdout is None:
-            self.stdout = StringIO()
+            self.stdout = IOBuffer('<stdout>')
         else:
             self.stdout = stdout
         if stderr is None:
-            self.stderr = StringIO()
+            self.stderr = IOBuffer('<stderr>')
         else:
             self.stderr = stderr
         if self.cwd or self.env:
             raise NotImplementedError("Cannot handle some of these args yet.")
 
+    def __del__(self):
+        log.info("[%s] Process.__del__()" % id(self))
+        # Ensure that all IOBuffer's are closed. If they are not, these
+        # can cause hangs. 
+        if isinstance(self.stdin, IOBuffer):
+            # Do not close user-specified streams. That is their
+            # responsibility.
+            log.info("[%s] Process: closing stdin (%r)."\
+                     % (id(self), self.stdin))
+            self.stdin.close()
+        if isinstance(self.stdout, IOBuffer):
+            # Do not close user-specified streams. That is their
+            # responsibility.
+            log.info("[%s] Process: closing stdout (%r)."\
+                     % (id(self), self.stdout))
+            self.stdout.close()
+        if isinstance(self.stderr, IOBuffer):
+            # Do not close user-specified streams. That is their
+            # responsibility.
+            log.info("[%s] Process: closing stderr (%r)."\
+                     % (id(self), self.stderr))
+            self.stderr.close()
+
     def start(self):
-        print "XXX Process.start()"
         # Create pipes for std handles.
         # (Set the bInheritHandle flag so pipe handles are inherited.)
         saAttr = pywintypes.SECURITY_ATTRIBUTES()
@@ -114,12 +212,41 @@
         childStdoutRd, childStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
         childStderrRd, childStderrWr = win32pipe.CreatePipe(saAttr, 0) 
 
+        # Duplicate the parent ends of the pipes so they are not
+        # inherited. 
+        childStdinWrDup = win32api.DuplicateHandle(
+            win32api.GetCurrentProcess(),
+            childStdinWr,
+            win32api.GetCurrentProcess(),
+            0,
+            0, # not inherited
+            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+        win32api.CloseHandle(childStdinWr)
+        childStdinWr = childStdinWrDup
+        childStdoutRdDup = win32api.DuplicateHandle(
+            win32api.GetCurrentProcess(),
+            childStdoutRd,
+            win32api.GetCurrentProcess(),
+            0,
+            0, # not inherited
+            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+        win32api.CloseHandle(childStdoutRd)
+        childStdoutRd = childStdoutRdDup
+        childStderrRdDup = win32api.DuplicateHandle(
+            win32api.GetCurrentProcess(),
+            childStderrRd,
+            win32api.GetCurrentProcess(),
+            0,
+            0, # not inherited
+            2) # win32api.DUPLICATE_SAME_ACCESS is not defined in PyWin32
+        win32api.CloseHandle(childStderrRd)
+        childStderrRd = childStderrRdDup
+
         #XXX Look into setvbuf() to optionally make the pipe streams
         #    unbuffered. Note that I don't know of a Python-level iface to
         #    this so would have to write a small extension for this.
         #    c.f. PyFile_SetBufSize()
-        #XXX Have to do the setting of inheritablility? I don't think
-        #    so.
+
         #XXX cwd and env setup.
 
         # Start the child process.
@@ -133,47 +260,223 @@
         startupInfo.hStdError = childStderrWr
         startupInfo.dwFlags |= win32process.STARTF_USESTDHANDLES
 
-        print "XXX Process.start(): call CreateProcess(cmdLine=%r)" % cmdLine
-        hProcess, hThread, dwProcessId, dwThreadId = win32process.CreateProcess(
-            None,           # app name
-            cmdLine,        # command line 
-            None,           # process security attributes 
-            None,           # primary thread security attributes 
-            1,              # handles are inherited 
-            0,              # creation flags 
-            None,           # use parent's environment 
-            None,           # use parent's current directory 
-            startupInfo)    # STARTUPINFO pointer 
-        win32api.CloseHandle(hThread) #XXX copying koprocess.cpp
+        log.info("Process.start(): call CreateProcess(cmdLine=%r)" % cmdLine)
+        self._hProcess, hThread, dwProcessId, dwThreadId\
+            = win32process.CreateProcess(
+                None,           # app name
+                cmdLine,        # command line 
+                None,           # process security attributes 
+                None,           # primary thread security attributes 
+                1,              # handles are inherited 
+                0,              # creation flags 
+                None,           # use parent's environment 
+                None,           # use parent's current directory 
+                startupInfo)    # STARTUPINFO pointer 
+        win32api.CloseHandle(hThread) #XXX copying koprocess.cpp here
 
         # Create proxy threads for the out pipes.
-        # XXX Need some what to decide whether stdin need be hooked up.
-        #     Allow passing in of pipe ends?
+        win32file.CloseHandle(childStdinRd)
+        stdinProxy = InFileProxy(self.stdin, childStdinWr, name='<stdin>')
+        stdinProxy.start()
         win32file.CloseHandle(childStdoutWr)
-        stdoutProxy = OutFileProxy(childStdoutRd, self.stdout)
+        stdoutProxy = OutFileProxy(childStdoutRd, self.stdout,
+                                   self.stdin, name='<stdout>')
         stdoutProxy.start()
         win32file.CloseHandle(childStderrWr)
-        stderrProxy = OutFileProxy(childStderrRd, self.stderr)
+        stderrProxy = OutFileProxy(childStderrRd, self.stderr,
+                                   name='<stderr>')
         stderrProxy.start()
-        win32file.CloseHandle(childStdinRd)
-        stdinProxy = InFileProxy(childStdinWr, self.stdin)
-        stdinProxy.start()
 
         #XXX Cleanup?
 
+    def wait(self, timeout=None): 
+        """Wait for the started process to complete.
+        
+        A 'timeone' floating point number of seconds after which to
+        timeout.  If the wait time's out or there is some other error it
+        will raise a ProcessError. Otherwise it returns the child's exit
+        value.
+        
+        XXX Or should returning the exit value be move out to another
+            function as on Win32 process control?
+        """
+        log.info("[%s] Process.wait(timeout=%r)" % (id(self), timeout))
+        if timeout is None:
+            timeout = win32event.INFINITE
+        else:
+            timeout = timeout * 1000.0 # Win32 API's timeout is in millisecs
+
+        log.debug("[%s] Process.wait(): call WaitForSingleObject(timeout=%r)" % (id(self), timeout))
+        rc = win32event.WaitForSingleObject(self._hProcess, timeout)
+        log.debug("[%s] Process.wait(): rc from WaitForSingleObject is %r" % (id(self), rc))
+        if rc == win32event.WAIT_FAILED:
+            raise ProcessError("'WAIT_FAILED' when waiting for process to "\
+                               "terminate: %r" % self.argv, rc)
+        elif rc == win32event.WAIT_TIMEOUT:
+            raise ProcessError("'WAIT_TIMEOUT' when waiting for process to "\
+                               "terminate: %r" % self.argv, rc)
+
+        return win32process.GetExitCodeProcess(self._hProcess)
+
+    def kill(self, exitCode=0):
+        return win32process.TerminateProcess(self._hProcess, exitCode)
+
+
+
+class IOBuffer:
+    """Want to be able to both read and write to this buffer from
+    difference threads and have the same read/write semantic as for a
+    std handler.
+
+    Supported methods:
+        .write(s)
+        .writelines(lines)
+        .read(n=-1)
+        .readline(length=None)
+        .flush()   # No-op
+        .close()
+
+    Would be nice to support:
+        .readlines(sizehint=0)
+
+    Cannot support:
+        .seek()     # Because we are managing *two* positions (one each
+        .tell()     #   for reading and writing), these do not make
+                    #   sense.
+    """
+    #TODO:
+    #   - Is performance a problem? This will likely be slower that
+    #     StringIO.StringIO().
+    #
+    def __init__(self, name=None):
+        """'name' can be set for debugging, it will be used in log messages."""
+        if name is not None:
+            self._name = name
+        else:
+            self._name = id(self)
+        log.info("[%s] IOBuffer.__init__()" % self._name)
+        self._buf = ''
+        # A state change is defined as the buffer being closed or a
+        # write occuring.
+        self._stateChange = threading.Condition()
+        self._mutex = threading.Lock()
+        self._closed = 0
+
+    def write(self, s):
+        log.info("[%s] IOBuffer.write(s=%r)" % (self._name, s))
+        # Silently drop writes after the buffer has been close()'d.
+        if self._closed:
+            return
+
+        self._mutex.acquire()
+        self._buf += s                  # Append to buffer.
+        self._stateChange.acquire()
+        self._stateChange.notifyAll()   # Notify of the write().
+        self._stateChange.release()
+        self._mutex.release()
+
+    def writelines(self, list):
+        self.write(''.join(list))
+
+    def read(self, n=-1):
+        log.info("[%s] IOBuffer.read(n=%r)" % (self._name, n))
+        log.info("[%s] IOBuffer.read(): wait for data" % self._name)
+        if n < 0:
+            # Wait until the buffer is closed, i.e. no more writes will
+            # come.
+            while not self._closed:
+                self._stateChange.acquire()
+                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()" % self._name)
+                self._stateChange.wait()
+                #log.debug("[%s]     >>> IOBuffer.read: done state change .wait()" % self._name)
+                self._stateChange.release()
+        else:
+            # Wait until there are the requested number of bytes to read
+            # (or until the buffer is closed, i.e. no more writes will
+            # come).
+            while not self._closed or len(self._buf) < n:
+                self._stateChange.acquire()
+                #log.debug("[%s]     <<< IOBuffer.read: state change .wait()" % self._name)
+                self._stateChange.wait()
+                #log.debug("[%s]     >>> IOBuffer.read: done state change .wait()" % self._name)
+                self._stateChange.release()
+        log.info("[%s] IOBuffer.read(): done waiting for data" % self._name)
+
+        self._mutex.acquire()
+        if n < 0:
+            idx = len(self._buf)
+        else:
+            idx = min(n, len(self._buf))
+        retval, self._buf = self._buf[:idx], self._buf[idx:]
+        self._mutex.release()
+        return retval
+
+    def readline(self, length=None):
+        # Wait until there is a full line (or at least 'length' bytes)
+        # in the buffer or until the buffer is closed, i.e. no more
+        # writes will come.
+        log.info("[%s] IOBuffer.readline(length=%r)" % (self._name, length))
+
+        log.info("[%s] IOBuffer.readline(): wait for data" % self._name)
+        self._stateChange.acquire()
+        while 1:
+            if self._closed: break
+            if self._buf.find('\n') != -1: break
+            if length is not None and len(self._buf) >= length: break
+            self._stateChange.wait()
+        self._stateChange.release()
+        log.info("[%s] IOBuffer.readline(): done waiting for data"\
+                 % self._name)
+
+        self._mutex.acquire()
+        idx = self._buf.find('\n')
+        if idx == -1:
+            idx = len(self._buf)
+        else:
+            idx += 1 # include the '\n'
+        if length is not None:
+            idx = min(idx, length)
+        retval, self._buf = self._buf[:idx], self._buf[idx:]
+        self._mutex.release()
+        return retval
+
+    def close(self):
+        if not self._closed:
+            log.info("[%s] IOBuffer.close()" % self._name)
+            self._stateChange.acquire()
+            self._closed = 1
+            self._stateChange.notifyAll()   # Notify of the close().
+            self._stateChange.release()
+
+    def flush(self):
+        log.info("[%s] IOBuffer.flush()" % self._name)
 
+
 class InFileProxy(threading.Thread):
     """A thread to proxy stdin.write()'s from the parent to the child."""
-    def __init__(self, fchild, fparent):
-        threading.Thread.__init__(self)
+    def __init__(self, fparent, fchild, name):
+        """
+        "fparent" is a Python file-like object setup for writing.
+        "fchild" is a Win32 handle to the a child process' output pipe.
+        "name" can be set for debugging, it will be used in log messages.
+        """
+        threading.Thread.__init__(self, name=name)
         self.fchild = fchild
-        # XXX What if fparent is None? What if fparent is just a
-        #     file-like object and not a file descriptor on which
-        #     win32file.ReadFile can be called?
         self.fparent = fparent
 
     def run(self):
-        print "XXX [%s] InFileProxy.run()" % self.getName()
+        log.info("[%s] InFileProxy.run()" % self.getName())
+        try:
+            self._proxyFromParentToChild()
+        finally:
+            if isinstance(self.fparent, IOBuffer):
+                # Do not close user-specified streams. That is their
+                # responsibility.
+                log.info("[%s] InFileProxy: closing parent (%r)"\
+                         % (self.getName(), self.fparent))
+                self.fparent.close()
+
+    def _proxyFromParentToChild(self):
         # This is a reasonable buffer size, on Windows at least.
         # Reducing this number will result in more 'ReadFile' calls.
         # Reducing it will NOT help to get output more smoothly from the
@@ -183,46 +486,96 @@
         # Read output from the child process, and (for now) just write
         # it out.
         while 1:
-            print "XXX [%s] InFileProxy: waiting for .read() on %r"\
-                  % (self.getName(), self.fparent)
-            text = self.fparent.readline(BUFSIZE)
+            log.info("[%s] InFileProxy: waiting for read on parent (%r)"\
+                     % (self.getName(), self.fparent))
+            # XXX Get hangs here (!) even with
+            #     self.stdin.close() in Process' __del__() under this
+            #     cond:
+            #           p = Process([...], stdin=sys.stdin)
+            #     The user must manually send '\n' via <Enter> or EOF
+            #     via <Ctrl-Z> to unlock this. How to get around that?
+            #     See cleanOnTermination note in OutFileProxy.run()
+            #     below.
+            #log.debug("XXX          -> start readline() on %r" % self.fparent)
+            try:
+                text = self.fparent.readline(BUFSIZE)
+            except ValueError, ex:
+                # ValueError is raised with trying to write to a closed
+                # file/pipe.
+                text = None
+            #log.debug("XXX          <- done readline() on %r" % self.fparent)
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the parent's end.
-                print "XXX [%s] InFileProxy: observed close of %r"\
-                      % (self.getName(), self.fparent)
+                log.info("[%s] InFileProxy: observed close of parent (%r)"\
+                         % (self.getName(), self.fparent))
+                # Signal the child so it knows to stop listening.
+                win32file.CloseHandle(self.fchild)
                 break
+            else:
+                log.info("[%s] InFileProxy: read %d bytes from parent: %r"\
+                         % (self.getName(), len(text), text))
 
-            print "XXX [%s] InFileProxy: text(len=%d): %r"\
-                  % (self.getName(), len(text), text)
             try:
-                errCode, nBytesWritten = win32file.WriteFile(self.fchild, text)
+                log.debug("writing %r to child" % text)
+                errCode, nBytesWritten = win32file.WriteFile(self.fchild,
+                                                             text)
             except pywintypes.error, ex:
                 # Ignore errors for now, like "The pipe is being closed.",
                 # etc. XXX There *may* be errors we don't want to avoid.
-                print "XXX [%s] InFileProxy: error writing to %r, "\
-                      "closing: %s" % (self.getName(), self.fparent, ex)
+                log.info("[%s] InFileProxy: error writing to child (%r), "\
+                         "closing: %s" % (self.getName(), self.fparent, ex))
                 break
             assert errCode == 0,\
                    "Why is 'errCode' from WriteFile non-zero? %r" % errCode
             if not nBytesWritten:
                 # No bytes written signifies that the pipe has been
                 # closed on the child's end.
-                print "XXX [%s] InFileProxy: observed close of %r"\
-                      % (self.getName(), self.fchild)
+                log.info("[%s] InFileProxy: observed close of child (%r)"\
+                         % (self.getName(), self.fchild))
                 break
+            else:
+                log.info("[%s] InFileProxy: wrote %d bytes to child: %r"\
+                         % (self.getName(), len(text), text))
 
 class OutFileProxy(threading.Thread):
     """A thread to watch an "out" file from the spawned child process
     and pass on write's to the parent.
     """
-    def __init__(self, fchild, fparent):
-        threading.Thread.__init__(self)
+    def __init__(self, fchild, fparent, cleanOnTermination=None,
+                 name=None):
+        """
+        "fchild" is a Win32 handle to the a child process' output pipe.
+        "fparent" is a Python file-like object setup for writing.
+        "cleanOnTermination" is a file-like object to clean up on close
+            of this proxy.
+        "name" can be set for debugging, it will be used in log messages.
+        """
+        threading.Thread.__init__(self, name=name)
         self.fchild = fchild
         self.fparent = fparent
+        self.cleanOnTermination = cleanOnTermination
 
     def run(self):
-        print "XXX [%s] OutFileProxy.run()" % self.getName()
+        log.info("[%s] OutFileProxy.run()" % self.getName())
+        try:
+            self._proxyFromChildToParent()
+        finally:
+            if isinstance(self.fparent, IOBuffer):
+                # Do not close user-specified streams. That is their
+                # responsibility.
+                log.info("[%s] OutFileProxy: closing parent (%r)"\
+                         % (self.getName(), self.fparent))
+                self.fparent.close()
+            if self.cleanOnTermination:
+                self.cleanOnTermination.write('')
+                # XXX Doing this relieves the
+                #     must-<Enter>-to-term-test_stdin_sysstdin problem
+                #     but I don't think it is the right thing to do.
+                #     Over my head.
+                #self.cleanOnTermination.close()
+
+    def _proxyFromChildToParent(self):
         # This is a reasonable buffer size, on Windows at least.
         # Reducing this number will result in more 'ReadFile' calls.
         # Reducing it will NOT help to get output more smoothly from the
@@ -233,58 +586,25 @@
         # it out.
         while 1:
             try:
-                print "XXX [%s] OutFileProxy: waiting for read on %r"\
-                      % (self.getName(), self.fchild)
+                log.info("[%s] OutFileProxy: waiting for read on child (%r)"\
+                         % (self.getName(), self.fchild))
                 hr, text = win32file.ReadFile(self.fchild, BUFSIZE)
             except pywintypes.error, ex:
                 # Ignore errors for now, like "The pipe is being closed.",
                 # etc. XXX There *may* be errors we don't want to avoid.
-                print "XXX [%s] OutFileProxy: error reading from %r, "\
-                      "closing: %s" % (self.getName(), self.fchild, ex)
+                log.info("[%s] OutFileProxy: error reading from child (%r), "\
+                         "closing: %s" % (self.getName(), self.fchild, ex))
                 break
             assert hr == 0, "Why is 'hr' from ReadFile non-zero? %r" % hr
             if not text:
                 # Empty text signifies that the pipe has been closed on
                 # the child's end.
-                print "XXX [%s] OutFileProxy: observed close of %r"\
-                      % (self.getName(), self.fchild)
+                log.info("[%s] OutFileProxy: observed close of child (%r)"\
+                         % (self.getName(), self.fchild))
                 break
 
-            print "XXX [%s] OutFileProxy: text(len=%d): %r"\
-                  % (self.getName(), len(text), text)
+            log.info("[%s] OutFileProxy: text(len=%d): %r"\
+                     % (self.getName(), len(text), text))
             self.fparent.write(text)
 
 
-#---- testing stuff
-
-class MyOutFile:
-    def __init__(self, name):
-        self.name = name
-    def write(self, text):
-        print "XXX [%s] MyOutFile.write(text=%r)" % (self.name, text)
-
-def test_runcommand_justrunit_sysstdin(argv):
-    print "XXX test_runcommand_justrunit(argv=%r)" % argv
-    p = Process(argv=argv, stdout=MyOutFile('<stdout>'),
-                stderr=MyOutFile('<stderr>'), stdin=sys.stdin)
-    p.start()
-
-##def test_runcommand_justrunit_manualstdin(argv):
-##    print "XXX test_runcommand_justrunit(argv=%r)" % argv
-##    p = Process(argv=argv, stdout=MyOutFile('<stdout>'),
-##                stderr=MyOutFile('<stderr>'))
-##    p.stdin.write("Trent")
-##    p.start()
-
-def main(argv):
-    #XXX getopt handling for --cwd=, --env=/-D, etc.
-    module = sys.modules[__name__]
-    tests = [attr for name, attr in module.__dict__.items()\
-             if name.startswith('test_')]
-    for test in tests:
-        test(argv[1:])
- 
-if __name__ == "__main__":
-    sys.exit( main(sys.argv) )
-
-
Change 40619 by trentm@trentm-razor on 2002/05/30 14:15:03

	Clean out some cruft.

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#2 edit

Differences ...

==== //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#2 (text) ====

@@ -25,8 +25,6 @@
 import pywintypes
 import win32process
 
-class DriveError(Exception):
-    pass
 class ProcessError(Exception):
     pass
 
@@ -256,106 +254,8 @@
                   % (self.getName(), len(text), text)
             self.fparent.write(text)
 
-##def drive(argv, cwd=None, env=None):
-##    """
-##    Notes:
-##        - 'cwd' and 'env' onot implemented yet.
-##    """
-##    print "XXX drive(argv=%r, cwd=%r, env=%r)" % (argv, cwd, env)
-##    if not argv:
-##        raise DriveError("You must specify an argv to drive.")
-##
-##    # Create pipes for std handles.
-##    # (Set the bInheritHandle flag so pipe handles are inherited.)
-##    saAttr = pywintypes.SECURITY_ATTRIBUTES()
-##    saAttr.bInheritHandle = 1
-##    #XXX Should try with os.pipe. Dunno what that does for
-##    #    inheritability though.
-##    hChildStdinRd, hChildStdinWr = win32pipe.CreatePipe(saAttr, 0) 
-##    hChildStdoutRd, hChildStdoutWr = win32pipe.CreatePipe(saAttr, 0) 
-##    hChildStderrRd, hChildStderrWr = win32pipe.CreatePipe(saAttr, 0) 
-##
-##    #XXX Look into setvbuf() to optionally make the pipe streams
-##    #    unbuffered. Note that I don't know of a Python-level iface to
-##    #    this so would have to write a small extension for this.
-##    #    c.f. PyFile_SetBufSize()
-##    #XXX Have to do the setting of inheritablility???
-##    #XXX cwd and env setup.
-##
-##    # Start the child process.
-##    cmdLine = _joinArgv(argv)
-##
-##    startupInfo = win32process.STARTUPINFO() 
-##    startupInfo.dwFlags = win32process.STARTF_USESHOWWINDOW
-##    startupInfo.wShowWindow = 0 # SW_HIDE
-##    startupInfo.hStdInput = hChildStdinRd
-##    startupInfo.hStdOutput = hChildStdoutWr
-##    startupInfo.hStdError = hChildStderrWr
-##    startupInfo.dwFlags |= win32process.STARTF_USESTDHANDLES
-##
-##    hProcess, hThread, dwProcessId, dwThreadId = win32process.CreateProcess(
-##        None,           # app name
-##        cmdLine,        # command line 
-##        None,           # process security attributes 
-##        None,           # primary thread security attributes 
-##        1,              # handles are inherited 
-##        0,              # creation flags 
-##        None,           # use parent's environment 
-##        None,           # use parent's current directory 
-##        startupInfo)    # STARTUPINFO pointer 
-##    win32api.CloseHandle(hThread) #XXX copying koprocess.cpp
-##
-##    # Create reader (XXX and writer?) threads.
-##    # XXX Need some what to decide whether stdin need be hooked up.
-##    #     Allow passing in of pipe ends?
-##    stdoutReader = Reader('<stdout>', hChildStdoutRd)
-##    win32file.CloseHandle(hChildStdoutWr)
-##    stdoutReader.start()
-##    stderrReader = Reader('<stderr>', hChildStderrRd)
-##    win32file.CloseHandle(hChildStderrWr)
-##    stderrReader.start()
-##    win32file.CloseHandle(hChildStdinRd)
-##
-####    #XXX test -------------------- (it works!)
-####    errCode, nBytesWritten = win32file.WriteFile(hChildStdinWr, "foo\n")
-####    assert errCode == 0, "Why is 'errCode' from WriteFile non-zero? %r"\
-####                         % errCode
-####    if not nBytesWritten:
-####        raise "failed to write 'foo' to child's stdin"
-####    #XXX test --------------------
-##
-##    #XXX Cleanup?
-##
-##
-##class Reader(threading.Thread):
-##    def __init__(self, name, fd):
-##        threading.Thread.__init__(self, name=name)
-##        self.fd = fd
-##
-##    def run(self):
-##        print "XXX [%s] Reader.run()" % self.getName()
-##        # This is a reasonable buffer size, on Windows at least.
-##        # Reducing this number will result in more 'ReadFile' calls.
-##        # Reducing it will NOT help to get output more smoothly from the
-##        # other end of the pipe (this is true for buffered and unbuffer
-##        # I/O situations).
-##        BUFSIZE = 4096
-##        # Read output from the child process, and (for now) just write
-##        # it out.
-##        while 1:
-##            try:
-##                hr, text = win32file.ReadFile(self.fd, BUFSIZE)
-##            except pywintypes.error, ex:
-##                # Ignore errors for now, like "pipe already closed",
-##                # etc. XXX There *may* be errors we don't want to avoid.
-##                break
-##            assert hr == 0, "Why is 'hr' from ReadFile non-zero? %r" % hr
-##            if not text:
-##                break
-##
-##            print "XXX [%s] text(len=%d): %r"\
-##                  % (self.getName(), len(text), text)
 
+#---- testing stuff
 
 class MyOutFile:
     def __init__(self, name):
@@ -386,3 +286,5 @@
  
 if __name__ == "__main__":
     sys.exit( main(sys.argv) )
+
+
Change 40617 by trentm@trentm-razor on 2002/05/30 14:13:40

	A starter at a replacement for our koprocess.cpp stuff.
	   The basic API is in place, but there are still many things to work out.
	   Currently you can test via: python process.py <command line to run>

Affected files ...

... //depot/main/Apps/Komodo-devel/src/python-sitelib/process.py#1 add

Differences ...
